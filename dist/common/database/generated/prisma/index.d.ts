
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Users
 * 
 */
export type Users = $Result.DefaultSelection<Prisma.$UsersPayload>
/**
 * Model Residents
 * 
 */
export type Residents = $Result.DefaultSelection<Prisma.$ResidentsPayload>
/**
 * Model Employees
 * 
 */
export type Employees = $Result.DefaultSelection<Prisma.$EmployeesPayload>
/**
 * Model Complaints
 * 
 */
export type Complaints = $Result.DefaultSelection<Prisma.$ComplaintsPayload>
/**
 * Model Announcements
 * 
 */
export type Announcements = $Result.DefaultSelection<Prisma.$AnnouncementsPayload>
/**
 * Model ForumPosts
 * 
 */
export type ForumPosts = $Result.DefaultSelection<Prisma.$ForumPostsPayload>
/**
 * Model PostTags
 * 
 */
export type PostTags = $Result.DefaultSelection<Prisma.$PostTagsPayload>
/**
 * Model ForumComments
 * 
 */
export type ForumComments = $Result.DefaultSelection<Prisma.$ForumCommentsPayload>
/**
 * Model Units
 * 
 */
export type Units = $Result.DefaultSelection<Prisma.$UnitsPayload>
/**
 * Model Bills
 * 
 */
export type Bills = $Result.DefaultSelection<Prisma.$BillsPayload>
/**
 * Model Payments
 * 
 */
export type Payments = $Result.DefaultSelection<Prisma.$PaymentsPayload>
/**
 * Model Contacts
 * 
 */
export type Contacts = $Result.DefaultSelection<Prisma.$ContactsPayload>
/**
 * Model SecurityReports
 * 
 */
export type SecurityReports = $Result.DefaultSelection<Prisma.$SecurityReportsPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
  RESIDENT: 'RESIDENT',
  EMPLOYEE: 'EMPLOYEE'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const EmployeeRole: {
  ADMIN: 'ADMIN',
  PROPERTY_MANAGER: 'PROPERTY_MANAGER',
  TECHNICIAN: 'TECHNICIAN',
  SECURITY: 'SECURITY',
  NONE: 'NONE'
};

export type EmployeeRole = (typeof EmployeeRole)[keyof typeof EmployeeRole]


export const Gender: {
  MALE: 'MALE',
  FEMALE: 'FEMALE',
  NONE: 'NONE'
};

export type Gender = (typeof Gender)[keyof typeof Gender]


export const ResidentStatus: {
  HEAD_HOUSE_HOLD: 'HEAD_HOUSE_HOLD',
  FAMILY_MEMBERS: 'FAMILY_MEMBERS'
};

export type ResidentStatus = (typeof ResidentStatus)[keyof typeof ResidentStatus]


export const PostedBy: {
  RESIDENT: 'RESIDENT',
  EMPLOYEE: 'EMPLOYEE'
};

export type PostedBy = (typeof PostedBy)[keyof typeof PostedBy]


export const UnitStatus: {
  OCCUPIED: 'OCCUPIED',
  VACANT: 'VACANT',
  MAINTENANCE: 'MAINTENANCE'
};

export type UnitStatus = (typeof UnitStatus)[keyof typeof UnitStatus]


export const PaymentStatus: {
  PAID: 'PAID',
  PENDING: 'PENDING',
  OVERDUE: 'OVERDUE',
  CANCELLED: 'CANCELLED'
};

export type PaymentStatus = (typeof PaymentStatus)[keyof typeof PaymentStatus]


export const PaymentMethod: {
  BANK_TRANSFER: 'BANK_TRANSFER',
  E_WALLET: 'E_WALLET',
  CREDIT_CARD: 'CREDIT_CARD',
  CASH: 'CASH'
};

export type PaymentMethod = (typeof PaymentMethod)[keyof typeof PaymentMethod]


export const MaintenanceCategory: {
  LOW: 'LOW',
  MEDIUM: 'MEDIUM',
  HIGH: 'HIGH',
  URGENT: 'URGENT'
};

export type MaintenanceCategory = (typeof MaintenanceCategory)[keyof typeof MaintenanceCategory]


export const MaintenanceStatus: {
  NEW: 'NEW',
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED'
};

export type MaintenanceStatus = (typeof MaintenanceStatus)[keyof typeof MaintenanceStatus]


export const PaymentType: {
  CICILAN_KPR: 'CICILAN_KPR',
  IURAN_BULANAN: 'IURAN_BULANAN'
};

export type PaymentType = (typeof PaymentType)[keyof typeof PaymentType]


export const ContactRole: {
  EMPLOYEE: 'EMPLOYEE',
  EMERGENCY_SERVICES: 'EMERGENCY_SERVICES'
};

export type ContactRole = (typeof ContactRole)[keyof typeof ContactRole]


export const ComplaintStatus: {
  NEW: 'NEW',
  VERIFIED: 'VERIFIED',
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED'
};

export type ComplaintStatus = (typeof ComplaintStatus)[keyof typeof ComplaintStatus]

}

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type EmployeeRole = $Enums.EmployeeRole

export const EmployeeRole: typeof $Enums.EmployeeRole

export type Gender = $Enums.Gender

export const Gender: typeof $Enums.Gender

export type ResidentStatus = $Enums.ResidentStatus

export const ResidentStatus: typeof $Enums.ResidentStatus

export type PostedBy = $Enums.PostedBy

export const PostedBy: typeof $Enums.PostedBy

export type UnitStatus = $Enums.UnitStatus

export const UnitStatus: typeof $Enums.UnitStatus

export type PaymentStatus = $Enums.PaymentStatus

export const PaymentStatus: typeof $Enums.PaymentStatus

export type PaymentMethod = $Enums.PaymentMethod

export const PaymentMethod: typeof $Enums.PaymentMethod

export type MaintenanceCategory = $Enums.MaintenanceCategory

export const MaintenanceCategory: typeof $Enums.MaintenanceCategory

export type MaintenanceStatus = $Enums.MaintenanceStatus

export const MaintenanceStatus: typeof $Enums.MaintenanceStatus

export type PaymentType = $Enums.PaymentType

export const PaymentType: typeof $Enums.PaymentType

export type ContactRole = $Enums.ContactRole

export const ContactRole: typeof $Enums.ContactRole

export type ComplaintStatus = $Enums.ComplaintStatus

export const ComplaintStatus: typeof $Enums.ComplaintStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.users.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.users.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.users`: Exposes CRUD operations for the **Users** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.users.findMany()
    * ```
    */
  get users(): Prisma.UsersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.residents`: Exposes CRUD operations for the **Residents** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Residents
    * const residents = await prisma.residents.findMany()
    * ```
    */
  get residents(): Prisma.ResidentsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.employees`: Exposes CRUD operations for the **Employees** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Employees
    * const employees = await prisma.employees.findMany()
    * ```
    */
  get employees(): Prisma.EmployeesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.complaints`: Exposes CRUD operations for the **Complaints** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Complaints
    * const complaints = await prisma.complaints.findMany()
    * ```
    */
  get complaints(): Prisma.ComplaintsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.announcements`: Exposes CRUD operations for the **Announcements** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Announcements
    * const announcements = await prisma.announcements.findMany()
    * ```
    */
  get announcements(): Prisma.AnnouncementsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.forumPosts`: Exposes CRUD operations for the **ForumPosts** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ForumPosts
    * const forumPosts = await prisma.forumPosts.findMany()
    * ```
    */
  get forumPosts(): Prisma.ForumPostsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.postTags`: Exposes CRUD operations for the **PostTags** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PostTags
    * const postTags = await prisma.postTags.findMany()
    * ```
    */
  get postTags(): Prisma.PostTagsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.forumComments`: Exposes CRUD operations for the **ForumComments** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ForumComments
    * const forumComments = await prisma.forumComments.findMany()
    * ```
    */
  get forumComments(): Prisma.ForumCommentsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.units`: Exposes CRUD operations for the **Units** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Units
    * const units = await prisma.units.findMany()
    * ```
    */
  get units(): Prisma.UnitsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bills`: Exposes CRUD operations for the **Bills** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bills
    * const bills = await prisma.bills.findMany()
    * ```
    */
  get bills(): Prisma.BillsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payments`: Exposes CRUD operations for the **Payments** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payments.findMany()
    * ```
    */
  get payments(): Prisma.PaymentsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contacts`: Exposes CRUD operations for the **Contacts** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contacts
    * const contacts = await prisma.contacts.findMany()
    * ```
    */
  get contacts(): Prisma.ContactsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.securityReports`: Exposes CRUD operations for the **SecurityReports** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SecurityReports
    * const securityReports = await prisma.securityReports.findMany()
    * ```
    */
  get securityReports(): Prisma.SecurityReportsDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.14.0
   * Query Engine version: 717184b7b35ea05dfa71a3236b7af656013e1e49
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Users: 'Users',
    Residents: 'Residents',
    Employees: 'Employees',
    Complaints: 'Complaints',
    Announcements: 'Announcements',
    ForumPosts: 'ForumPosts',
    PostTags: 'PostTags',
    ForumComments: 'ForumComments',
    Units: 'Units',
    Bills: 'Bills',
    Payments: 'Payments',
    Contacts: 'Contacts',
    SecurityReports: 'SecurityReports'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "users" | "residents" | "employees" | "complaints" | "announcements" | "forumPosts" | "postTags" | "forumComments" | "units" | "bills" | "payments" | "contacts" | "securityReports"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Users: {
        payload: Prisma.$UsersPayload<ExtArgs>
        fields: Prisma.UsersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UsersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UsersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          findFirst: {
            args: Prisma.UsersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UsersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          findMany: {
            args: Prisma.UsersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>[]
          }
          create: {
            args: Prisma.UsersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          createMany: {
            args: Prisma.UsersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UsersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>[]
          }
          delete: {
            args: Prisma.UsersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          update: {
            args: Prisma.UsersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          deleteMany: {
            args: Prisma.UsersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UsersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UsersUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>[]
          }
          upsert: {
            args: Prisma.UsersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          aggregate: {
            args: Prisma.UsersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsers>
          }
          groupBy: {
            args: Prisma.UsersGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsersGroupByOutputType>[]
          }
          count: {
            args: Prisma.UsersCountArgs<ExtArgs>
            result: $Utils.Optional<UsersCountAggregateOutputType> | number
          }
        }
      }
      Residents: {
        payload: Prisma.$ResidentsPayload<ExtArgs>
        fields: Prisma.ResidentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ResidentsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResidentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ResidentsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResidentsPayload>
          }
          findFirst: {
            args: Prisma.ResidentsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResidentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ResidentsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResidentsPayload>
          }
          findMany: {
            args: Prisma.ResidentsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResidentsPayload>[]
          }
          create: {
            args: Prisma.ResidentsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResidentsPayload>
          }
          createMany: {
            args: Prisma.ResidentsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ResidentsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResidentsPayload>[]
          }
          delete: {
            args: Prisma.ResidentsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResidentsPayload>
          }
          update: {
            args: Prisma.ResidentsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResidentsPayload>
          }
          deleteMany: {
            args: Prisma.ResidentsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ResidentsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ResidentsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResidentsPayload>[]
          }
          upsert: {
            args: Prisma.ResidentsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResidentsPayload>
          }
          aggregate: {
            args: Prisma.ResidentsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateResidents>
          }
          groupBy: {
            args: Prisma.ResidentsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ResidentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.ResidentsCountArgs<ExtArgs>
            result: $Utils.Optional<ResidentsCountAggregateOutputType> | number
          }
        }
      }
      Employees: {
        payload: Prisma.$EmployeesPayload<ExtArgs>
        fields: Prisma.EmployeesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmployeesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmployeesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeesPayload>
          }
          findFirst: {
            args: Prisma.EmployeesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmployeesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeesPayload>
          }
          findMany: {
            args: Prisma.EmployeesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeesPayload>[]
          }
          create: {
            args: Prisma.EmployeesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeesPayload>
          }
          createMany: {
            args: Prisma.EmployeesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmployeesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeesPayload>[]
          }
          delete: {
            args: Prisma.EmployeesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeesPayload>
          }
          update: {
            args: Prisma.EmployeesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeesPayload>
          }
          deleteMany: {
            args: Prisma.EmployeesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmployeesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EmployeesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeesPayload>[]
          }
          upsert: {
            args: Prisma.EmployeesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeesPayload>
          }
          aggregate: {
            args: Prisma.EmployeesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmployees>
          }
          groupBy: {
            args: Prisma.EmployeesGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmployeesGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmployeesCountArgs<ExtArgs>
            result: $Utils.Optional<EmployeesCountAggregateOutputType> | number
          }
        }
      }
      Complaints: {
        payload: Prisma.$ComplaintsPayload<ExtArgs>
        fields: Prisma.ComplaintsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ComplaintsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ComplaintsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintsPayload>
          }
          findFirst: {
            args: Prisma.ComplaintsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ComplaintsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintsPayload>
          }
          findMany: {
            args: Prisma.ComplaintsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintsPayload>[]
          }
          create: {
            args: Prisma.ComplaintsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintsPayload>
          }
          createMany: {
            args: Prisma.ComplaintsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ComplaintsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintsPayload>[]
          }
          delete: {
            args: Prisma.ComplaintsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintsPayload>
          }
          update: {
            args: Prisma.ComplaintsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintsPayload>
          }
          deleteMany: {
            args: Prisma.ComplaintsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ComplaintsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ComplaintsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintsPayload>[]
          }
          upsert: {
            args: Prisma.ComplaintsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintsPayload>
          }
          aggregate: {
            args: Prisma.ComplaintsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComplaints>
          }
          groupBy: {
            args: Prisma.ComplaintsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ComplaintsGroupByOutputType>[]
          }
          count: {
            args: Prisma.ComplaintsCountArgs<ExtArgs>
            result: $Utils.Optional<ComplaintsCountAggregateOutputType> | number
          }
        }
      }
      Announcements: {
        payload: Prisma.$AnnouncementsPayload<ExtArgs>
        fields: Prisma.AnnouncementsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AnnouncementsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AnnouncementsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementsPayload>
          }
          findFirst: {
            args: Prisma.AnnouncementsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AnnouncementsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementsPayload>
          }
          findMany: {
            args: Prisma.AnnouncementsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementsPayload>[]
          }
          create: {
            args: Prisma.AnnouncementsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementsPayload>
          }
          createMany: {
            args: Prisma.AnnouncementsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AnnouncementsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementsPayload>[]
          }
          delete: {
            args: Prisma.AnnouncementsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementsPayload>
          }
          update: {
            args: Prisma.AnnouncementsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementsPayload>
          }
          deleteMany: {
            args: Prisma.AnnouncementsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AnnouncementsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AnnouncementsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementsPayload>[]
          }
          upsert: {
            args: Prisma.AnnouncementsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementsPayload>
          }
          aggregate: {
            args: Prisma.AnnouncementsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAnnouncements>
          }
          groupBy: {
            args: Prisma.AnnouncementsGroupByArgs<ExtArgs>
            result: $Utils.Optional<AnnouncementsGroupByOutputType>[]
          }
          count: {
            args: Prisma.AnnouncementsCountArgs<ExtArgs>
            result: $Utils.Optional<AnnouncementsCountAggregateOutputType> | number
          }
        }
      }
      ForumPosts: {
        payload: Prisma.$ForumPostsPayload<ExtArgs>
        fields: Prisma.ForumPostsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ForumPostsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumPostsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ForumPostsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumPostsPayload>
          }
          findFirst: {
            args: Prisma.ForumPostsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumPostsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ForumPostsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumPostsPayload>
          }
          findMany: {
            args: Prisma.ForumPostsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumPostsPayload>[]
          }
          create: {
            args: Prisma.ForumPostsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumPostsPayload>
          }
          createMany: {
            args: Prisma.ForumPostsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ForumPostsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumPostsPayload>[]
          }
          delete: {
            args: Prisma.ForumPostsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumPostsPayload>
          }
          update: {
            args: Prisma.ForumPostsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumPostsPayload>
          }
          deleteMany: {
            args: Prisma.ForumPostsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ForumPostsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ForumPostsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumPostsPayload>[]
          }
          upsert: {
            args: Prisma.ForumPostsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumPostsPayload>
          }
          aggregate: {
            args: Prisma.ForumPostsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateForumPosts>
          }
          groupBy: {
            args: Prisma.ForumPostsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ForumPostsGroupByOutputType>[]
          }
          count: {
            args: Prisma.ForumPostsCountArgs<ExtArgs>
            result: $Utils.Optional<ForumPostsCountAggregateOutputType> | number
          }
        }
      }
      PostTags: {
        payload: Prisma.$PostTagsPayload<ExtArgs>
        fields: Prisma.PostTagsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PostTagsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostTagsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PostTagsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostTagsPayload>
          }
          findFirst: {
            args: Prisma.PostTagsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostTagsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PostTagsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostTagsPayload>
          }
          findMany: {
            args: Prisma.PostTagsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostTagsPayload>[]
          }
          create: {
            args: Prisma.PostTagsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostTagsPayload>
          }
          createMany: {
            args: Prisma.PostTagsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PostTagsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostTagsPayload>[]
          }
          delete: {
            args: Prisma.PostTagsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostTagsPayload>
          }
          update: {
            args: Prisma.PostTagsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostTagsPayload>
          }
          deleteMany: {
            args: Prisma.PostTagsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PostTagsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PostTagsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostTagsPayload>[]
          }
          upsert: {
            args: Prisma.PostTagsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostTagsPayload>
          }
          aggregate: {
            args: Prisma.PostTagsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePostTags>
          }
          groupBy: {
            args: Prisma.PostTagsGroupByArgs<ExtArgs>
            result: $Utils.Optional<PostTagsGroupByOutputType>[]
          }
          count: {
            args: Prisma.PostTagsCountArgs<ExtArgs>
            result: $Utils.Optional<PostTagsCountAggregateOutputType> | number
          }
        }
      }
      ForumComments: {
        payload: Prisma.$ForumCommentsPayload<ExtArgs>
        fields: Prisma.ForumCommentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ForumCommentsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumCommentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ForumCommentsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumCommentsPayload>
          }
          findFirst: {
            args: Prisma.ForumCommentsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumCommentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ForumCommentsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumCommentsPayload>
          }
          findMany: {
            args: Prisma.ForumCommentsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumCommentsPayload>[]
          }
          create: {
            args: Prisma.ForumCommentsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumCommentsPayload>
          }
          createMany: {
            args: Prisma.ForumCommentsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ForumCommentsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumCommentsPayload>[]
          }
          delete: {
            args: Prisma.ForumCommentsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumCommentsPayload>
          }
          update: {
            args: Prisma.ForumCommentsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumCommentsPayload>
          }
          deleteMany: {
            args: Prisma.ForumCommentsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ForumCommentsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ForumCommentsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumCommentsPayload>[]
          }
          upsert: {
            args: Prisma.ForumCommentsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumCommentsPayload>
          }
          aggregate: {
            args: Prisma.ForumCommentsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateForumComments>
          }
          groupBy: {
            args: Prisma.ForumCommentsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ForumCommentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.ForumCommentsCountArgs<ExtArgs>
            result: $Utils.Optional<ForumCommentsCountAggregateOutputType> | number
          }
        }
      }
      Units: {
        payload: Prisma.$UnitsPayload<ExtArgs>
        fields: Prisma.UnitsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UnitsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UnitsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitsPayload>
          }
          findFirst: {
            args: Prisma.UnitsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UnitsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitsPayload>
          }
          findMany: {
            args: Prisma.UnitsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitsPayload>[]
          }
          create: {
            args: Prisma.UnitsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitsPayload>
          }
          createMany: {
            args: Prisma.UnitsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UnitsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitsPayload>[]
          }
          delete: {
            args: Prisma.UnitsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitsPayload>
          }
          update: {
            args: Prisma.UnitsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitsPayload>
          }
          deleteMany: {
            args: Prisma.UnitsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UnitsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UnitsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitsPayload>[]
          }
          upsert: {
            args: Prisma.UnitsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitsPayload>
          }
          aggregate: {
            args: Prisma.UnitsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUnits>
          }
          groupBy: {
            args: Prisma.UnitsGroupByArgs<ExtArgs>
            result: $Utils.Optional<UnitsGroupByOutputType>[]
          }
          count: {
            args: Prisma.UnitsCountArgs<ExtArgs>
            result: $Utils.Optional<UnitsCountAggregateOutputType> | number
          }
        }
      }
      Bills: {
        payload: Prisma.$BillsPayload<ExtArgs>
        fields: Prisma.BillsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BillsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BillsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillsPayload>
          }
          findFirst: {
            args: Prisma.BillsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BillsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillsPayload>
          }
          findMany: {
            args: Prisma.BillsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillsPayload>[]
          }
          create: {
            args: Prisma.BillsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillsPayload>
          }
          createMany: {
            args: Prisma.BillsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BillsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillsPayload>[]
          }
          delete: {
            args: Prisma.BillsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillsPayload>
          }
          update: {
            args: Prisma.BillsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillsPayload>
          }
          deleteMany: {
            args: Prisma.BillsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BillsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BillsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillsPayload>[]
          }
          upsert: {
            args: Prisma.BillsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillsPayload>
          }
          aggregate: {
            args: Prisma.BillsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBills>
          }
          groupBy: {
            args: Prisma.BillsGroupByArgs<ExtArgs>
            result: $Utils.Optional<BillsGroupByOutputType>[]
          }
          count: {
            args: Prisma.BillsCountArgs<ExtArgs>
            result: $Utils.Optional<BillsCountAggregateOutputType> | number
          }
        }
      }
      Payments: {
        payload: Prisma.$PaymentsPayload<ExtArgs>
        fields: Prisma.PaymentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentsPayload>
          }
          findFirst: {
            args: Prisma.PaymentsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentsPayload>
          }
          findMany: {
            args: Prisma.PaymentsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentsPayload>[]
          }
          create: {
            args: Prisma.PaymentsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentsPayload>
          }
          createMany: {
            args: Prisma.PaymentsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentsPayload>[]
          }
          delete: {
            args: Prisma.PaymentsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentsPayload>
          }
          update: {
            args: Prisma.PaymentsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentsPayload>
          }
          deleteMany: {
            args: Prisma.PaymentsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PaymentsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentsPayload>[]
          }
          upsert: {
            args: Prisma.PaymentsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentsPayload>
          }
          aggregate: {
            args: Prisma.PaymentsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayments>
          }
          groupBy: {
            args: Prisma.PaymentsGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentsCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentsCountAggregateOutputType> | number
          }
        }
      }
      Contacts: {
        payload: Prisma.$ContactsPayload<ExtArgs>
        fields: Prisma.ContactsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContactsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContactsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactsPayload>
          }
          findFirst: {
            args: Prisma.ContactsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContactsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactsPayload>
          }
          findMany: {
            args: Prisma.ContactsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactsPayload>[]
          }
          create: {
            args: Prisma.ContactsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactsPayload>
          }
          createMany: {
            args: Prisma.ContactsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContactsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactsPayload>[]
          }
          delete: {
            args: Prisma.ContactsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactsPayload>
          }
          update: {
            args: Prisma.ContactsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactsPayload>
          }
          deleteMany: {
            args: Prisma.ContactsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContactsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ContactsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactsPayload>[]
          }
          upsert: {
            args: Prisma.ContactsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactsPayload>
          }
          aggregate: {
            args: Prisma.ContactsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContacts>
          }
          groupBy: {
            args: Prisma.ContactsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContactsGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContactsCountArgs<ExtArgs>
            result: $Utils.Optional<ContactsCountAggregateOutputType> | number
          }
        }
      }
      SecurityReports: {
        payload: Prisma.$SecurityReportsPayload<ExtArgs>
        fields: Prisma.SecurityReportsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SecurityReportsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityReportsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SecurityReportsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityReportsPayload>
          }
          findFirst: {
            args: Prisma.SecurityReportsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityReportsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SecurityReportsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityReportsPayload>
          }
          findMany: {
            args: Prisma.SecurityReportsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityReportsPayload>[]
          }
          create: {
            args: Prisma.SecurityReportsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityReportsPayload>
          }
          createMany: {
            args: Prisma.SecurityReportsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SecurityReportsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityReportsPayload>[]
          }
          delete: {
            args: Prisma.SecurityReportsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityReportsPayload>
          }
          update: {
            args: Prisma.SecurityReportsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityReportsPayload>
          }
          deleteMany: {
            args: Prisma.SecurityReportsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SecurityReportsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SecurityReportsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityReportsPayload>[]
          }
          upsert: {
            args: Prisma.SecurityReportsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityReportsPayload>
          }
          aggregate: {
            args: Prisma.SecurityReportsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSecurityReports>
          }
          groupBy: {
            args: Prisma.SecurityReportsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SecurityReportsGroupByOutputType>[]
          }
          count: {
            args: Prisma.SecurityReportsCountArgs<ExtArgs>
            result: $Utils.Optional<SecurityReportsCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    users?: UsersOmit
    residents?: ResidentsOmit
    employees?: EmployeesOmit
    complaints?: ComplaintsOmit
    announcements?: AnnouncementsOmit
    forumPosts?: ForumPostsOmit
    postTags?: PostTagsOmit
    forumComments?: ForumCommentsOmit
    units?: UnitsOmit
    bills?: BillsOmit
    payments?: PaymentsOmit
    contacts?: ContactsOmit
    securityReports?: SecurityReportsOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UsersCountOutputType
   */

  export type UsersCountOutputType = {
    ForumPosts: number
    ForumComments: number
  }

  export type UsersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ForumPosts?: boolean | UsersCountOutputTypeCountForumPostsArgs
    ForumComments?: boolean | UsersCountOutputTypeCountForumCommentsArgs
  }

  // Custom InputTypes
  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersCountOutputType
     */
    select?: UsersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountForumPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ForumPostsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountForumCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ForumCommentsWhereInput
  }


  /**
   * Count Type ResidentsCountOutputType
   */

  export type ResidentsCountOutputType = {
    Complaints: number
    Payments: number
  }

  export type ResidentsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Complaints?: boolean | ResidentsCountOutputTypeCountComplaintsArgs
    Payments?: boolean | ResidentsCountOutputTypeCountPaymentsArgs
  }

  // Custom InputTypes
  /**
   * ResidentsCountOutputType without action
   */
  export type ResidentsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResidentsCountOutputType
     */
    select?: ResidentsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ResidentsCountOutputType without action
   */
  export type ResidentsCountOutputTypeCountComplaintsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComplaintsWhereInput
  }

  /**
   * ResidentsCountOutputType without action
   */
  export type ResidentsCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentsWhereInput
  }


  /**
   * Count Type EmployeesCountOutputType
   */

  export type EmployeesCountOutputType = {
    Announcements: number
    Complaints: number
    Bills: number
    Payments: number
    SecurityReports: number
  }

  export type EmployeesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Announcements?: boolean | EmployeesCountOutputTypeCountAnnouncementsArgs
    Complaints?: boolean | EmployeesCountOutputTypeCountComplaintsArgs
    Bills?: boolean | EmployeesCountOutputTypeCountBillsArgs
    Payments?: boolean | EmployeesCountOutputTypeCountPaymentsArgs
    SecurityReports?: boolean | EmployeesCountOutputTypeCountSecurityReportsArgs
  }

  // Custom InputTypes
  /**
   * EmployeesCountOutputType without action
   */
  export type EmployeesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeesCountOutputType
     */
    select?: EmployeesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EmployeesCountOutputType without action
   */
  export type EmployeesCountOutputTypeCountAnnouncementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnnouncementsWhereInput
  }

  /**
   * EmployeesCountOutputType without action
   */
  export type EmployeesCountOutputTypeCountComplaintsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComplaintsWhereInput
  }

  /**
   * EmployeesCountOutputType without action
   */
  export type EmployeesCountOutputTypeCountBillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BillsWhereInput
  }

  /**
   * EmployeesCountOutputType without action
   */
  export type EmployeesCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentsWhereInput
  }

  /**
   * EmployeesCountOutputType without action
   */
  export type EmployeesCountOutputTypeCountSecurityReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SecurityReportsWhereInput
  }


  /**
   * Count Type ForumPostsCountOutputType
   */

  export type ForumPostsCountOutputType = {
    tags: number
    comments: number
  }

  export type ForumPostsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tags?: boolean | ForumPostsCountOutputTypeCountTagsArgs
    comments?: boolean | ForumPostsCountOutputTypeCountCommentsArgs
  }

  // Custom InputTypes
  /**
   * ForumPostsCountOutputType without action
   */
  export type ForumPostsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumPostsCountOutputType
     */
    select?: ForumPostsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ForumPostsCountOutputType without action
   */
  export type ForumPostsCountOutputTypeCountTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostTagsWhereInput
  }

  /**
   * ForumPostsCountOutputType without action
   */
  export type ForumPostsCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ForumCommentsWhereInput
  }


  /**
   * Count Type PostTagsCountOutputType
   */

  export type PostTagsCountOutputType = {
    posts: number
  }

  export type PostTagsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    posts?: boolean | PostTagsCountOutputTypeCountPostsArgs
  }

  // Custom InputTypes
  /**
   * PostTagsCountOutputType without action
   */
  export type PostTagsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostTagsCountOutputType
     */
    select?: PostTagsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PostTagsCountOutputType without action
   */
  export type PostTagsCountOutputTypeCountPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ForumPostsWhereInput
  }


  /**
   * Count Type UnitsCountOutputType
   */

  export type UnitsCountOutputType = {
    Residents: number
    Payments: number
    Bills: number
    Complaints: number
  }

  export type UnitsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Residents?: boolean | UnitsCountOutputTypeCountResidentsArgs
    Payments?: boolean | UnitsCountOutputTypeCountPaymentsArgs
    Bills?: boolean | UnitsCountOutputTypeCountBillsArgs
    Complaints?: boolean | UnitsCountOutputTypeCountComplaintsArgs
  }

  // Custom InputTypes
  /**
   * UnitsCountOutputType without action
   */
  export type UnitsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitsCountOutputType
     */
    select?: UnitsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UnitsCountOutputType without action
   */
  export type UnitsCountOutputTypeCountResidentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResidentsWhereInput
  }

  /**
   * UnitsCountOutputType without action
   */
  export type UnitsCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentsWhereInput
  }

  /**
   * UnitsCountOutputType without action
   */
  export type UnitsCountOutputTypeCountBillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BillsWhereInput
  }

  /**
   * UnitsCountOutputType without action
   */
  export type UnitsCountOutputTypeCountComplaintsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComplaintsWhereInput
  }


  /**
   * Count Type BillsCountOutputType
   */

  export type BillsCountOutputType = {
    Payments: number
  }

  export type BillsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Payments?: boolean | BillsCountOutputTypeCountPaymentsArgs
  }

  // Custom InputTypes
  /**
   * BillsCountOutputType without action
   */
  export type BillsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillsCountOutputType
     */
    select?: BillsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BillsCountOutputType without action
   */
  export type BillsCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentsWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Users
   */

  export type AggregateUsers = {
    _count: UsersCountAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  export type UsersMinAggregateOutputType = {
    id: string | null
    fullName: string | null
    firstName: string | null
    lastName: string | null
    username: string | null
    dateOfBirth: Date | null
    contactNumber: string | null
    primaryEmail: string | null
    secondaryEmail: string | null
    password: string | null
    sessionToken: string | null
    emailVerificationToken: string | null
    passwordResetToken: string | null
    role: $Enums.UserRole | null
    gender: $Enums.Gender | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UsersMaxAggregateOutputType = {
    id: string | null
    fullName: string | null
    firstName: string | null
    lastName: string | null
    username: string | null
    dateOfBirth: Date | null
    contactNumber: string | null
    primaryEmail: string | null
    secondaryEmail: string | null
    password: string | null
    sessionToken: string | null
    emailVerificationToken: string | null
    passwordResetToken: string | null
    role: $Enums.UserRole | null
    gender: $Enums.Gender | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UsersCountAggregateOutputType = {
    id: number
    fullName: number
    firstName: number
    lastName: number
    username: number
    dateOfBirth: number
    contactNumber: number
    primaryEmail: number
    secondaryEmail: number
    password: number
    sessionToken: number
    emailVerificationToken: number
    passwordResetToken: number
    role: number
    gender: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UsersMinAggregateInputType = {
    id?: true
    fullName?: true
    firstName?: true
    lastName?: true
    username?: true
    dateOfBirth?: true
    contactNumber?: true
    primaryEmail?: true
    secondaryEmail?: true
    password?: true
    sessionToken?: true
    emailVerificationToken?: true
    passwordResetToken?: true
    role?: true
    gender?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UsersMaxAggregateInputType = {
    id?: true
    fullName?: true
    firstName?: true
    lastName?: true
    username?: true
    dateOfBirth?: true
    contactNumber?: true
    primaryEmail?: true
    secondaryEmail?: true
    password?: true
    sessionToken?: true
    emailVerificationToken?: true
    passwordResetToken?: true
    role?: true
    gender?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UsersCountAggregateInputType = {
    id?: true
    fullName?: true
    firstName?: true
    lastName?: true
    username?: true
    dateOfBirth?: true
    contactNumber?: true
    primaryEmail?: true
    secondaryEmail?: true
    password?: true
    sessionToken?: true
    emailVerificationToken?: true
    passwordResetToken?: true
    role?: true
    gender?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UsersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to aggregate.
     */
    where?: UsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UsersOrderByWithRelationInput | UsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UsersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsersMaxAggregateInputType
  }

  export type GetUsersAggregateType<T extends UsersAggregateArgs> = {
        [P in keyof T & keyof AggregateUsers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsers[P]>
      : GetScalarType<T[P], AggregateUsers[P]>
  }




  export type UsersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsersWhereInput
    orderBy?: UsersOrderByWithAggregationInput | UsersOrderByWithAggregationInput[]
    by: UsersScalarFieldEnum[] | UsersScalarFieldEnum
    having?: UsersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsersCountAggregateInputType | true
    _min?: UsersMinAggregateInputType
    _max?: UsersMaxAggregateInputType
  }

  export type UsersGroupByOutputType = {
    id: string
    fullName: string
    firstName: string
    lastName: string
    username: string
    dateOfBirth: Date | null
    contactNumber: string | null
    primaryEmail: string
    secondaryEmail: string | null
    password: string
    sessionToken: string | null
    emailVerificationToken: string | null
    passwordResetToken: string | null
    role: $Enums.UserRole
    gender: $Enums.Gender | null
    createdAt: Date
    updatedAt: Date
    _count: UsersCountAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  type GetUsersGroupByPayload<T extends UsersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsersGroupByOutputType[P]>
            : GetScalarType<T[P], UsersGroupByOutputType[P]>
        }
      >
    >


  export type UsersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fullName?: boolean
    firstName?: boolean
    lastName?: boolean
    username?: boolean
    dateOfBirth?: boolean
    contactNumber?: boolean
    primaryEmail?: boolean
    secondaryEmail?: boolean
    password?: boolean
    sessionToken?: boolean
    emailVerificationToken?: boolean
    passwordResetToken?: boolean
    role?: boolean
    gender?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Resident?: boolean | Users$ResidentArgs<ExtArgs>
    Employee?: boolean | Users$EmployeeArgs<ExtArgs>
    ForumPosts?: boolean | Users$ForumPostsArgs<ExtArgs>
    ForumComments?: boolean | Users$ForumCommentsArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["users"]>

  export type UsersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fullName?: boolean
    firstName?: boolean
    lastName?: boolean
    username?: boolean
    dateOfBirth?: boolean
    contactNumber?: boolean
    primaryEmail?: boolean
    secondaryEmail?: boolean
    password?: boolean
    sessionToken?: boolean
    emailVerificationToken?: boolean
    passwordResetToken?: boolean
    role?: boolean
    gender?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["users"]>

  export type UsersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fullName?: boolean
    firstName?: boolean
    lastName?: boolean
    username?: boolean
    dateOfBirth?: boolean
    contactNumber?: boolean
    primaryEmail?: boolean
    secondaryEmail?: boolean
    password?: boolean
    sessionToken?: boolean
    emailVerificationToken?: boolean
    passwordResetToken?: boolean
    role?: boolean
    gender?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["users"]>

  export type UsersSelectScalar = {
    id?: boolean
    fullName?: boolean
    firstName?: boolean
    lastName?: boolean
    username?: boolean
    dateOfBirth?: boolean
    contactNumber?: boolean
    primaryEmail?: boolean
    secondaryEmail?: boolean
    password?: boolean
    sessionToken?: boolean
    emailVerificationToken?: boolean
    passwordResetToken?: boolean
    role?: boolean
    gender?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UsersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "fullName" | "firstName" | "lastName" | "username" | "dateOfBirth" | "contactNumber" | "primaryEmail" | "secondaryEmail" | "password" | "sessionToken" | "emailVerificationToken" | "passwordResetToken" | "role" | "gender" | "createdAt" | "updatedAt", ExtArgs["result"]["users"]>
  export type UsersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Resident?: boolean | Users$ResidentArgs<ExtArgs>
    Employee?: boolean | Users$EmployeeArgs<ExtArgs>
    ForumPosts?: boolean | Users$ForumPostsArgs<ExtArgs>
    ForumComments?: boolean | Users$ForumCommentsArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UsersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UsersIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UsersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Users"
    objects: {
      Resident: Prisma.$ResidentsPayload<ExtArgs> | null
      Employee: Prisma.$EmployeesPayload<ExtArgs> | null
      ForumPosts: Prisma.$ForumPostsPayload<ExtArgs>[]
      ForumComments: Prisma.$ForumCommentsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      fullName: string
      firstName: string
      lastName: string
      username: string
      dateOfBirth: Date | null
      contactNumber: string | null
      primaryEmail: string
      secondaryEmail: string | null
      password: string
      sessionToken: string | null
      emailVerificationToken: string | null
      passwordResetToken: string | null
      role: $Enums.UserRole
      gender: $Enums.Gender | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["users"]>
    composites: {}
  }

  type UsersGetPayload<S extends boolean | null | undefined | UsersDefaultArgs> = $Result.GetResult<Prisma.$UsersPayload, S>

  type UsersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UsersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UsersCountAggregateInputType | true
    }

  export interface UsersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Users'], meta: { name: 'Users' } }
    /**
     * Find zero or one Users that matches the filter.
     * @param {UsersFindUniqueArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UsersFindUniqueArgs>(args: SelectSubset<T, UsersFindUniqueArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Users that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UsersFindUniqueOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UsersFindUniqueOrThrowArgs>(args: SelectSubset<T, UsersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersFindFirstArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UsersFindFirstArgs>(args?: SelectSubset<T, UsersFindFirstArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersFindFirstOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UsersFindFirstOrThrowArgs>(args?: SelectSubset<T, UsersFindFirstOrThrowArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.users.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.users.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usersWithIdOnly = await prisma.users.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UsersFindManyArgs>(args?: SelectSubset<T, UsersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Users.
     * @param {UsersCreateArgs} args - Arguments to create a Users.
     * @example
     * // Create one Users
     * const Users = await prisma.users.create({
     *   data: {
     *     // ... data to create a Users
     *   }
     * })
     * 
     */
    create<T extends UsersCreateArgs>(args: SelectSubset<T, UsersCreateArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UsersCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UsersCreateManyArgs>(args?: SelectSubset<T, UsersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UsersCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const usersWithIdOnly = await prisma.users.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UsersCreateManyAndReturnArgs>(args?: SelectSubset<T, UsersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Users.
     * @param {UsersDeleteArgs} args - Arguments to delete one Users.
     * @example
     * // Delete one Users
     * const Users = await prisma.users.delete({
     *   where: {
     *     // ... filter to delete one Users
     *   }
     * })
     * 
     */
    delete<T extends UsersDeleteArgs>(args: SelectSubset<T, UsersDeleteArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Users.
     * @param {UsersUpdateArgs} args - Arguments to update one Users.
     * @example
     * // Update one Users
     * const users = await prisma.users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UsersUpdateArgs>(args: SelectSubset<T, UsersUpdateArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UsersDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UsersDeleteManyArgs>(args?: SelectSubset<T, UsersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UsersUpdateManyArgs>(args: SelectSubset<T, UsersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UsersUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const usersWithIdOnly = await prisma.users.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UsersUpdateManyAndReturnArgs>(args: SelectSubset<T, UsersUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Users.
     * @param {UsersUpsertArgs} args - Arguments to update or create a Users.
     * @example
     * // Update or create a Users
     * const users = await prisma.users.upsert({
     *   create: {
     *     // ... data to create a Users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Users we want to update
     *   }
     * })
     */
    upsert<T extends UsersUpsertArgs>(args: SelectSubset<T, UsersUpsertArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.users.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UsersCountArgs>(
      args?: Subset<T, UsersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsersAggregateArgs>(args: Subset<T, UsersAggregateArgs>): Prisma.PrismaPromise<GetUsersAggregateType<T>>

    /**
     * Group by Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsersGroupByArgs['orderBy'] }
        : { orderBy?: UsersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Users model
   */
  readonly fields: UsersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UsersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Resident<T extends Users$ResidentArgs<ExtArgs> = {}>(args?: Subset<T, Users$ResidentArgs<ExtArgs>>): Prisma__ResidentsClient<$Result.GetResult<Prisma.$ResidentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    Employee<T extends Users$EmployeeArgs<ExtArgs> = {}>(args?: Subset<T, Users$EmployeeArgs<ExtArgs>>): Prisma__EmployeesClient<$Result.GetResult<Prisma.$EmployeesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    ForumPosts<T extends Users$ForumPostsArgs<ExtArgs> = {}>(args?: Subset<T, Users$ForumPostsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ForumPostsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ForumComments<T extends Users$ForumCommentsArgs<ExtArgs> = {}>(args?: Subset<T, Users$ForumCommentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ForumCommentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Users model
   */
  interface UsersFieldRefs {
    readonly id: FieldRef<"Users", 'String'>
    readonly fullName: FieldRef<"Users", 'String'>
    readonly firstName: FieldRef<"Users", 'String'>
    readonly lastName: FieldRef<"Users", 'String'>
    readonly username: FieldRef<"Users", 'String'>
    readonly dateOfBirth: FieldRef<"Users", 'DateTime'>
    readonly contactNumber: FieldRef<"Users", 'String'>
    readonly primaryEmail: FieldRef<"Users", 'String'>
    readonly secondaryEmail: FieldRef<"Users", 'String'>
    readonly password: FieldRef<"Users", 'String'>
    readonly sessionToken: FieldRef<"Users", 'String'>
    readonly emailVerificationToken: FieldRef<"Users", 'String'>
    readonly passwordResetToken: FieldRef<"Users", 'String'>
    readonly role: FieldRef<"Users", 'UserRole'>
    readonly gender: FieldRef<"Users", 'Gender'>
    readonly createdAt: FieldRef<"Users", 'DateTime'>
    readonly updatedAt: FieldRef<"Users", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Users findUnique
   */
  export type UsersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where: UsersWhereUniqueInput
  }

  /**
   * Users findUniqueOrThrow
   */
  export type UsersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where: UsersWhereUniqueInput
  }

  /**
   * Users findFirst
   */
  export type UsersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UsersOrderByWithRelationInput | UsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * Users findFirstOrThrow
   */
  export type UsersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UsersOrderByWithRelationInput | UsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * Users findMany
   */
  export type UsersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UsersOrderByWithRelationInput | UsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * Users create
   */
  export type UsersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * The data needed to create a Users.
     */
    data: XOR<UsersCreateInput, UsersUncheckedCreateInput>
  }

  /**
   * Users createMany
   */
  export type UsersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UsersCreateManyInput | UsersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Users createManyAndReturn
   */
  export type UsersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UsersCreateManyInput | UsersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Users update
   */
  export type UsersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * The data needed to update a Users.
     */
    data: XOR<UsersUpdateInput, UsersUncheckedUpdateInput>
    /**
     * Choose, which Users to update.
     */
    where: UsersWhereUniqueInput
  }

  /**
   * Users updateMany
   */
  export type UsersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UsersUpdateManyMutationInput, UsersUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UsersWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * Users updateManyAndReturn
   */
  export type UsersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UsersUpdateManyMutationInput, UsersUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UsersWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * Users upsert
   */
  export type UsersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * The filter to search for the Users to update in case it exists.
     */
    where: UsersWhereUniqueInput
    /**
     * In case the Users found by the `where` argument doesn't exist, create a new Users with this data.
     */
    create: XOR<UsersCreateInput, UsersUncheckedCreateInput>
    /**
     * In case the Users was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UsersUpdateInput, UsersUncheckedUpdateInput>
  }

  /**
   * Users delete
   */
  export type UsersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter which Users to delete.
     */
    where: UsersWhereUniqueInput
  }

  /**
   * Users deleteMany
   */
  export type UsersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UsersWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * Users.Resident
   */
  export type Users$ResidentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Residents
     */
    select?: ResidentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Residents
     */
    omit?: ResidentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResidentsInclude<ExtArgs> | null
    where?: ResidentsWhereInput
  }

  /**
   * Users.Employee
   */
  export type Users$EmployeeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employees
     */
    select?: EmployeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employees
     */
    omit?: EmployeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeesInclude<ExtArgs> | null
    where?: EmployeesWhereInput
  }

  /**
   * Users.ForumPosts
   */
  export type Users$ForumPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumPosts
     */
    select?: ForumPostsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ForumPosts
     */
    omit?: ForumPostsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumPostsInclude<ExtArgs> | null
    where?: ForumPostsWhereInput
    orderBy?: ForumPostsOrderByWithRelationInput | ForumPostsOrderByWithRelationInput[]
    cursor?: ForumPostsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ForumPostsScalarFieldEnum | ForumPostsScalarFieldEnum[]
  }

  /**
   * Users.ForumComments
   */
  export type Users$ForumCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumComments
     */
    select?: ForumCommentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ForumComments
     */
    omit?: ForumCommentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumCommentsInclude<ExtArgs> | null
    where?: ForumCommentsWhereInput
    orderBy?: ForumCommentsOrderByWithRelationInput | ForumCommentsOrderByWithRelationInput[]
    cursor?: ForumCommentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ForumCommentsScalarFieldEnum | ForumCommentsScalarFieldEnum[]
  }

  /**
   * Users without action
   */
  export type UsersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
  }


  /**
   * Model Residents
   */

  export type AggregateResidents = {
    _count: ResidentsCountAggregateOutputType | null
    _avg: ResidentsAvgAggregateOutputType | null
    _sum: ResidentsSumAggregateOutputType | null
    _min: ResidentsMinAggregateOutputType | null
    _max: ResidentsMaxAggregateOutputType | null
  }

  export type ResidentsAvgAggregateOutputType = {
    kprPaymentAmount: number | null
  }

  export type ResidentsSumAggregateOutputType = {
    kprPaymentAmount: number | null
  }

  export type ResidentsMinAggregateOutputType = {
    id: string | null
    userId: string | null
    emergencyContactName: string | null
    emergencyContactNumber: string | null
    movedInDate: Date | null
    movedOutDate: Date | null
    residentStatus: $Enums.ResidentStatus | null
    unitId: string | null
    kprPaymentAmount: number | null
    kprDueDate: Date | null
    isKprPaid: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ResidentsMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    emergencyContactName: string | null
    emergencyContactNumber: string | null
    movedInDate: Date | null
    movedOutDate: Date | null
    residentStatus: $Enums.ResidentStatus | null
    unitId: string | null
    kprPaymentAmount: number | null
    kprDueDate: Date | null
    isKprPaid: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ResidentsCountAggregateOutputType = {
    id: number
    userId: number
    emergencyContactName: number
    emergencyContactNumber: number
    movedInDate: number
    movedOutDate: number
    residentStatus: number
    unitId: number
    kprPaymentAmount: number
    kprDueDate: number
    isKprPaid: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ResidentsAvgAggregateInputType = {
    kprPaymentAmount?: true
  }

  export type ResidentsSumAggregateInputType = {
    kprPaymentAmount?: true
  }

  export type ResidentsMinAggregateInputType = {
    id?: true
    userId?: true
    emergencyContactName?: true
    emergencyContactNumber?: true
    movedInDate?: true
    movedOutDate?: true
    residentStatus?: true
    unitId?: true
    kprPaymentAmount?: true
    kprDueDate?: true
    isKprPaid?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ResidentsMaxAggregateInputType = {
    id?: true
    userId?: true
    emergencyContactName?: true
    emergencyContactNumber?: true
    movedInDate?: true
    movedOutDate?: true
    residentStatus?: true
    unitId?: true
    kprPaymentAmount?: true
    kprDueDate?: true
    isKprPaid?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ResidentsCountAggregateInputType = {
    id?: true
    userId?: true
    emergencyContactName?: true
    emergencyContactNumber?: true
    movedInDate?: true
    movedOutDate?: true
    residentStatus?: true
    unitId?: true
    kprPaymentAmount?: true
    kprDueDate?: true
    isKprPaid?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ResidentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Residents to aggregate.
     */
    where?: ResidentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Residents to fetch.
     */
    orderBy?: ResidentsOrderByWithRelationInput | ResidentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ResidentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Residents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Residents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Residents
    **/
    _count?: true | ResidentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ResidentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ResidentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ResidentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ResidentsMaxAggregateInputType
  }

  export type GetResidentsAggregateType<T extends ResidentsAggregateArgs> = {
        [P in keyof T & keyof AggregateResidents]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateResidents[P]>
      : GetScalarType<T[P], AggregateResidents[P]>
  }




  export type ResidentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResidentsWhereInput
    orderBy?: ResidentsOrderByWithAggregationInput | ResidentsOrderByWithAggregationInput[]
    by: ResidentsScalarFieldEnum[] | ResidentsScalarFieldEnum
    having?: ResidentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ResidentsCountAggregateInputType | true
    _avg?: ResidentsAvgAggregateInputType
    _sum?: ResidentsSumAggregateInputType
    _min?: ResidentsMinAggregateInputType
    _max?: ResidentsMaxAggregateInputType
  }

  export type ResidentsGroupByOutputType = {
    id: string
    userId: string
    emergencyContactName: string | null
    emergencyContactNumber: string | null
    movedInDate: Date
    movedOutDate: Date | null
    residentStatus: $Enums.ResidentStatus | null
    unitId: string | null
    kprPaymentAmount: number | null
    kprDueDate: Date | null
    isKprPaid: boolean | null
    createdAt: Date
    updatedAt: Date
    _count: ResidentsCountAggregateOutputType | null
    _avg: ResidentsAvgAggregateOutputType | null
    _sum: ResidentsSumAggregateOutputType | null
    _min: ResidentsMinAggregateOutputType | null
    _max: ResidentsMaxAggregateOutputType | null
  }

  type GetResidentsGroupByPayload<T extends ResidentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ResidentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ResidentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ResidentsGroupByOutputType[P]>
            : GetScalarType<T[P], ResidentsGroupByOutputType[P]>
        }
      >
    >


  export type ResidentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    emergencyContactName?: boolean
    emergencyContactNumber?: boolean
    movedInDate?: boolean
    movedOutDate?: boolean
    residentStatus?: boolean
    unitId?: boolean
    kprPaymentAmount?: boolean
    kprDueDate?: boolean
    isKprPaid?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UsersDefaultArgs<ExtArgs>
    unit?: boolean | Residents$unitArgs<ExtArgs>
    Complaints?: boolean | Residents$ComplaintsArgs<ExtArgs>
    Payments?: boolean | Residents$PaymentsArgs<ExtArgs>
    _count?: boolean | ResidentsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["residents"]>

  export type ResidentsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    emergencyContactName?: boolean
    emergencyContactNumber?: boolean
    movedInDate?: boolean
    movedOutDate?: boolean
    residentStatus?: boolean
    unitId?: boolean
    kprPaymentAmount?: boolean
    kprDueDate?: boolean
    isKprPaid?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UsersDefaultArgs<ExtArgs>
    unit?: boolean | Residents$unitArgs<ExtArgs>
  }, ExtArgs["result"]["residents"]>

  export type ResidentsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    emergencyContactName?: boolean
    emergencyContactNumber?: boolean
    movedInDate?: boolean
    movedOutDate?: boolean
    residentStatus?: boolean
    unitId?: boolean
    kprPaymentAmount?: boolean
    kprDueDate?: boolean
    isKprPaid?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UsersDefaultArgs<ExtArgs>
    unit?: boolean | Residents$unitArgs<ExtArgs>
  }, ExtArgs["result"]["residents"]>

  export type ResidentsSelectScalar = {
    id?: boolean
    userId?: boolean
    emergencyContactName?: boolean
    emergencyContactNumber?: boolean
    movedInDate?: boolean
    movedOutDate?: boolean
    residentStatus?: boolean
    unitId?: boolean
    kprPaymentAmount?: boolean
    kprDueDate?: boolean
    isKprPaid?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ResidentsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "emergencyContactName" | "emergencyContactNumber" | "movedInDate" | "movedOutDate" | "residentStatus" | "unitId" | "kprPaymentAmount" | "kprDueDate" | "isKprPaid" | "createdAt" | "updatedAt", ExtArgs["result"]["residents"]>
  export type ResidentsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UsersDefaultArgs<ExtArgs>
    unit?: boolean | Residents$unitArgs<ExtArgs>
    Complaints?: boolean | Residents$ComplaintsArgs<ExtArgs>
    Payments?: boolean | Residents$PaymentsArgs<ExtArgs>
    _count?: boolean | ResidentsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ResidentsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UsersDefaultArgs<ExtArgs>
    unit?: boolean | Residents$unitArgs<ExtArgs>
  }
  export type ResidentsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UsersDefaultArgs<ExtArgs>
    unit?: boolean | Residents$unitArgs<ExtArgs>
  }

  export type $ResidentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Residents"
    objects: {
      user: Prisma.$UsersPayload<ExtArgs>
      unit: Prisma.$UnitsPayload<ExtArgs> | null
      Complaints: Prisma.$ComplaintsPayload<ExtArgs>[]
      Payments: Prisma.$PaymentsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      emergencyContactName: string | null
      emergencyContactNumber: string | null
      movedInDate: Date
      movedOutDate: Date | null
      residentStatus: $Enums.ResidentStatus | null
      unitId: string | null
      kprPaymentAmount: number | null
      kprDueDate: Date | null
      isKprPaid: boolean | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["residents"]>
    composites: {}
  }

  type ResidentsGetPayload<S extends boolean | null | undefined | ResidentsDefaultArgs> = $Result.GetResult<Prisma.$ResidentsPayload, S>

  type ResidentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ResidentsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ResidentsCountAggregateInputType | true
    }

  export interface ResidentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Residents'], meta: { name: 'Residents' } }
    /**
     * Find zero or one Residents that matches the filter.
     * @param {ResidentsFindUniqueArgs} args - Arguments to find a Residents
     * @example
     * // Get one Residents
     * const residents = await prisma.residents.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ResidentsFindUniqueArgs>(args: SelectSubset<T, ResidentsFindUniqueArgs<ExtArgs>>): Prisma__ResidentsClient<$Result.GetResult<Prisma.$ResidentsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Residents that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ResidentsFindUniqueOrThrowArgs} args - Arguments to find a Residents
     * @example
     * // Get one Residents
     * const residents = await prisma.residents.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ResidentsFindUniqueOrThrowArgs>(args: SelectSubset<T, ResidentsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ResidentsClient<$Result.GetResult<Prisma.$ResidentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Residents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResidentsFindFirstArgs} args - Arguments to find a Residents
     * @example
     * // Get one Residents
     * const residents = await prisma.residents.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ResidentsFindFirstArgs>(args?: SelectSubset<T, ResidentsFindFirstArgs<ExtArgs>>): Prisma__ResidentsClient<$Result.GetResult<Prisma.$ResidentsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Residents that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResidentsFindFirstOrThrowArgs} args - Arguments to find a Residents
     * @example
     * // Get one Residents
     * const residents = await prisma.residents.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ResidentsFindFirstOrThrowArgs>(args?: SelectSubset<T, ResidentsFindFirstOrThrowArgs<ExtArgs>>): Prisma__ResidentsClient<$Result.GetResult<Prisma.$ResidentsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Residents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResidentsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Residents
     * const residents = await prisma.residents.findMany()
     * 
     * // Get first 10 Residents
     * const residents = await prisma.residents.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const residentsWithIdOnly = await prisma.residents.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ResidentsFindManyArgs>(args?: SelectSubset<T, ResidentsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResidentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Residents.
     * @param {ResidentsCreateArgs} args - Arguments to create a Residents.
     * @example
     * // Create one Residents
     * const Residents = await prisma.residents.create({
     *   data: {
     *     // ... data to create a Residents
     *   }
     * })
     * 
     */
    create<T extends ResidentsCreateArgs>(args: SelectSubset<T, ResidentsCreateArgs<ExtArgs>>): Prisma__ResidentsClient<$Result.GetResult<Prisma.$ResidentsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Residents.
     * @param {ResidentsCreateManyArgs} args - Arguments to create many Residents.
     * @example
     * // Create many Residents
     * const residents = await prisma.residents.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ResidentsCreateManyArgs>(args?: SelectSubset<T, ResidentsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Residents and returns the data saved in the database.
     * @param {ResidentsCreateManyAndReturnArgs} args - Arguments to create many Residents.
     * @example
     * // Create many Residents
     * const residents = await prisma.residents.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Residents and only return the `id`
     * const residentsWithIdOnly = await prisma.residents.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ResidentsCreateManyAndReturnArgs>(args?: SelectSubset<T, ResidentsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResidentsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Residents.
     * @param {ResidentsDeleteArgs} args - Arguments to delete one Residents.
     * @example
     * // Delete one Residents
     * const Residents = await prisma.residents.delete({
     *   where: {
     *     // ... filter to delete one Residents
     *   }
     * })
     * 
     */
    delete<T extends ResidentsDeleteArgs>(args: SelectSubset<T, ResidentsDeleteArgs<ExtArgs>>): Prisma__ResidentsClient<$Result.GetResult<Prisma.$ResidentsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Residents.
     * @param {ResidentsUpdateArgs} args - Arguments to update one Residents.
     * @example
     * // Update one Residents
     * const residents = await prisma.residents.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ResidentsUpdateArgs>(args: SelectSubset<T, ResidentsUpdateArgs<ExtArgs>>): Prisma__ResidentsClient<$Result.GetResult<Prisma.$ResidentsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Residents.
     * @param {ResidentsDeleteManyArgs} args - Arguments to filter Residents to delete.
     * @example
     * // Delete a few Residents
     * const { count } = await prisma.residents.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ResidentsDeleteManyArgs>(args?: SelectSubset<T, ResidentsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Residents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResidentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Residents
     * const residents = await prisma.residents.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ResidentsUpdateManyArgs>(args: SelectSubset<T, ResidentsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Residents and returns the data updated in the database.
     * @param {ResidentsUpdateManyAndReturnArgs} args - Arguments to update many Residents.
     * @example
     * // Update many Residents
     * const residents = await prisma.residents.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Residents and only return the `id`
     * const residentsWithIdOnly = await prisma.residents.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ResidentsUpdateManyAndReturnArgs>(args: SelectSubset<T, ResidentsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResidentsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Residents.
     * @param {ResidentsUpsertArgs} args - Arguments to update or create a Residents.
     * @example
     * // Update or create a Residents
     * const residents = await prisma.residents.upsert({
     *   create: {
     *     // ... data to create a Residents
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Residents we want to update
     *   }
     * })
     */
    upsert<T extends ResidentsUpsertArgs>(args: SelectSubset<T, ResidentsUpsertArgs<ExtArgs>>): Prisma__ResidentsClient<$Result.GetResult<Prisma.$ResidentsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Residents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResidentsCountArgs} args - Arguments to filter Residents to count.
     * @example
     * // Count the number of Residents
     * const count = await prisma.residents.count({
     *   where: {
     *     // ... the filter for the Residents we want to count
     *   }
     * })
    **/
    count<T extends ResidentsCountArgs>(
      args?: Subset<T, ResidentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ResidentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Residents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResidentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ResidentsAggregateArgs>(args: Subset<T, ResidentsAggregateArgs>): Prisma.PrismaPromise<GetResidentsAggregateType<T>>

    /**
     * Group by Residents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResidentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ResidentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ResidentsGroupByArgs['orderBy'] }
        : { orderBy?: ResidentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ResidentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetResidentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Residents model
   */
  readonly fields: ResidentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Residents.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ResidentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    unit<T extends Residents$unitArgs<ExtArgs> = {}>(args?: Subset<T, Residents$unitArgs<ExtArgs>>): Prisma__UnitsClient<$Result.GetResult<Prisma.$UnitsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    Complaints<T extends Residents$ComplaintsArgs<ExtArgs> = {}>(args?: Subset<T, Residents$ComplaintsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComplaintsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Payments<T extends Residents$PaymentsArgs<ExtArgs> = {}>(args?: Subset<T, Residents$PaymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Residents model
   */
  interface ResidentsFieldRefs {
    readonly id: FieldRef<"Residents", 'String'>
    readonly userId: FieldRef<"Residents", 'String'>
    readonly emergencyContactName: FieldRef<"Residents", 'String'>
    readonly emergencyContactNumber: FieldRef<"Residents", 'String'>
    readonly movedInDate: FieldRef<"Residents", 'DateTime'>
    readonly movedOutDate: FieldRef<"Residents", 'DateTime'>
    readonly residentStatus: FieldRef<"Residents", 'ResidentStatus'>
    readonly unitId: FieldRef<"Residents", 'String'>
    readonly kprPaymentAmount: FieldRef<"Residents", 'Float'>
    readonly kprDueDate: FieldRef<"Residents", 'DateTime'>
    readonly isKprPaid: FieldRef<"Residents", 'Boolean'>
    readonly createdAt: FieldRef<"Residents", 'DateTime'>
    readonly updatedAt: FieldRef<"Residents", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Residents findUnique
   */
  export type ResidentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Residents
     */
    select?: ResidentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Residents
     */
    omit?: ResidentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResidentsInclude<ExtArgs> | null
    /**
     * Filter, which Residents to fetch.
     */
    where: ResidentsWhereUniqueInput
  }

  /**
   * Residents findUniqueOrThrow
   */
  export type ResidentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Residents
     */
    select?: ResidentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Residents
     */
    omit?: ResidentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResidentsInclude<ExtArgs> | null
    /**
     * Filter, which Residents to fetch.
     */
    where: ResidentsWhereUniqueInput
  }

  /**
   * Residents findFirst
   */
  export type ResidentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Residents
     */
    select?: ResidentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Residents
     */
    omit?: ResidentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResidentsInclude<ExtArgs> | null
    /**
     * Filter, which Residents to fetch.
     */
    where?: ResidentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Residents to fetch.
     */
    orderBy?: ResidentsOrderByWithRelationInput | ResidentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Residents.
     */
    cursor?: ResidentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Residents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Residents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Residents.
     */
    distinct?: ResidentsScalarFieldEnum | ResidentsScalarFieldEnum[]
  }

  /**
   * Residents findFirstOrThrow
   */
  export type ResidentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Residents
     */
    select?: ResidentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Residents
     */
    omit?: ResidentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResidentsInclude<ExtArgs> | null
    /**
     * Filter, which Residents to fetch.
     */
    where?: ResidentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Residents to fetch.
     */
    orderBy?: ResidentsOrderByWithRelationInput | ResidentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Residents.
     */
    cursor?: ResidentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Residents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Residents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Residents.
     */
    distinct?: ResidentsScalarFieldEnum | ResidentsScalarFieldEnum[]
  }

  /**
   * Residents findMany
   */
  export type ResidentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Residents
     */
    select?: ResidentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Residents
     */
    omit?: ResidentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResidentsInclude<ExtArgs> | null
    /**
     * Filter, which Residents to fetch.
     */
    where?: ResidentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Residents to fetch.
     */
    orderBy?: ResidentsOrderByWithRelationInput | ResidentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Residents.
     */
    cursor?: ResidentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Residents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Residents.
     */
    skip?: number
    distinct?: ResidentsScalarFieldEnum | ResidentsScalarFieldEnum[]
  }

  /**
   * Residents create
   */
  export type ResidentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Residents
     */
    select?: ResidentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Residents
     */
    omit?: ResidentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResidentsInclude<ExtArgs> | null
    /**
     * The data needed to create a Residents.
     */
    data: XOR<ResidentsCreateInput, ResidentsUncheckedCreateInput>
  }

  /**
   * Residents createMany
   */
  export type ResidentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Residents.
     */
    data: ResidentsCreateManyInput | ResidentsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Residents createManyAndReturn
   */
  export type ResidentsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Residents
     */
    select?: ResidentsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Residents
     */
    omit?: ResidentsOmit<ExtArgs> | null
    /**
     * The data used to create many Residents.
     */
    data: ResidentsCreateManyInput | ResidentsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResidentsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Residents update
   */
  export type ResidentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Residents
     */
    select?: ResidentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Residents
     */
    omit?: ResidentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResidentsInclude<ExtArgs> | null
    /**
     * The data needed to update a Residents.
     */
    data: XOR<ResidentsUpdateInput, ResidentsUncheckedUpdateInput>
    /**
     * Choose, which Residents to update.
     */
    where: ResidentsWhereUniqueInput
  }

  /**
   * Residents updateMany
   */
  export type ResidentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Residents.
     */
    data: XOR<ResidentsUpdateManyMutationInput, ResidentsUncheckedUpdateManyInput>
    /**
     * Filter which Residents to update
     */
    where?: ResidentsWhereInput
    /**
     * Limit how many Residents to update.
     */
    limit?: number
  }

  /**
   * Residents updateManyAndReturn
   */
  export type ResidentsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Residents
     */
    select?: ResidentsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Residents
     */
    omit?: ResidentsOmit<ExtArgs> | null
    /**
     * The data used to update Residents.
     */
    data: XOR<ResidentsUpdateManyMutationInput, ResidentsUncheckedUpdateManyInput>
    /**
     * Filter which Residents to update
     */
    where?: ResidentsWhereInput
    /**
     * Limit how many Residents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResidentsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Residents upsert
   */
  export type ResidentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Residents
     */
    select?: ResidentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Residents
     */
    omit?: ResidentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResidentsInclude<ExtArgs> | null
    /**
     * The filter to search for the Residents to update in case it exists.
     */
    where: ResidentsWhereUniqueInput
    /**
     * In case the Residents found by the `where` argument doesn't exist, create a new Residents with this data.
     */
    create: XOR<ResidentsCreateInput, ResidentsUncheckedCreateInput>
    /**
     * In case the Residents was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ResidentsUpdateInput, ResidentsUncheckedUpdateInput>
  }

  /**
   * Residents delete
   */
  export type ResidentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Residents
     */
    select?: ResidentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Residents
     */
    omit?: ResidentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResidentsInclude<ExtArgs> | null
    /**
     * Filter which Residents to delete.
     */
    where: ResidentsWhereUniqueInput
  }

  /**
   * Residents deleteMany
   */
  export type ResidentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Residents to delete
     */
    where?: ResidentsWhereInput
    /**
     * Limit how many Residents to delete.
     */
    limit?: number
  }

  /**
   * Residents.unit
   */
  export type Residents$unitArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Units
     */
    select?: UnitsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Units
     */
    omit?: UnitsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitsInclude<ExtArgs> | null
    where?: UnitsWhereInput
  }

  /**
   * Residents.Complaints
   */
  export type Residents$ComplaintsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Complaints
     */
    select?: ComplaintsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Complaints
     */
    omit?: ComplaintsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintsInclude<ExtArgs> | null
    where?: ComplaintsWhereInput
    orderBy?: ComplaintsOrderByWithRelationInput | ComplaintsOrderByWithRelationInput[]
    cursor?: ComplaintsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ComplaintsScalarFieldEnum | ComplaintsScalarFieldEnum[]
  }

  /**
   * Residents.Payments
   */
  export type Residents$PaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payments
     */
    select?: PaymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payments
     */
    omit?: PaymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentsInclude<ExtArgs> | null
    where?: PaymentsWhereInput
    orderBy?: PaymentsOrderByWithRelationInput | PaymentsOrderByWithRelationInput[]
    cursor?: PaymentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentsScalarFieldEnum | PaymentsScalarFieldEnum[]
  }

  /**
   * Residents without action
   */
  export type ResidentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Residents
     */
    select?: ResidentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Residents
     */
    omit?: ResidentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResidentsInclude<ExtArgs> | null
  }


  /**
   * Model Employees
   */

  export type AggregateEmployees = {
    _count: EmployeesCountAggregateOutputType | null
    _avg: EmployeesAvgAggregateOutputType | null
    _sum: EmployeesSumAggregateOutputType | null
    _min: EmployeesMinAggregateOutputType | null
    _max: EmployeesMaxAggregateOutputType | null
  }

  export type EmployeesAvgAggregateOutputType = {
    workingHours: number | null
    salary: number | null
    bonus: number | null
  }

  export type EmployeesSumAggregateOutputType = {
    workingHours: number | null
    salary: number | null
    bonus: number | null
  }

  export type EmployeesMinAggregateOutputType = {
    id: string | null
    userId: string | null
    employeeNumberId: string | null
    hireDate: Date | null
    employeePosition: $Enums.EmployeeRole | null
    workingHours: number | null
    salary: number | null
    bonus: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmployeesMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    employeeNumberId: string | null
    hireDate: Date | null
    employeePosition: $Enums.EmployeeRole | null
    workingHours: number | null
    salary: number | null
    bonus: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmployeesCountAggregateOutputType = {
    id: number
    userId: number
    employeeNumberId: number
    hireDate: number
    employeePosition: number
    workingHours: number
    salary: number
    bonus: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EmployeesAvgAggregateInputType = {
    workingHours?: true
    salary?: true
    bonus?: true
  }

  export type EmployeesSumAggregateInputType = {
    workingHours?: true
    salary?: true
    bonus?: true
  }

  export type EmployeesMinAggregateInputType = {
    id?: true
    userId?: true
    employeeNumberId?: true
    hireDate?: true
    employeePosition?: true
    workingHours?: true
    salary?: true
    bonus?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmployeesMaxAggregateInputType = {
    id?: true
    userId?: true
    employeeNumberId?: true
    hireDate?: true
    employeePosition?: true
    workingHours?: true
    salary?: true
    bonus?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmployeesCountAggregateInputType = {
    id?: true
    userId?: true
    employeeNumberId?: true
    hireDate?: true
    employeePosition?: true
    workingHours?: true
    salary?: true
    bonus?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EmployeesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Employees to aggregate.
     */
    where?: EmployeesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeesOrderByWithRelationInput | EmployeesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmployeesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Employees
    **/
    _count?: true | EmployeesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmployeesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmployeesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmployeesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmployeesMaxAggregateInputType
  }

  export type GetEmployeesAggregateType<T extends EmployeesAggregateArgs> = {
        [P in keyof T & keyof AggregateEmployees]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmployees[P]>
      : GetScalarType<T[P], AggregateEmployees[P]>
  }




  export type EmployeesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeesWhereInput
    orderBy?: EmployeesOrderByWithAggregationInput | EmployeesOrderByWithAggregationInput[]
    by: EmployeesScalarFieldEnum[] | EmployeesScalarFieldEnum
    having?: EmployeesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmployeesCountAggregateInputType | true
    _avg?: EmployeesAvgAggregateInputType
    _sum?: EmployeesSumAggregateInputType
    _min?: EmployeesMinAggregateInputType
    _max?: EmployeesMaxAggregateInputType
  }

  export type EmployeesGroupByOutputType = {
    id: string
    userId: string
    employeeNumberId: string
    hireDate: Date
    employeePosition: $Enums.EmployeeRole
    workingHours: number
    salary: number
    bonus: number | null
    createdAt: Date
    updatedAt: Date
    _count: EmployeesCountAggregateOutputType | null
    _avg: EmployeesAvgAggregateOutputType | null
    _sum: EmployeesSumAggregateOutputType | null
    _min: EmployeesMinAggregateOutputType | null
    _max: EmployeesMaxAggregateOutputType | null
  }

  type GetEmployeesGroupByPayload<T extends EmployeesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmployeesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmployeesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmployeesGroupByOutputType[P]>
            : GetScalarType<T[P], EmployeesGroupByOutputType[P]>
        }
      >
    >


  export type EmployeesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    employeeNumberId?: boolean
    hireDate?: boolean
    employeePosition?: boolean
    workingHours?: boolean
    salary?: boolean
    bonus?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UsersDefaultArgs<ExtArgs>
    Announcements?: boolean | Employees$AnnouncementsArgs<ExtArgs>
    Complaints?: boolean | Employees$ComplaintsArgs<ExtArgs>
    Bills?: boolean | Employees$BillsArgs<ExtArgs>
    Payments?: boolean | Employees$PaymentsArgs<ExtArgs>
    SecurityReports?: boolean | Employees$SecurityReportsArgs<ExtArgs>
    _count?: boolean | EmployeesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employees"]>

  export type EmployeesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    employeeNumberId?: boolean
    hireDate?: boolean
    employeePosition?: boolean
    workingHours?: boolean
    salary?: boolean
    bonus?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employees"]>

  export type EmployeesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    employeeNumberId?: boolean
    hireDate?: boolean
    employeePosition?: boolean
    workingHours?: boolean
    salary?: boolean
    bonus?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employees"]>

  export type EmployeesSelectScalar = {
    id?: boolean
    userId?: boolean
    employeeNumberId?: boolean
    hireDate?: boolean
    employeePosition?: boolean
    workingHours?: boolean
    salary?: boolean
    bonus?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EmployeesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "employeeNumberId" | "hireDate" | "employeePosition" | "workingHours" | "salary" | "bonus" | "createdAt" | "updatedAt", ExtArgs["result"]["employees"]>
  export type EmployeesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UsersDefaultArgs<ExtArgs>
    Announcements?: boolean | Employees$AnnouncementsArgs<ExtArgs>
    Complaints?: boolean | Employees$ComplaintsArgs<ExtArgs>
    Bills?: boolean | Employees$BillsArgs<ExtArgs>
    Payments?: boolean | Employees$PaymentsArgs<ExtArgs>
    SecurityReports?: boolean | Employees$SecurityReportsArgs<ExtArgs>
    _count?: boolean | EmployeesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EmployeesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UsersDefaultArgs<ExtArgs>
  }
  export type EmployeesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UsersDefaultArgs<ExtArgs>
  }

  export type $EmployeesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Employees"
    objects: {
      user: Prisma.$UsersPayload<ExtArgs>
      Announcements: Prisma.$AnnouncementsPayload<ExtArgs>[]
      Complaints: Prisma.$ComplaintsPayload<ExtArgs>[]
      Bills: Prisma.$BillsPayload<ExtArgs>[]
      Payments: Prisma.$PaymentsPayload<ExtArgs>[]
      SecurityReports: Prisma.$SecurityReportsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      employeeNumberId: string
      hireDate: Date
      employeePosition: $Enums.EmployeeRole
      workingHours: number
      salary: number
      bonus: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["employees"]>
    composites: {}
  }

  type EmployeesGetPayload<S extends boolean | null | undefined | EmployeesDefaultArgs> = $Result.GetResult<Prisma.$EmployeesPayload, S>

  type EmployeesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmployeesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmployeesCountAggregateInputType | true
    }

  export interface EmployeesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Employees'], meta: { name: 'Employees' } }
    /**
     * Find zero or one Employees that matches the filter.
     * @param {EmployeesFindUniqueArgs} args - Arguments to find a Employees
     * @example
     * // Get one Employees
     * const employees = await prisma.employees.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmployeesFindUniqueArgs>(args: SelectSubset<T, EmployeesFindUniqueArgs<ExtArgs>>): Prisma__EmployeesClient<$Result.GetResult<Prisma.$EmployeesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Employees that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmployeesFindUniqueOrThrowArgs} args - Arguments to find a Employees
     * @example
     * // Get one Employees
     * const employees = await prisma.employees.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmployeesFindUniqueOrThrowArgs>(args: SelectSubset<T, EmployeesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmployeesClient<$Result.GetResult<Prisma.$EmployeesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Employees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeesFindFirstArgs} args - Arguments to find a Employees
     * @example
     * // Get one Employees
     * const employees = await prisma.employees.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmployeesFindFirstArgs>(args?: SelectSubset<T, EmployeesFindFirstArgs<ExtArgs>>): Prisma__EmployeesClient<$Result.GetResult<Prisma.$EmployeesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Employees that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeesFindFirstOrThrowArgs} args - Arguments to find a Employees
     * @example
     * // Get one Employees
     * const employees = await prisma.employees.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmployeesFindFirstOrThrowArgs>(args?: SelectSubset<T, EmployeesFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmployeesClient<$Result.GetResult<Prisma.$EmployeesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Employees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Employees
     * const employees = await prisma.employees.findMany()
     * 
     * // Get first 10 Employees
     * const employees = await prisma.employees.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const employeesWithIdOnly = await prisma.employees.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmployeesFindManyArgs>(args?: SelectSubset<T, EmployeesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Employees.
     * @param {EmployeesCreateArgs} args - Arguments to create a Employees.
     * @example
     * // Create one Employees
     * const Employees = await prisma.employees.create({
     *   data: {
     *     // ... data to create a Employees
     *   }
     * })
     * 
     */
    create<T extends EmployeesCreateArgs>(args: SelectSubset<T, EmployeesCreateArgs<ExtArgs>>): Prisma__EmployeesClient<$Result.GetResult<Prisma.$EmployeesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Employees.
     * @param {EmployeesCreateManyArgs} args - Arguments to create many Employees.
     * @example
     * // Create many Employees
     * const employees = await prisma.employees.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmployeesCreateManyArgs>(args?: SelectSubset<T, EmployeesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Employees and returns the data saved in the database.
     * @param {EmployeesCreateManyAndReturnArgs} args - Arguments to create many Employees.
     * @example
     * // Create many Employees
     * const employees = await prisma.employees.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Employees and only return the `id`
     * const employeesWithIdOnly = await prisma.employees.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmployeesCreateManyAndReturnArgs>(args?: SelectSubset<T, EmployeesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Employees.
     * @param {EmployeesDeleteArgs} args - Arguments to delete one Employees.
     * @example
     * // Delete one Employees
     * const Employees = await prisma.employees.delete({
     *   where: {
     *     // ... filter to delete one Employees
     *   }
     * })
     * 
     */
    delete<T extends EmployeesDeleteArgs>(args: SelectSubset<T, EmployeesDeleteArgs<ExtArgs>>): Prisma__EmployeesClient<$Result.GetResult<Prisma.$EmployeesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Employees.
     * @param {EmployeesUpdateArgs} args - Arguments to update one Employees.
     * @example
     * // Update one Employees
     * const employees = await prisma.employees.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmployeesUpdateArgs>(args: SelectSubset<T, EmployeesUpdateArgs<ExtArgs>>): Prisma__EmployeesClient<$Result.GetResult<Prisma.$EmployeesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Employees.
     * @param {EmployeesDeleteManyArgs} args - Arguments to filter Employees to delete.
     * @example
     * // Delete a few Employees
     * const { count } = await prisma.employees.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmployeesDeleteManyArgs>(args?: SelectSubset<T, EmployeesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Employees
     * const employees = await prisma.employees.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmployeesUpdateManyArgs>(args: SelectSubset<T, EmployeesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Employees and returns the data updated in the database.
     * @param {EmployeesUpdateManyAndReturnArgs} args - Arguments to update many Employees.
     * @example
     * // Update many Employees
     * const employees = await prisma.employees.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Employees and only return the `id`
     * const employeesWithIdOnly = await prisma.employees.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EmployeesUpdateManyAndReturnArgs>(args: SelectSubset<T, EmployeesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Employees.
     * @param {EmployeesUpsertArgs} args - Arguments to update or create a Employees.
     * @example
     * // Update or create a Employees
     * const employees = await prisma.employees.upsert({
     *   create: {
     *     // ... data to create a Employees
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Employees we want to update
     *   }
     * })
     */
    upsert<T extends EmployeesUpsertArgs>(args: SelectSubset<T, EmployeesUpsertArgs<ExtArgs>>): Prisma__EmployeesClient<$Result.GetResult<Prisma.$EmployeesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeesCountArgs} args - Arguments to filter Employees to count.
     * @example
     * // Count the number of Employees
     * const count = await prisma.employees.count({
     *   where: {
     *     // ... the filter for the Employees we want to count
     *   }
     * })
    **/
    count<T extends EmployeesCountArgs>(
      args?: Subset<T, EmployeesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmployeesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmployeesAggregateArgs>(args: Subset<T, EmployeesAggregateArgs>): Prisma.PrismaPromise<GetEmployeesAggregateType<T>>

    /**
     * Group by Employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmployeesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmployeesGroupByArgs['orderBy'] }
        : { orderBy?: EmployeesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmployeesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmployeesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Employees model
   */
  readonly fields: EmployeesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Employees.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmployeesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Announcements<T extends Employees$AnnouncementsArgs<ExtArgs> = {}>(args?: Subset<T, Employees$AnnouncementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnnouncementsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Complaints<T extends Employees$ComplaintsArgs<ExtArgs> = {}>(args?: Subset<T, Employees$ComplaintsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComplaintsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Bills<T extends Employees$BillsArgs<ExtArgs> = {}>(args?: Subset<T, Employees$BillsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Payments<T extends Employees$PaymentsArgs<ExtArgs> = {}>(args?: Subset<T, Employees$PaymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    SecurityReports<T extends Employees$SecurityReportsArgs<ExtArgs> = {}>(args?: Subset<T, Employees$SecurityReportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SecurityReportsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Employees model
   */
  interface EmployeesFieldRefs {
    readonly id: FieldRef<"Employees", 'String'>
    readonly userId: FieldRef<"Employees", 'String'>
    readonly employeeNumberId: FieldRef<"Employees", 'String'>
    readonly hireDate: FieldRef<"Employees", 'DateTime'>
    readonly employeePosition: FieldRef<"Employees", 'EmployeeRole'>
    readonly workingHours: FieldRef<"Employees", 'Int'>
    readonly salary: FieldRef<"Employees", 'Float'>
    readonly bonus: FieldRef<"Employees", 'Float'>
    readonly createdAt: FieldRef<"Employees", 'DateTime'>
    readonly updatedAt: FieldRef<"Employees", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Employees findUnique
   */
  export type EmployeesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employees
     */
    select?: EmployeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employees
     */
    omit?: EmployeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeesInclude<ExtArgs> | null
    /**
     * Filter, which Employees to fetch.
     */
    where: EmployeesWhereUniqueInput
  }

  /**
   * Employees findUniqueOrThrow
   */
  export type EmployeesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employees
     */
    select?: EmployeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employees
     */
    omit?: EmployeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeesInclude<ExtArgs> | null
    /**
     * Filter, which Employees to fetch.
     */
    where: EmployeesWhereUniqueInput
  }

  /**
   * Employees findFirst
   */
  export type EmployeesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employees
     */
    select?: EmployeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employees
     */
    omit?: EmployeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeesInclude<ExtArgs> | null
    /**
     * Filter, which Employees to fetch.
     */
    where?: EmployeesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeesOrderByWithRelationInput | EmployeesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Employees.
     */
    cursor?: EmployeesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Employees.
     */
    distinct?: EmployeesScalarFieldEnum | EmployeesScalarFieldEnum[]
  }

  /**
   * Employees findFirstOrThrow
   */
  export type EmployeesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employees
     */
    select?: EmployeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employees
     */
    omit?: EmployeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeesInclude<ExtArgs> | null
    /**
     * Filter, which Employees to fetch.
     */
    where?: EmployeesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeesOrderByWithRelationInput | EmployeesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Employees.
     */
    cursor?: EmployeesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Employees.
     */
    distinct?: EmployeesScalarFieldEnum | EmployeesScalarFieldEnum[]
  }

  /**
   * Employees findMany
   */
  export type EmployeesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employees
     */
    select?: EmployeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employees
     */
    omit?: EmployeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeesInclude<ExtArgs> | null
    /**
     * Filter, which Employees to fetch.
     */
    where?: EmployeesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeesOrderByWithRelationInput | EmployeesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Employees.
     */
    cursor?: EmployeesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    distinct?: EmployeesScalarFieldEnum | EmployeesScalarFieldEnum[]
  }

  /**
   * Employees create
   */
  export type EmployeesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employees
     */
    select?: EmployeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employees
     */
    omit?: EmployeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeesInclude<ExtArgs> | null
    /**
     * The data needed to create a Employees.
     */
    data: XOR<EmployeesCreateInput, EmployeesUncheckedCreateInput>
  }

  /**
   * Employees createMany
   */
  export type EmployeesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Employees.
     */
    data: EmployeesCreateManyInput | EmployeesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Employees createManyAndReturn
   */
  export type EmployeesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employees
     */
    select?: EmployeesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Employees
     */
    omit?: EmployeesOmit<ExtArgs> | null
    /**
     * The data used to create many Employees.
     */
    data: EmployeesCreateManyInput | EmployeesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Employees update
   */
  export type EmployeesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employees
     */
    select?: EmployeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employees
     */
    omit?: EmployeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeesInclude<ExtArgs> | null
    /**
     * The data needed to update a Employees.
     */
    data: XOR<EmployeesUpdateInput, EmployeesUncheckedUpdateInput>
    /**
     * Choose, which Employees to update.
     */
    where: EmployeesWhereUniqueInput
  }

  /**
   * Employees updateMany
   */
  export type EmployeesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Employees.
     */
    data: XOR<EmployeesUpdateManyMutationInput, EmployeesUncheckedUpdateManyInput>
    /**
     * Filter which Employees to update
     */
    where?: EmployeesWhereInput
    /**
     * Limit how many Employees to update.
     */
    limit?: number
  }

  /**
   * Employees updateManyAndReturn
   */
  export type EmployeesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employees
     */
    select?: EmployeesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Employees
     */
    omit?: EmployeesOmit<ExtArgs> | null
    /**
     * The data used to update Employees.
     */
    data: XOR<EmployeesUpdateManyMutationInput, EmployeesUncheckedUpdateManyInput>
    /**
     * Filter which Employees to update
     */
    where?: EmployeesWhereInput
    /**
     * Limit how many Employees to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Employees upsert
   */
  export type EmployeesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employees
     */
    select?: EmployeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employees
     */
    omit?: EmployeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeesInclude<ExtArgs> | null
    /**
     * The filter to search for the Employees to update in case it exists.
     */
    where: EmployeesWhereUniqueInput
    /**
     * In case the Employees found by the `where` argument doesn't exist, create a new Employees with this data.
     */
    create: XOR<EmployeesCreateInput, EmployeesUncheckedCreateInput>
    /**
     * In case the Employees was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmployeesUpdateInput, EmployeesUncheckedUpdateInput>
  }

  /**
   * Employees delete
   */
  export type EmployeesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employees
     */
    select?: EmployeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employees
     */
    omit?: EmployeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeesInclude<ExtArgs> | null
    /**
     * Filter which Employees to delete.
     */
    where: EmployeesWhereUniqueInput
  }

  /**
   * Employees deleteMany
   */
  export type EmployeesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Employees to delete
     */
    where?: EmployeesWhereInput
    /**
     * Limit how many Employees to delete.
     */
    limit?: number
  }

  /**
   * Employees.Announcements
   */
  export type Employees$AnnouncementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcements
     */
    select?: AnnouncementsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcements
     */
    omit?: AnnouncementsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementsInclude<ExtArgs> | null
    where?: AnnouncementsWhereInput
    orderBy?: AnnouncementsOrderByWithRelationInput | AnnouncementsOrderByWithRelationInput[]
    cursor?: AnnouncementsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AnnouncementsScalarFieldEnum | AnnouncementsScalarFieldEnum[]
  }

  /**
   * Employees.Complaints
   */
  export type Employees$ComplaintsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Complaints
     */
    select?: ComplaintsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Complaints
     */
    omit?: ComplaintsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintsInclude<ExtArgs> | null
    where?: ComplaintsWhereInput
    orderBy?: ComplaintsOrderByWithRelationInput | ComplaintsOrderByWithRelationInput[]
    cursor?: ComplaintsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ComplaintsScalarFieldEnum | ComplaintsScalarFieldEnum[]
  }

  /**
   * Employees.Bills
   */
  export type Employees$BillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bills
     */
    select?: BillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bills
     */
    omit?: BillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillsInclude<ExtArgs> | null
    where?: BillsWhereInput
    orderBy?: BillsOrderByWithRelationInput | BillsOrderByWithRelationInput[]
    cursor?: BillsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BillsScalarFieldEnum | BillsScalarFieldEnum[]
  }

  /**
   * Employees.Payments
   */
  export type Employees$PaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payments
     */
    select?: PaymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payments
     */
    omit?: PaymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentsInclude<ExtArgs> | null
    where?: PaymentsWhereInput
    orderBy?: PaymentsOrderByWithRelationInput | PaymentsOrderByWithRelationInput[]
    cursor?: PaymentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentsScalarFieldEnum | PaymentsScalarFieldEnum[]
  }

  /**
   * Employees.SecurityReports
   */
  export type Employees$SecurityReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityReports
     */
    select?: SecurityReportsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityReports
     */
    omit?: SecurityReportsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityReportsInclude<ExtArgs> | null
    where?: SecurityReportsWhereInput
    orderBy?: SecurityReportsOrderByWithRelationInput | SecurityReportsOrderByWithRelationInput[]
    cursor?: SecurityReportsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SecurityReportsScalarFieldEnum | SecurityReportsScalarFieldEnum[]
  }

  /**
   * Employees without action
   */
  export type EmployeesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employees
     */
    select?: EmployeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employees
     */
    omit?: EmployeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeesInclude<ExtArgs> | null
  }


  /**
   * Model Complaints
   */

  export type AggregateComplaints = {
    _count: ComplaintsCountAggregateOutputType | null
    _min: ComplaintsMinAggregateOutputType | null
    _max: ComplaintsMaxAggregateOutputType | null
  }

  export type ComplaintsMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    category: $Enums.MaintenanceCategory | null
    status: $Enums.ComplaintStatus | null
    submittedAt: Date | null
    resolvedAt: Date | null
    resolutionDetails: string | null
    residentId: string | null
    employeeId: string | null
    unitId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ComplaintsMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    category: $Enums.MaintenanceCategory | null
    status: $Enums.ComplaintStatus | null
    submittedAt: Date | null
    resolvedAt: Date | null
    resolutionDetails: string | null
    residentId: string | null
    employeeId: string | null
    unitId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ComplaintsCountAggregateOutputType = {
    id: number
    title: number
    description: number
    category: number
    status: number
    images: number
    submittedAt: number
    resolvedAt: number
    resolutionDetails: number
    residentId: number
    employeeId: number
    unitId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ComplaintsMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    category?: true
    status?: true
    submittedAt?: true
    resolvedAt?: true
    resolutionDetails?: true
    residentId?: true
    employeeId?: true
    unitId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ComplaintsMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    category?: true
    status?: true
    submittedAt?: true
    resolvedAt?: true
    resolutionDetails?: true
    residentId?: true
    employeeId?: true
    unitId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ComplaintsCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    category?: true
    status?: true
    images?: true
    submittedAt?: true
    resolvedAt?: true
    resolutionDetails?: true
    residentId?: true
    employeeId?: true
    unitId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ComplaintsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Complaints to aggregate.
     */
    where?: ComplaintsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Complaints to fetch.
     */
    orderBy?: ComplaintsOrderByWithRelationInput | ComplaintsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ComplaintsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Complaints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Complaints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Complaints
    **/
    _count?: true | ComplaintsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ComplaintsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ComplaintsMaxAggregateInputType
  }

  export type GetComplaintsAggregateType<T extends ComplaintsAggregateArgs> = {
        [P in keyof T & keyof AggregateComplaints]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComplaints[P]>
      : GetScalarType<T[P], AggregateComplaints[P]>
  }




  export type ComplaintsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComplaintsWhereInput
    orderBy?: ComplaintsOrderByWithAggregationInput | ComplaintsOrderByWithAggregationInput[]
    by: ComplaintsScalarFieldEnum[] | ComplaintsScalarFieldEnum
    having?: ComplaintsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ComplaintsCountAggregateInputType | true
    _min?: ComplaintsMinAggregateInputType
    _max?: ComplaintsMaxAggregateInputType
  }

  export type ComplaintsGroupByOutputType = {
    id: string
    title: string
    description: string
    category: $Enums.MaintenanceCategory
    status: $Enums.ComplaintStatus
    images: string[]
    submittedAt: Date
    resolvedAt: Date | null
    resolutionDetails: string | null
    residentId: string
    employeeId: string | null
    unitId: string | null
    createdAt: Date
    updatedAt: Date
    _count: ComplaintsCountAggregateOutputType | null
    _min: ComplaintsMinAggregateOutputType | null
    _max: ComplaintsMaxAggregateOutputType | null
  }

  type GetComplaintsGroupByPayload<T extends ComplaintsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ComplaintsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ComplaintsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ComplaintsGroupByOutputType[P]>
            : GetScalarType<T[P], ComplaintsGroupByOutputType[P]>
        }
      >
    >


  export type ComplaintsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    status?: boolean
    images?: boolean
    submittedAt?: boolean
    resolvedAt?: boolean
    resolutionDetails?: boolean
    residentId?: boolean
    employeeId?: boolean
    unitId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    resident?: boolean | ResidentsDefaultArgs<ExtArgs>
    employee?: boolean | Complaints$employeeArgs<ExtArgs>
    unit?: boolean | Complaints$unitArgs<ExtArgs>
  }, ExtArgs["result"]["complaints"]>

  export type ComplaintsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    status?: boolean
    images?: boolean
    submittedAt?: boolean
    resolvedAt?: boolean
    resolutionDetails?: boolean
    residentId?: boolean
    employeeId?: boolean
    unitId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    resident?: boolean | ResidentsDefaultArgs<ExtArgs>
    employee?: boolean | Complaints$employeeArgs<ExtArgs>
    unit?: boolean | Complaints$unitArgs<ExtArgs>
  }, ExtArgs["result"]["complaints"]>

  export type ComplaintsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    status?: boolean
    images?: boolean
    submittedAt?: boolean
    resolvedAt?: boolean
    resolutionDetails?: boolean
    residentId?: boolean
    employeeId?: boolean
    unitId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    resident?: boolean | ResidentsDefaultArgs<ExtArgs>
    employee?: boolean | Complaints$employeeArgs<ExtArgs>
    unit?: boolean | Complaints$unitArgs<ExtArgs>
  }, ExtArgs["result"]["complaints"]>

  export type ComplaintsSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    status?: boolean
    images?: boolean
    submittedAt?: boolean
    resolvedAt?: boolean
    resolutionDetails?: boolean
    residentId?: boolean
    employeeId?: boolean
    unitId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ComplaintsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "category" | "status" | "images" | "submittedAt" | "resolvedAt" | "resolutionDetails" | "residentId" | "employeeId" | "unitId" | "createdAt" | "updatedAt", ExtArgs["result"]["complaints"]>
  export type ComplaintsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    resident?: boolean | ResidentsDefaultArgs<ExtArgs>
    employee?: boolean | Complaints$employeeArgs<ExtArgs>
    unit?: boolean | Complaints$unitArgs<ExtArgs>
  }
  export type ComplaintsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    resident?: boolean | ResidentsDefaultArgs<ExtArgs>
    employee?: boolean | Complaints$employeeArgs<ExtArgs>
    unit?: boolean | Complaints$unitArgs<ExtArgs>
  }
  export type ComplaintsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    resident?: boolean | ResidentsDefaultArgs<ExtArgs>
    employee?: boolean | Complaints$employeeArgs<ExtArgs>
    unit?: boolean | Complaints$unitArgs<ExtArgs>
  }

  export type $ComplaintsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Complaints"
    objects: {
      resident: Prisma.$ResidentsPayload<ExtArgs>
      employee: Prisma.$EmployeesPayload<ExtArgs> | null
      unit: Prisma.$UnitsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string
      category: $Enums.MaintenanceCategory
      status: $Enums.ComplaintStatus
      images: string[]
      submittedAt: Date
      resolvedAt: Date | null
      resolutionDetails: string | null
      residentId: string
      employeeId: string | null
      unitId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["complaints"]>
    composites: {}
  }

  type ComplaintsGetPayload<S extends boolean | null | undefined | ComplaintsDefaultArgs> = $Result.GetResult<Prisma.$ComplaintsPayload, S>

  type ComplaintsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ComplaintsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ComplaintsCountAggregateInputType | true
    }

  export interface ComplaintsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Complaints'], meta: { name: 'Complaints' } }
    /**
     * Find zero or one Complaints that matches the filter.
     * @param {ComplaintsFindUniqueArgs} args - Arguments to find a Complaints
     * @example
     * // Get one Complaints
     * const complaints = await prisma.complaints.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ComplaintsFindUniqueArgs>(args: SelectSubset<T, ComplaintsFindUniqueArgs<ExtArgs>>): Prisma__ComplaintsClient<$Result.GetResult<Prisma.$ComplaintsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Complaints that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ComplaintsFindUniqueOrThrowArgs} args - Arguments to find a Complaints
     * @example
     * // Get one Complaints
     * const complaints = await prisma.complaints.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ComplaintsFindUniqueOrThrowArgs>(args: SelectSubset<T, ComplaintsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ComplaintsClient<$Result.GetResult<Prisma.$ComplaintsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Complaints that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplaintsFindFirstArgs} args - Arguments to find a Complaints
     * @example
     * // Get one Complaints
     * const complaints = await prisma.complaints.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ComplaintsFindFirstArgs>(args?: SelectSubset<T, ComplaintsFindFirstArgs<ExtArgs>>): Prisma__ComplaintsClient<$Result.GetResult<Prisma.$ComplaintsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Complaints that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplaintsFindFirstOrThrowArgs} args - Arguments to find a Complaints
     * @example
     * // Get one Complaints
     * const complaints = await prisma.complaints.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ComplaintsFindFirstOrThrowArgs>(args?: SelectSubset<T, ComplaintsFindFirstOrThrowArgs<ExtArgs>>): Prisma__ComplaintsClient<$Result.GetResult<Prisma.$ComplaintsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Complaints that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplaintsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Complaints
     * const complaints = await prisma.complaints.findMany()
     * 
     * // Get first 10 Complaints
     * const complaints = await prisma.complaints.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const complaintsWithIdOnly = await prisma.complaints.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ComplaintsFindManyArgs>(args?: SelectSubset<T, ComplaintsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComplaintsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Complaints.
     * @param {ComplaintsCreateArgs} args - Arguments to create a Complaints.
     * @example
     * // Create one Complaints
     * const Complaints = await prisma.complaints.create({
     *   data: {
     *     // ... data to create a Complaints
     *   }
     * })
     * 
     */
    create<T extends ComplaintsCreateArgs>(args: SelectSubset<T, ComplaintsCreateArgs<ExtArgs>>): Prisma__ComplaintsClient<$Result.GetResult<Prisma.$ComplaintsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Complaints.
     * @param {ComplaintsCreateManyArgs} args - Arguments to create many Complaints.
     * @example
     * // Create many Complaints
     * const complaints = await prisma.complaints.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ComplaintsCreateManyArgs>(args?: SelectSubset<T, ComplaintsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Complaints and returns the data saved in the database.
     * @param {ComplaintsCreateManyAndReturnArgs} args - Arguments to create many Complaints.
     * @example
     * // Create many Complaints
     * const complaints = await prisma.complaints.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Complaints and only return the `id`
     * const complaintsWithIdOnly = await prisma.complaints.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ComplaintsCreateManyAndReturnArgs>(args?: SelectSubset<T, ComplaintsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComplaintsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Complaints.
     * @param {ComplaintsDeleteArgs} args - Arguments to delete one Complaints.
     * @example
     * // Delete one Complaints
     * const Complaints = await prisma.complaints.delete({
     *   where: {
     *     // ... filter to delete one Complaints
     *   }
     * })
     * 
     */
    delete<T extends ComplaintsDeleteArgs>(args: SelectSubset<T, ComplaintsDeleteArgs<ExtArgs>>): Prisma__ComplaintsClient<$Result.GetResult<Prisma.$ComplaintsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Complaints.
     * @param {ComplaintsUpdateArgs} args - Arguments to update one Complaints.
     * @example
     * // Update one Complaints
     * const complaints = await prisma.complaints.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ComplaintsUpdateArgs>(args: SelectSubset<T, ComplaintsUpdateArgs<ExtArgs>>): Prisma__ComplaintsClient<$Result.GetResult<Prisma.$ComplaintsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Complaints.
     * @param {ComplaintsDeleteManyArgs} args - Arguments to filter Complaints to delete.
     * @example
     * // Delete a few Complaints
     * const { count } = await prisma.complaints.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ComplaintsDeleteManyArgs>(args?: SelectSubset<T, ComplaintsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Complaints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplaintsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Complaints
     * const complaints = await prisma.complaints.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ComplaintsUpdateManyArgs>(args: SelectSubset<T, ComplaintsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Complaints and returns the data updated in the database.
     * @param {ComplaintsUpdateManyAndReturnArgs} args - Arguments to update many Complaints.
     * @example
     * // Update many Complaints
     * const complaints = await prisma.complaints.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Complaints and only return the `id`
     * const complaintsWithIdOnly = await prisma.complaints.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ComplaintsUpdateManyAndReturnArgs>(args: SelectSubset<T, ComplaintsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComplaintsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Complaints.
     * @param {ComplaintsUpsertArgs} args - Arguments to update or create a Complaints.
     * @example
     * // Update or create a Complaints
     * const complaints = await prisma.complaints.upsert({
     *   create: {
     *     // ... data to create a Complaints
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Complaints we want to update
     *   }
     * })
     */
    upsert<T extends ComplaintsUpsertArgs>(args: SelectSubset<T, ComplaintsUpsertArgs<ExtArgs>>): Prisma__ComplaintsClient<$Result.GetResult<Prisma.$ComplaintsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Complaints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplaintsCountArgs} args - Arguments to filter Complaints to count.
     * @example
     * // Count the number of Complaints
     * const count = await prisma.complaints.count({
     *   where: {
     *     // ... the filter for the Complaints we want to count
     *   }
     * })
    **/
    count<T extends ComplaintsCountArgs>(
      args?: Subset<T, ComplaintsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ComplaintsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Complaints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplaintsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ComplaintsAggregateArgs>(args: Subset<T, ComplaintsAggregateArgs>): Prisma.PrismaPromise<GetComplaintsAggregateType<T>>

    /**
     * Group by Complaints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplaintsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ComplaintsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ComplaintsGroupByArgs['orderBy'] }
        : { orderBy?: ComplaintsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ComplaintsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetComplaintsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Complaints model
   */
  readonly fields: ComplaintsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Complaints.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ComplaintsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    resident<T extends ResidentsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ResidentsDefaultArgs<ExtArgs>>): Prisma__ResidentsClient<$Result.GetResult<Prisma.$ResidentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    employee<T extends Complaints$employeeArgs<ExtArgs> = {}>(args?: Subset<T, Complaints$employeeArgs<ExtArgs>>): Prisma__EmployeesClient<$Result.GetResult<Prisma.$EmployeesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    unit<T extends Complaints$unitArgs<ExtArgs> = {}>(args?: Subset<T, Complaints$unitArgs<ExtArgs>>): Prisma__UnitsClient<$Result.GetResult<Prisma.$UnitsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Complaints model
   */
  interface ComplaintsFieldRefs {
    readonly id: FieldRef<"Complaints", 'String'>
    readonly title: FieldRef<"Complaints", 'String'>
    readonly description: FieldRef<"Complaints", 'String'>
    readonly category: FieldRef<"Complaints", 'MaintenanceCategory'>
    readonly status: FieldRef<"Complaints", 'ComplaintStatus'>
    readonly images: FieldRef<"Complaints", 'String[]'>
    readonly submittedAt: FieldRef<"Complaints", 'DateTime'>
    readonly resolvedAt: FieldRef<"Complaints", 'DateTime'>
    readonly resolutionDetails: FieldRef<"Complaints", 'String'>
    readonly residentId: FieldRef<"Complaints", 'String'>
    readonly employeeId: FieldRef<"Complaints", 'String'>
    readonly unitId: FieldRef<"Complaints", 'String'>
    readonly createdAt: FieldRef<"Complaints", 'DateTime'>
    readonly updatedAt: FieldRef<"Complaints", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Complaints findUnique
   */
  export type ComplaintsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Complaints
     */
    select?: ComplaintsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Complaints
     */
    omit?: ComplaintsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintsInclude<ExtArgs> | null
    /**
     * Filter, which Complaints to fetch.
     */
    where: ComplaintsWhereUniqueInput
  }

  /**
   * Complaints findUniqueOrThrow
   */
  export type ComplaintsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Complaints
     */
    select?: ComplaintsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Complaints
     */
    omit?: ComplaintsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintsInclude<ExtArgs> | null
    /**
     * Filter, which Complaints to fetch.
     */
    where: ComplaintsWhereUniqueInput
  }

  /**
   * Complaints findFirst
   */
  export type ComplaintsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Complaints
     */
    select?: ComplaintsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Complaints
     */
    omit?: ComplaintsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintsInclude<ExtArgs> | null
    /**
     * Filter, which Complaints to fetch.
     */
    where?: ComplaintsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Complaints to fetch.
     */
    orderBy?: ComplaintsOrderByWithRelationInput | ComplaintsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Complaints.
     */
    cursor?: ComplaintsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Complaints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Complaints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Complaints.
     */
    distinct?: ComplaintsScalarFieldEnum | ComplaintsScalarFieldEnum[]
  }

  /**
   * Complaints findFirstOrThrow
   */
  export type ComplaintsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Complaints
     */
    select?: ComplaintsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Complaints
     */
    omit?: ComplaintsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintsInclude<ExtArgs> | null
    /**
     * Filter, which Complaints to fetch.
     */
    where?: ComplaintsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Complaints to fetch.
     */
    orderBy?: ComplaintsOrderByWithRelationInput | ComplaintsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Complaints.
     */
    cursor?: ComplaintsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Complaints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Complaints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Complaints.
     */
    distinct?: ComplaintsScalarFieldEnum | ComplaintsScalarFieldEnum[]
  }

  /**
   * Complaints findMany
   */
  export type ComplaintsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Complaints
     */
    select?: ComplaintsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Complaints
     */
    omit?: ComplaintsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintsInclude<ExtArgs> | null
    /**
     * Filter, which Complaints to fetch.
     */
    where?: ComplaintsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Complaints to fetch.
     */
    orderBy?: ComplaintsOrderByWithRelationInput | ComplaintsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Complaints.
     */
    cursor?: ComplaintsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Complaints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Complaints.
     */
    skip?: number
    distinct?: ComplaintsScalarFieldEnum | ComplaintsScalarFieldEnum[]
  }

  /**
   * Complaints create
   */
  export type ComplaintsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Complaints
     */
    select?: ComplaintsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Complaints
     */
    omit?: ComplaintsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintsInclude<ExtArgs> | null
    /**
     * The data needed to create a Complaints.
     */
    data: XOR<ComplaintsCreateInput, ComplaintsUncheckedCreateInput>
  }

  /**
   * Complaints createMany
   */
  export type ComplaintsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Complaints.
     */
    data: ComplaintsCreateManyInput | ComplaintsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Complaints createManyAndReturn
   */
  export type ComplaintsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Complaints
     */
    select?: ComplaintsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Complaints
     */
    omit?: ComplaintsOmit<ExtArgs> | null
    /**
     * The data used to create many Complaints.
     */
    data: ComplaintsCreateManyInput | ComplaintsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Complaints update
   */
  export type ComplaintsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Complaints
     */
    select?: ComplaintsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Complaints
     */
    omit?: ComplaintsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintsInclude<ExtArgs> | null
    /**
     * The data needed to update a Complaints.
     */
    data: XOR<ComplaintsUpdateInput, ComplaintsUncheckedUpdateInput>
    /**
     * Choose, which Complaints to update.
     */
    where: ComplaintsWhereUniqueInput
  }

  /**
   * Complaints updateMany
   */
  export type ComplaintsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Complaints.
     */
    data: XOR<ComplaintsUpdateManyMutationInput, ComplaintsUncheckedUpdateManyInput>
    /**
     * Filter which Complaints to update
     */
    where?: ComplaintsWhereInput
    /**
     * Limit how many Complaints to update.
     */
    limit?: number
  }

  /**
   * Complaints updateManyAndReturn
   */
  export type ComplaintsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Complaints
     */
    select?: ComplaintsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Complaints
     */
    omit?: ComplaintsOmit<ExtArgs> | null
    /**
     * The data used to update Complaints.
     */
    data: XOR<ComplaintsUpdateManyMutationInput, ComplaintsUncheckedUpdateManyInput>
    /**
     * Filter which Complaints to update
     */
    where?: ComplaintsWhereInput
    /**
     * Limit how many Complaints to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Complaints upsert
   */
  export type ComplaintsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Complaints
     */
    select?: ComplaintsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Complaints
     */
    omit?: ComplaintsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintsInclude<ExtArgs> | null
    /**
     * The filter to search for the Complaints to update in case it exists.
     */
    where: ComplaintsWhereUniqueInput
    /**
     * In case the Complaints found by the `where` argument doesn't exist, create a new Complaints with this data.
     */
    create: XOR<ComplaintsCreateInput, ComplaintsUncheckedCreateInput>
    /**
     * In case the Complaints was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ComplaintsUpdateInput, ComplaintsUncheckedUpdateInput>
  }

  /**
   * Complaints delete
   */
  export type ComplaintsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Complaints
     */
    select?: ComplaintsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Complaints
     */
    omit?: ComplaintsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintsInclude<ExtArgs> | null
    /**
     * Filter which Complaints to delete.
     */
    where: ComplaintsWhereUniqueInput
  }

  /**
   * Complaints deleteMany
   */
  export type ComplaintsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Complaints to delete
     */
    where?: ComplaintsWhereInput
    /**
     * Limit how many Complaints to delete.
     */
    limit?: number
  }

  /**
   * Complaints.employee
   */
  export type Complaints$employeeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employees
     */
    select?: EmployeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employees
     */
    omit?: EmployeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeesInclude<ExtArgs> | null
    where?: EmployeesWhereInput
  }

  /**
   * Complaints.unit
   */
  export type Complaints$unitArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Units
     */
    select?: UnitsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Units
     */
    omit?: UnitsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitsInclude<ExtArgs> | null
    where?: UnitsWhereInput
  }

  /**
   * Complaints without action
   */
  export type ComplaintsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Complaints
     */
    select?: ComplaintsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Complaints
     */
    omit?: ComplaintsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintsInclude<ExtArgs> | null
  }


  /**
   * Model Announcements
   */

  export type AggregateAnnouncements = {
    _count: AnnouncementsCountAggregateOutputType | null
    _min: AnnouncementsMinAggregateOutputType | null
    _max: AnnouncementsMaxAggregateOutputType | null
  }

  export type AnnouncementsMinAggregateOutputType = {
    id: string | null
    title: string | null
    content: string | null
    publishDate: Date | null
    expiryDate: Date | null
    employeeId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AnnouncementsMaxAggregateOutputType = {
    id: string | null
    title: string | null
    content: string | null
    publishDate: Date | null
    expiryDate: Date | null
    employeeId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AnnouncementsCountAggregateOutputType = {
    id: number
    title: number
    content: number
    attachments: number
    publishDate: number
    expiryDate: number
    employeeId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AnnouncementsMinAggregateInputType = {
    id?: true
    title?: true
    content?: true
    publishDate?: true
    expiryDate?: true
    employeeId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AnnouncementsMaxAggregateInputType = {
    id?: true
    title?: true
    content?: true
    publishDate?: true
    expiryDate?: true
    employeeId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AnnouncementsCountAggregateInputType = {
    id?: true
    title?: true
    content?: true
    attachments?: true
    publishDate?: true
    expiryDate?: true
    employeeId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AnnouncementsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Announcements to aggregate.
     */
    where?: AnnouncementsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Announcements to fetch.
     */
    orderBy?: AnnouncementsOrderByWithRelationInput | AnnouncementsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AnnouncementsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Announcements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Announcements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Announcements
    **/
    _count?: true | AnnouncementsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AnnouncementsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AnnouncementsMaxAggregateInputType
  }

  export type GetAnnouncementsAggregateType<T extends AnnouncementsAggregateArgs> = {
        [P in keyof T & keyof AggregateAnnouncements]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnnouncements[P]>
      : GetScalarType<T[P], AggregateAnnouncements[P]>
  }




  export type AnnouncementsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnnouncementsWhereInput
    orderBy?: AnnouncementsOrderByWithAggregationInput | AnnouncementsOrderByWithAggregationInput[]
    by: AnnouncementsScalarFieldEnum[] | AnnouncementsScalarFieldEnum
    having?: AnnouncementsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AnnouncementsCountAggregateInputType | true
    _min?: AnnouncementsMinAggregateInputType
    _max?: AnnouncementsMaxAggregateInputType
  }

  export type AnnouncementsGroupByOutputType = {
    id: string
    title: string
    content: string
    attachments: string[]
    publishDate: Date
    expiryDate: Date | null
    employeeId: string
    createdAt: Date
    updatedAt: Date
    _count: AnnouncementsCountAggregateOutputType | null
    _min: AnnouncementsMinAggregateOutputType | null
    _max: AnnouncementsMaxAggregateOutputType | null
  }

  type GetAnnouncementsGroupByPayload<T extends AnnouncementsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AnnouncementsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AnnouncementsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnnouncementsGroupByOutputType[P]>
            : GetScalarType<T[P], AnnouncementsGroupByOutputType[P]>
        }
      >
    >


  export type AnnouncementsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    attachments?: boolean
    publishDate?: boolean
    expiryDate?: boolean
    employeeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | EmployeesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["announcements"]>

  export type AnnouncementsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    attachments?: boolean
    publishDate?: boolean
    expiryDate?: boolean
    employeeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | EmployeesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["announcements"]>

  export type AnnouncementsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    attachments?: boolean
    publishDate?: boolean
    expiryDate?: boolean
    employeeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | EmployeesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["announcements"]>

  export type AnnouncementsSelectScalar = {
    id?: boolean
    title?: boolean
    content?: boolean
    attachments?: boolean
    publishDate?: boolean
    expiryDate?: boolean
    employeeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AnnouncementsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "content" | "attachments" | "publishDate" | "expiryDate" | "employeeId" | "createdAt" | "updatedAt", ExtArgs["result"]["announcements"]>
  export type AnnouncementsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeesDefaultArgs<ExtArgs>
  }
  export type AnnouncementsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeesDefaultArgs<ExtArgs>
  }
  export type AnnouncementsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeesDefaultArgs<ExtArgs>
  }

  export type $AnnouncementsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Announcements"
    objects: {
      employee: Prisma.$EmployeesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      content: string
      attachments: string[]
      publishDate: Date
      expiryDate: Date | null
      employeeId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["announcements"]>
    composites: {}
  }

  type AnnouncementsGetPayload<S extends boolean | null | undefined | AnnouncementsDefaultArgs> = $Result.GetResult<Prisma.$AnnouncementsPayload, S>

  type AnnouncementsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AnnouncementsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AnnouncementsCountAggregateInputType | true
    }

  export interface AnnouncementsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Announcements'], meta: { name: 'Announcements' } }
    /**
     * Find zero or one Announcements that matches the filter.
     * @param {AnnouncementsFindUniqueArgs} args - Arguments to find a Announcements
     * @example
     * // Get one Announcements
     * const announcements = await prisma.announcements.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AnnouncementsFindUniqueArgs>(args: SelectSubset<T, AnnouncementsFindUniqueArgs<ExtArgs>>): Prisma__AnnouncementsClient<$Result.GetResult<Prisma.$AnnouncementsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Announcements that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AnnouncementsFindUniqueOrThrowArgs} args - Arguments to find a Announcements
     * @example
     * // Get one Announcements
     * const announcements = await prisma.announcements.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AnnouncementsFindUniqueOrThrowArgs>(args: SelectSubset<T, AnnouncementsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AnnouncementsClient<$Result.GetResult<Prisma.$AnnouncementsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Announcements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementsFindFirstArgs} args - Arguments to find a Announcements
     * @example
     * // Get one Announcements
     * const announcements = await prisma.announcements.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AnnouncementsFindFirstArgs>(args?: SelectSubset<T, AnnouncementsFindFirstArgs<ExtArgs>>): Prisma__AnnouncementsClient<$Result.GetResult<Prisma.$AnnouncementsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Announcements that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementsFindFirstOrThrowArgs} args - Arguments to find a Announcements
     * @example
     * // Get one Announcements
     * const announcements = await prisma.announcements.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AnnouncementsFindFirstOrThrowArgs>(args?: SelectSubset<T, AnnouncementsFindFirstOrThrowArgs<ExtArgs>>): Prisma__AnnouncementsClient<$Result.GetResult<Prisma.$AnnouncementsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Announcements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Announcements
     * const announcements = await prisma.announcements.findMany()
     * 
     * // Get first 10 Announcements
     * const announcements = await prisma.announcements.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const announcementsWithIdOnly = await prisma.announcements.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AnnouncementsFindManyArgs>(args?: SelectSubset<T, AnnouncementsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnnouncementsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Announcements.
     * @param {AnnouncementsCreateArgs} args - Arguments to create a Announcements.
     * @example
     * // Create one Announcements
     * const Announcements = await prisma.announcements.create({
     *   data: {
     *     // ... data to create a Announcements
     *   }
     * })
     * 
     */
    create<T extends AnnouncementsCreateArgs>(args: SelectSubset<T, AnnouncementsCreateArgs<ExtArgs>>): Prisma__AnnouncementsClient<$Result.GetResult<Prisma.$AnnouncementsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Announcements.
     * @param {AnnouncementsCreateManyArgs} args - Arguments to create many Announcements.
     * @example
     * // Create many Announcements
     * const announcements = await prisma.announcements.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AnnouncementsCreateManyArgs>(args?: SelectSubset<T, AnnouncementsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Announcements and returns the data saved in the database.
     * @param {AnnouncementsCreateManyAndReturnArgs} args - Arguments to create many Announcements.
     * @example
     * // Create many Announcements
     * const announcements = await prisma.announcements.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Announcements and only return the `id`
     * const announcementsWithIdOnly = await prisma.announcements.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AnnouncementsCreateManyAndReturnArgs>(args?: SelectSubset<T, AnnouncementsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnnouncementsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Announcements.
     * @param {AnnouncementsDeleteArgs} args - Arguments to delete one Announcements.
     * @example
     * // Delete one Announcements
     * const Announcements = await prisma.announcements.delete({
     *   where: {
     *     // ... filter to delete one Announcements
     *   }
     * })
     * 
     */
    delete<T extends AnnouncementsDeleteArgs>(args: SelectSubset<T, AnnouncementsDeleteArgs<ExtArgs>>): Prisma__AnnouncementsClient<$Result.GetResult<Prisma.$AnnouncementsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Announcements.
     * @param {AnnouncementsUpdateArgs} args - Arguments to update one Announcements.
     * @example
     * // Update one Announcements
     * const announcements = await prisma.announcements.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AnnouncementsUpdateArgs>(args: SelectSubset<T, AnnouncementsUpdateArgs<ExtArgs>>): Prisma__AnnouncementsClient<$Result.GetResult<Prisma.$AnnouncementsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Announcements.
     * @param {AnnouncementsDeleteManyArgs} args - Arguments to filter Announcements to delete.
     * @example
     * // Delete a few Announcements
     * const { count } = await prisma.announcements.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AnnouncementsDeleteManyArgs>(args?: SelectSubset<T, AnnouncementsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Announcements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Announcements
     * const announcements = await prisma.announcements.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AnnouncementsUpdateManyArgs>(args: SelectSubset<T, AnnouncementsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Announcements and returns the data updated in the database.
     * @param {AnnouncementsUpdateManyAndReturnArgs} args - Arguments to update many Announcements.
     * @example
     * // Update many Announcements
     * const announcements = await prisma.announcements.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Announcements and only return the `id`
     * const announcementsWithIdOnly = await prisma.announcements.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AnnouncementsUpdateManyAndReturnArgs>(args: SelectSubset<T, AnnouncementsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnnouncementsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Announcements.
     * @param {AnnouncementsUpsertArgs} args - Arguments to update or create a Announcements.
     * @example
     * // Update or create a Announcements
     * const announcements = await prisma.announcements.upsert({
     *   create: {
     *     // ... data to create a Announcements
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Announcements we want to update
     *   }
     * })
     */
    upsert<T extends AnnouncementsUpsertArgs>(args: SelectSubset<T, AnnouncementsUpsertArgs<ExtArgs>>): Prisma__AnnouncementsClient<$Result.GetResult<Prisma.$AnnouncementsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Announcements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementsCountArgs} args - Arguments to filter Announcements to count.
     * @example
     * // Count the number of Announcements
     * const count = await prisma.announcements.count({
     *   where: {
     *     // ... the filter for the Announcements we want to count
     *   }
     * })
    **/
    count<T extends AnnouncementsCountArgs>(
      args?: Subset<T, AnnouncementsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnnouncementsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Announcements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AnnouncementsAggregateArgs>(args: Subset<T, AnnouncementsAggregateArgs>): Prisma.PrismaPromise<GetAnnouncementsAggregateType<T>>

    /**
     * Group by Announcements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AnnouncementsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AnnouncementsGroupByArgs['orderBy'] }
        : { orderBy?: AnnouncementsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AnnouncementsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAnnouncementsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Announcements model
   */
  readonly fields: AnnouncementsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Announcements.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AnnouncementsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends EmployeesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeesDefaultArgs<ExtArgs>>): Prisma__EmployeesClient<$Result.GetResult<Prisma.$EmployeesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Announcements model
   */
  interface AnnouncementsFieldRefs {
    readonly id: FieldRef<"Announcements", 'String'>
    readonly title: FieldRef<"Announcements", 'String'>
    readonly content: FieldRef<"Announcements", 'String'>
    readonly attachments: FieldRef<"Announcements", 'String[]'>
    readonly publishDate: FieldRef<"Announcements", 'DateTime'>
    readonly expiryDate: FieldRef<"Announcements", 'DateTime'>
    readonly employeeId: FieldRef<"Announcements", 'String'>
    readonly createdAt: FieldRef<"Announcements", 'DateTime'>
    readonly updatedAt: FieldRef<"Announcements", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Announcements findUnique
   */
  export type AnnouncementsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcements
     */
    select?: AnnouncementsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcements
     */
    omit?: AnnouncementsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementsInclude<ExtArgs> | null
    /**
     * Filter, which Announcements to fetch.
     */
    where: AnnouncementsWhereUniqueInput
  }

  /**
   * Announcements findUniqueOrThrow
   */
  export type AnnouncementsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcements
     */
    select?: AnnouncementsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcements
     */
    omit?: AnnouncementsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementsInclude<ExtArgs> | null
    /**
     * Filter, which Announcements to fetch.
     */
    where: AnnouncementsWhereUniqueInput
  }

  /**
   * Announcements findFirst
   */
  export type AnnouncementsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcements
     */
    select?: AnnouncementsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcements
     */
    omit?: AnnouncementsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementsInclude<ExtArgs> | null
    /**
     * Filter, which Announcements to fetch.
     */
    where?: AnnouncementsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Announcements to fetch.
     */
    orderBy?: AnnouncementsOrderByWithRelationInput | AnnouncementsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Announcements.
     */
    cursor?: AnnouncementsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Announcements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Announcements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Announcements.
     */
    distinct?: AnnouncementsScalarFieldEnum | AnnouncementsScalarFieldEnum[]
  }

  /**
   * Announcements findFirstOrThrow
   */
  export type AnnouncementsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcements
     */
    select?: AnnouncementsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcements
     */
    omit?: AnnouncementsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementsInclude<ExtArgs> | null
    /**
     * Filter, which Announcements to fetch.
     */
    where?: AnnouncementsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Announcements to fetch.
     */
    orderBy?: AnnouncementsOrderByWithRelationInput | AnnouncementsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Announcements.
     */
    cursor?: AnnouncementsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Announcements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Announcements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Announcements.
     */
    distinct?: AnnouncementsScalarFieldEnum | AnnouncementsScalarFieldEnum[]
  }

  /**
   * Announcements findMany
   */
  export type AnnouncementsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcements
     */
    select?: AnnouncementsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcements
     */
    omit?: AnnouncementsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementsInclude<ExtArgs> | null
    /**
     * Filter, which Announcements to fetch.
     */
    where?: AnnouncementsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Announcements to fetch.
     */
    orderBy?: AnnouncementsOrderByWithRelationInput | AnnouncementsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Announcements.
     */
    cursor?: AnnouncementsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Announcements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Announcements.
     */
    skip?: number
    distinct?: AnnouncementsScalarFieldEnum | AnnouncementsScalarFieldEnum[]
  }

  /**
   * Announcements create
   */
  export type AnnouncementsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcements
     */
    select?: AnnouncementsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcements
     */
    omit?: AnnouncementsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementsInclude<ExtArgs> | null
    /**
     * The data needed to create a Announcements.
     */
    data: XOR<AnnouncementsCreateInput, AnnouncementsUncheckedCreateInput>
  }

  /**
   * Announcements createMany
   */
  export type AnnouncementsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Announcements.
     */
    data: AnnouncementsCreateManyInput | AnnouncementsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Announcements createManyAndReturn
   */
  export type AnnouncementsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcements
     */
    select?: AnnouncementsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Announcements
     */
    omit?: AnnouncementsOmit<ExtArgs> | null
    /**
     * The data used to create many Announcements.
     */
    data: AnnouncementsCreateManyInput | AnnouncementsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Announcements update
   */
  export type AnnouncementsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcements
     */
    select?: AnnouncementsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcements
     */
    omit?: AnnouncementsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementsInclude<ExtArgs> | null
    /**
     * The data needed to update a Announcements.
     */
    data: XOR<AnnouncementsUpdateInput, AnnouncementsUncheckedUpdateInput>
    /**
     * Choose, which Announcements to update.
     */
    where: AnnouncementsWhereUniqueInput
  }

  /**
   * Announcements updateMany
   */
  export type AnnouncementsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Announcements.
     */
    data: XOR<AnnouncementsUpdateManyMutationInput, AnnouncementsUncheckedUpdateManyInput>
    /**
     * Filter which Announcements to update
     */
    where?: AnnouncementsWhereInput
    /**
     * Limit how many Announcements to update.
     */
    limit?: number
  }

  /**
   * Announcements updateManyAndReturn
   */
  export type AnnouncementsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcements
     */
    select?: AnnouncementsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Announcements
     */
    omit?: AnnouncementsOmit<ExtArgs> | null
    /**
     * The data used to update Announcements.
     */
    data: XOR<AnnouncementsUpdateManyMutationInput, AnnouncementsUncheckedUpdateManyInput>
    /**
     * Filter which Announcements to update
     */
    where?: AnnouncementsWhereInput
    /**
     * Limit how many Announcements to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Announcements upsert
   */
  export type AnnouncementsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcements
     */
    select?: AnnouncementsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcements
     */
    omit?: AnnouncementsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementsInclude<ExtArgs> | null
    /**
     * The filter to search for the Announcements to update in case it exists.
     */
    where: AnnouncementsWhereUniqueInput
    /**
     * In case the Announcements found by the `where` argument doesn't exist, create a new Announcements with this data.
     */
    create: XOR<AnnouncementsCreateInput, AnnouncementsUncheckedCreateInput>
    /**
     * In case the Announcements was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AnnouncementsUpdateInput, AnnouncementsUncheckedUpdateInput>
  }

  /**
   * Announcements delete
   */
  export type AnnouncementsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcements
     */
    select?: AnnouncementsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcements
     */
    omit?: AnnouncementsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementsInclude<ExtArgs> | null
    /**
     * Filter which Announcements to delete.
     */
    where: AnnouncementsWhereUniqueInput
  }

  /**
   * Announcements deleteMany
   */
  export type AnnouncementsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Announcements to delete
     */
    where?: AnnouncementsWhereInput
    /**
     * Limit how many Announcements to delete.
     */
    limit?: number
  }

  /**
   * Announcements without action
   */
  export type AnnouncementsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcements
     */
    select?: AnnouncementsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcements
     */
    omit?: AnnouncementsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementsInclude<ExtArgs> | null
  }


  /**
   * Model ForumPosts
   */

  export type AggregateForumPosts = {
    _count: ForumPostsCountAggregateOutputType | null
    _min: ForumPostsMinAggregateOutputType | null
    _max: ForumPostsMaxAggregateOutputType | null
  }

  export type ForumPostsMinAggregateOutputType = {
    id: string | null
    title: string | null
    content: string | null
    authorRole: $Enums.UserRole | null
    userId: string | null
    publishedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ForumPostsMaxAggregateOutputType = {
    id: string | null
    title: string | null
    content: string | null
    authorRole: $Enums.UserRole | null
    userId: string | null
    publishedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ForumPostsCountAggregateOutputType = {
    id: number
    title: number
    content: number
    attachments: number
    authorRole: number
    userId: number
    publishedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ForumPostsMinAggregateInputType = {
    id?: true
    title?: true
    content?: true
    authorRole?: true
    userId?: true
    publishedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ForumPostsMaxAggregateInputType = {
    id?: true
    title?: true
    content?: true
    authorRole?: true
    userId?: true
    publishedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ForumPostsCountAggregateInputType = {
    id?: true
    title?: true
    content?: true
    attachments?: true
    authorRole?: true
    userId?: true
    publishedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ForumPostsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ForumPosts to aggregate.
     */
    where?: ForumPostsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ForumPosts to fetch.
     */
    orderBy?: ForumPostsOrderByWithRelationInput | ForumPostsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ForumPostsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ForumPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ForumPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ForumPosts
    **/
    _count?: true | ForumPostsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ForumPostsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ForumPostsMaxAggregateInputType
  }

  export type GetForumPostsAggregateType<T extends ForumPostsAggregateArgs> = {
        [P in keyof T & keyof AggregateForumPosts]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateForumPosts[P]>
      : GetScalarType<T[P], AggregateForumPosts[P]>
  }




  export type ForumPostsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ForumPostsWhereInput
    orderBy?: ForumPostsOrderByWithAggregationInput | ForumPostsOrderByWithAggregationInput[]
    by: ForumPostsScalarFieldEnum[] | ForumPostsScalarFieldEnum
    having?: ForumPostsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ForumPostsCountAggregateInputType | true
    _min?: ForumPostsMinAggregateInputType
    _max?: ForumPostsMaxAggregateInputType
  }

  export type ForumPostsGroupByOutputType = {
    id: string
    title: string
    content: string
    attachments: string[]
    authorRole: $Enums.UserRole
    userId: string
    publishedAt: Date
    createdAt: Date
    updatedAt: Date
    _count: ForumPostsCountAggregateOutputType | null
    _min: ForumPostsMinAggregateOutputType | null
    _max: ForumPostsMaxAggregateOutputType | null
  }

  type GetForumPostsGroupByPayload<T extends ForumPostsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ForumPostsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ForumPostsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ForumPostsGroupByOutputType[P]>
            : GetScalarType<T[P], ForumPostsGroupByOutputType[P]>
        }
      >
    >


  export type ForumPostsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    attachments?: boolean
    authorRole?: boolean
    userId?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UsersDefaultArgs<ExtArgs>
    tags?: boolean | ForumPosts$tagsArgs<ExtArgs>
    comments?: boolean | ForumPosts$commentsArgs<ExtArgs>
    _count?: boolean | ForumPostsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["forumPosts"]>

  export type ForumPostsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    attachments?: boolean
    authorRole?: boolean
    userId?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["forumPosts"]>

  export type ForumPostsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    attachments?: boolean
    authorRole?: boolean
    userId?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["forumPosts"]>

  export type ForumPostsSelectScalar = {
    id?: boolean
    title?: boolean
    content?: boolean
    attachments?: boolean
    authorRole?: boolean
    userId?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ForumPostsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "content" | "attachments" | "authorRole" | "userId" | "publishedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["forumPosts"]>
  export type ForumPostsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UsersDefaultArgs<ExtArgs>
    tags?: boolean | ForumPosts$tagsArgs<ExtArgs>
    comments?: boolean | ForumPosts$commentsArgs<ExtArgs>
    _count?: boolean | ForumPostsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ForumPostsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UsersDefaultArgs<ExtArgs>
  }
  export type ForumPostsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UsersDefaultArgs<ExtArgs>
  }

  export type $ForumPostsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ForumPosts"
    objects: {
      user: Prisma.$UsersPayload<ExtArgs>
      tags: Prisma.$PostTagsPayload<ExtArgs>[]
      comments: Prisma.$ForumCommentsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      content: string
      attachments: string[]
      authorRole: $Enums.UserRole
      userId: string
      publishedAt: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["forumPosts"]>
    composites: {}
  }

  type ForumPostsGetPayload<S extends boolean | null | undefined | ForumPostsDefaultArgs> = $Result.GetResult<Prisma.$ForumPostsPayload, S>

  type ForumPostsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ForumPostsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ForumPostsCountAggregateInputType | true
    }

  export interface ForumPostsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ForumPosts'], meta: { name: 'ForumPosts' } }
    /**
     * Find zero or one ForumPosts that matches the filter.
     * @param {ForumPostsFindUniqueArgs} args - Arguments to find a ForumPosts
     * @example
     * // Get one ForumPosts
     * const forumPosts = await prisma.forumPosts.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ForumPostsFindUniqueArgs>(args: SelectSubset<T, ForumPostsFindUniqueArgs<ExtArgs>>): Prisma__ForumPostsClient<$Result.GetResult<Prisma.$ForumPostsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ForumPosts that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ForumPostsFindUniqueOrThrowArgs} args - Arguments to find a ForumPosts
     * @example
     * // Get one ForumPosts
     * const forumPosts = await prisma.forumPosts.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ForumPostsFindUniqueOrThrowArgs>(args: SelectSubset<T, ForumPostsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ForumPostsClient<$Result.GetResult<Prisma.$ForumPostsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ForumPosts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumPostsFindFirstArgs} args - Arguments to find a ForumPosts
     * @example
     * // Get one ForumPosts
     * const forumPosts = await prisma.forumPosts.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ForumPostsFindFirstArgs>(args?: SelectSubset<T, ForumPostsFindFirstArgs<ExtArgs>>): Prisma__ForumPostsClient<$Result.GetResult<Prisma.$ForumPostsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ForumPosts that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumPostsFindFirstOrThrowArgs} args - Arguments to find a ForumPosts
     * @example
     * // Get one ForumPosts
     * const forumPosts = await prisma.forumPosts.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ForumPostsFindFirstOrThrowArgs>(args?: SelectSubset<T, ForumPostsFindFirstOrThrowArgs<ExtArgs>>): Prisma__ForumPostsClient<$Result.GetResult<Prisma.$ForumPostsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ForumPosts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumPostsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ForumPosts
     * const forumPosts = await prisma.forumPosts.findMany()
     * 
     * // Get first 10 ForumPosts
     * const forumPosts = await prisma.forumPosts.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const forumPostsWithIdOnly = await prisma.forumPosts.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ForumPostsFindManyArgs>(args?: SelectSubset<T, ForumPostsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ForumPostsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ForumPosts.
     * @param {ForumPostsCreateArgs} args - Arguments to create a ForumPosts.
     * @example
     * // Create one ForumPosts
     * const ForumPosts = await prisma.forumPosts.create({
     *   data: {
     *     // ... data to create a ForumPosts
     *   }
     * })
     * 
     */
    create<T extends ForumPostsCreateArgs>(args: SelectSubset<T, ForumPostsCreateArgs<ExtArgs>>): Prisma__ForumPostsClient<$Result.GetResult<Prisma.$ForumPostsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ForumPosts.
     * @param {ForumPostsCreateManyArgs} args - Arguments to create many ForumPosts.
     * @example
     * // Create many ForumPosts
     * const forumPosts = await prisma.forumPosts.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ForumPostsCreateManyArgs>(args?: SelectSubset<T, ForumPostsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ForumPosts and returns the data saved in the database.
     * @param {ForumPostsCreateManyAndReturnArgs} args - Arguments to create many ForumPosts.
     * @example
     * // Create many ForumPosts
     * const forumPosts = await prisma.forumPosts.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ForumPosts and only return the `id`
     * const forumPostsWithIdOnly = await prisma.forumPosts.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ForumPostsCreateManyAndReturnArgs>(args?: SelectSubset<T, ForumPostsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ForumPostsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ForumPosts.
     * @param {ForumPostsDeleteArgs} args - Arguments to delete one ForumPosts.
     * @example
     * // Delete one ForumPosts
     * const ForumPosts = await prisma.forumPosts.delete({
     *   where: {
     *     // ... filter to delete one ForumPosts
     *   }
     * })
     * 
     */
    delete<T extends ForumPostsDeleteArgs>(args: SelectSubset<T, ForumPostsDeleteArgs<ExtArgs>>): Prisma__ForumPostsClient<$Result.GetResult<Prisma.$ForumPostsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ForumPosts.
     * @param {ForumPostsUpdateArgs} args - Arguments to update one ForumPosts.
     * @example
     * // Update one ForumPosts
     * const forumPosts = await prisma.forumPosts.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ForumPostsUpdateArgs>(args: SelectSubset<T, ForumPostsUpdateArgs<ExtArgs>>): Prisma__ForumPostsClient<$Result.GetResult<Prisma.$ForumPostsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ForumPosts.
     * @param {ForumPostsDeleteManyArgs} args - Arguments to filter ForumPosts to delete.
     * @example
     * // Delete a few ForumPosts
     * const { count } = await prisma.forumPosts.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ForumPostsDeleteManyArgs>(args?: SelectSubset<T, ForumPostsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ForumPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumPostsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ForumPosts
     * const forumPosts = await prisma.forumPosts.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ForumPostsUpdateManyArgs>(args: SelectSubset<T, ForumPostsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ForumPosts and returns the data updated in the database.
     * @param {ForumPostsUpdateManyAndReturnArgs} args - Arguments to update many ForumPosts.
     * @example
     * // Update many ForumPosts
     * const forumPosts = await prisma.forumPosts.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ForumPosts and only return the `id`
     * const forumPostsWithIdOnly = await prisma.forumPosts.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ForumPostsUpdateManyAndReturnArgs>(args: SelectSubset<T, ForumPostsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ForumPostsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ForumPosts.
     * @param {ForumPostsUpsertArgs} args - Arguments to update or create a ForumPosts.
     * @example
     * // Update or create a ForumPosts
     * const forumPosts = await prisma.forumPosts.upsert({
     *   create: {
     *     // ... data to create a ForumPosts
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ForumPosts we want to update
     *   }
     * })
     */
    upsert<T extends ForumPostsUpsertArgs>(args: SelectSubset<T, ForumPostsUpsertArgs<ExtArgs>>): Prisma__ForumPostsClient<$Result.GetResult<Prisma.$ForumPostsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ForumPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumPostsCountArgs} args - Arguments to filter ForumPosts to count.
     * @example
     * // Count the number of ForumPosts
     * const count = await prisma.forumPosts.count({
     *   where: {
     *     // ... the filter for the ForumPosts we want to count
     *   }
     * })
    **/
    count<T extends ForumPostsCountArgs>(
      args?: Subset<T, ForumPostsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ForumPostsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ForumPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumPostsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ForumPostsAggregateArgs>(args: Subset<T, ForumPostsAggregateArgs>): Prisma.PrismaPromise<GetForumPostsAggregateType<T>>

    /**
     * Group by ForumPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumPostsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ForumPostsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ForumPostsGroupByArgs['orderBy'] }
        : { orderBy?: ForumPostsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ForumPostsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetForumPostsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ForumPosts model
   */
  readonly fields: ForumPostsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ForumPosts.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ForumPostsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tags<T extends ForumPosts$tagsArgs<ExtArgs> = {}>(args?: Subset<T, ForumPosts$tagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostTagsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    comments<T extends ForumPosts$commentsArgs<ExtArgs> = {}>(args?: Subset<T, ForumPosts$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ForumCommentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ForumPosts model
   */
  interface ForumPostsFieldRefs {
    readonly id: FieldRef<"ForumPosts", 'String'>
    readonly title: FieldRef<"ForumPosts", 'String'>
    readonly content: FieldRef<"ForumPosts", 'String'>
    readonly attachments: FieldRef<"ForumPosts", 'String[]'>
    readonly authorRole: FieldRef<"ForumPosts", 'UserRole'>
    readonly userId: FieldRef<"ForumPosts", 'String'>
    readonly publishedAt: FieldRef<"ForumPosts", 'DateTime'>
    readonly createdAt: FieldRef<"ForumPosts", 'DateTime'>
    readonly updatedAt: FieldRef<"ForumPosts", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ForumPosts findUnique
   */
  export type ForumPostsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumPosts
     */
    select?: ForumPostsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ForumPosts
     */
    omit?: ForumPostsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumPostsInclude<ExtArgs> | null
    /**
     * Filter, which ForumPosts to fetch.
     */
    where: ForumPostsWhereUniqueInput
  }

  /**
   * ForumPosts findUniqueOrThrow
   */
  export type ForumPostsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumPosts
     */
    select?: ForumPostsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ForumPosts
     */
    omit?: ForumPostsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumPostsInclude<ExtArgs> | null
    /**
     * Filter, which ForumPosts to fetch.
     */
    where: ForumPostsWhereUniqueInput
  }

  /**
   * ForumPosts findFirst
   */
  export type ForumPostsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumPosts
     */
    select?: ForumPostsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ForumPosts
     */
    omit?: ForumPostsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumPostsInclude<ExtArgs> | null
    /**
     * Filter, which ForumPosts to fetch.
     */
    where?: ForumPostsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ForumPosts to fetch.
     */
    orderBy?: ForumPostsOrderByWithRelationInput | ForumPostsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ForumPosts.
     */
    cursor?: ForumPostsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ForumPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ForumPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ForumPosts.
     */
    distinct?: ForumPostsScalarFieldEnum | ForumPostsScalarFieldEnum[]
  }

  /**
   * ForumPosts findFirstOrThrow
   */
  export type ForumPostsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumPosts
     */
    select?: ForumPostsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ForumPosts
     */
    omit?: ForumPostsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumPostsInclude<ExtArgs> | null
    /**
     * Filter, which ForumPosts to fetch.
     */
    where?: ForumPostsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ForumPosts to fetch.
     */
    orderBy?: ForumPostsOrderByWithRelationInput | ForumPostsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ForumPosts.
     */
    cursor?: ForumPostsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ForumPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ForumPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ForumPosts.
     */
    distinct?: ForumPostsScalarFieldEnum | ForumPostsScalarFieldEnum[]
  }

  /**
   * ForumPosts findMany
   */
  export type ForumPostsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumPosts
     */
    select?: ForumPostsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ForumPosts
     */
    omit?: ForumPostsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumPostsInclude<ExtArgs> | null
    /**
     * Filter, which ForumPosts to fetch.
     */
    where?: ForumPostsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ForumPosts to fetch.
     */
    orderBy?: ForumPostsOrderByWithRelationInput | ForumPostsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ForumPosts.
     */
    cursor?: ForumPostsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ForumPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ForumPosts.
     */
    skip?: number
    distinct?: ForumPostsScalarFieldEnum | ForumPostsScalarFieldEnum[]
  }

  /**
   * ForumPosts create
   */
  export type ForumPostsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumPosts
     */
    select?: ForumPostsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ForumPosts
     */
    omit?: ForumPostsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumPostsInclude<ExtArgs> | null
    /**
     * The data needed to create a ForumPosts.
     */
    data: XOR<ForumPostsCreateInput, ForumPostsUncheckedCreateInput>
  }

  /**
   * ForumPosts createMany
   */
  export type ForumPostsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ForumPosts.
     */
    data: ForumPostsCreateManyInput | ForumPostsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ForumPosts createManyAndReturn
   */
  export type ForumPostsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumPosts
     */
    select?: ForumPostsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ForumPosts
     */
    omit?: ForumPostsOmit<ExtArgs> | null
    /**
     * The data used to create many ForumPosts.
     */
    data: ForumPostsCreateManyInput | ForumPostsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumPostsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ForumPosts update
   */
  export type ForumPostsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumPosts
     */
    select?: ForumPostsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ForumPosts
     */
    omit?: ForumPostsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumPostsInclude<ExtArgs> | null
    /**
     * The data needed to update a ForumPosts.
     */
    data: XOR<ForumPostsUpdateInput, ForumPostsUncheckedUpdateInput>
    /**
     * Choose, which ForumPosts to update.
     */
    where: ForumPostsWhereUniqueInput
  }

  /**
   * ForumPosts updateMany
   */
  export type ForumPostsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ForumPosts.
     */
    data: XOR<ForumPostsUpdateManyMutationInput, ForumPostsUncheckedUpdateManyInput>
    /**
     * Filter which ForumPosts to update
     */
    where?: ForumPostsWhereInput
    /**
     * Limit how many ForumPosts to update.
     */
    limit?: number
  }

  /**
   * ForumPosts updateManyAndReturn
   */
  export type ForumPostsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumPosts
     */
    select?: ForumPostsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ForumPosts
     */
    omit?: ForumPostsOmit<ExtArgs> | null
    /**
     * The data used to update ForumPosts.
     */
    data: XOR<ForumPostsUpdateManyMutationInput, ForumPostsUncheckedUpdateManyInput>
    /**
     * Filter which ForumPosts to update
     */
    where?: ForumPostsWhereInput
    /**
     * Limit how many ForumPosts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumPostsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ForumPosts upsert
   */
  export type ForumPostsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumPosts
     */
    select?: ForumPostsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ForumPosts
     */
    omit?: ForumPostsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumPostsInclude<ExtArgs> | null
    /**
     * The filter to search for the ForumPosts to update in case it exists.
     */
    where: ForumPostsWhereUniqueInput
    /**
     * In case the ForumPosts found by the `where` argument doesn't exist, create a new ForumPosts with this data.
     */
    create: XOR<ForumPostsCreateInput, ForumPostsUncheckedCreateInput>
    /**
     * In case the ForumPosts was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ForumPostsUpdateInput, ForumPostsUncheckedUpdateInput>
  }

  /**
   * ForumPosts delete
   */
  export type ForumPostsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumPosts
     */
    select?: ForumPostsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ForumPosts
     */
    omit?: ForumPostsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumPostsInclude<ExtArgs> | null
    /**
     * Filter which ForumPosts to delete.
     */
    where: ForumPostsWhereUniqueInput
  }

  /**
   * ForumPosts deleteMany
   */
  export type ForumPostsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ForumPosts to delete
     */
    where?: ForumPostsWhereInput
    /**
     * Limit how many ForumPosts to delete.
     */
    limit?: number
  }

  /**
   * ForumPosts.tags
   */
  export type ForumPosts$tagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostTags
     */
    select?: PostTagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostTags
     */
    omit?: PostTagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostTagsInclude<ExtArgs> | null
    where?: PostTagsWhereInput
    orderBy?: PostTagsOrderByWithRelationInput | PostTagsOrderByWithRelationInput[]
    cursor?: PostTagsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostTagsScalarFieldEnum | PostTagsScalarFieldEnum[]
  }

  /**
   * ForumPosts.comments
   */
  export type ForumPosts$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumComments
     */
    select?: ForumCommentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ForumComments
     */
    omit?: ForumCommentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumCommentsInclude<ExtArgs> | null
    where?: ForumCommentsWhereInput
    orderBy?: ForumCommentsOrderByWithRelationInput | ForumCommentsOrderByWithRelationInput[]
    cursor?: ForumCommentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ForumCommentsScalarFieldEnum | ForumCommentsScalarFieldEnum[]
  }

  /**
   * ForumPosts without action
   */
  export type ForumPostsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumPosts
     */
    select?: ForumPostsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ForumPosts
     */
    omit?: ForumPostsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumPostsInclude<ExtArgs> | null
  }


  /**
   * Model PostTags
   */

  export type AggregatePostTags = {
    _count: PostTagsCountAggregateOutputType | null
    _min: PostTagsMinAggregateOutputType | null
    _max: PostTagsMaxAggregateOutputType | null
  }

  export type PostTagsMinAggregateOutputType = {
    id: string | null
    tagName: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PostTagsMaxAggregateOutputType = {
    id: string | null
    tagName: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PostTagsCountAggregateOutputType = {
    id: number
    tagName: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PostTagsMinAggregateInputType = {
    id?: true
    tagName?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PostTagsMaxAggregateInputType = {
    id?: true
    tagName?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PostTagsCountAggregateInputType = {
    id?: true
    tagName?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PostTagsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PostTags to aggregate.
     */
    where?: PostTagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostTags to fetch.
     */
    orderBy?: PostTagsOrderByWithRelationInput | PostTagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PostTagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PostTags
    **/
    _count?: true | PostTagsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PostTagsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PostTagsMaxAggregateInputType
  }

  export type GetPostTagsAggregateType<T extends PostTagsAggregateArgs> = {
        [P in keyof T & keyof AggregatePostTags]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePostTags[P]>
      : GetScalarType<T[P], AggregatePostTags[P]>
  }




  export type PostTagsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostTagsWhereInput
    orderBy?: PostTagsOrderByWithAggregationInput | PostTagsOrderByWithAggregationInput[]
    by: PostTagsScalarFieldEnum[] | PostTagsScalarFieldEnum
    having?: PostTagsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PostTagsCountAggregateInputType | true
    _min?: PostTagsMinAggregateInputType
    _max?: PostTagsMaxAggregateInputType
  }

  export type PostTagsGroupByOutputType = {
    id: string
    tagName: string
    createdAt: Date
    updatedAt: Date
    _count: PostTagsCountAggregateOutputType | null
    _min: PostTagsMinAggregateOutputType | null
    _max: PostTagsMaxAggregateOutputType | null
  }

  type GetPostTagsGroupByPayload<T extends PostTagsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PostTagsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PostTagsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PostTagsGroupByOutputType[P]>
            : GetScalarType<T[P], PostTagsGroupByOutputType[P]>
        }
      >
    >


  export type PostTagsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tagName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    posts?: boolean | PostTags$postsArgs<ExtArgs>
    _count?: boolean | PostTagsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["postTags"]>

  export type PostTagsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tagName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["postTags"]>

  export type PostTagsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tagName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["postTags"]>

  export type PostTagsSelectScalar = {
    id?: boolean
    tagName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PostTagsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tagName" | "createdAt" | "updatedAt", ExtArgs["result"]["postTags"]>
  export type PostTagsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    posts?: boolean | PostTags$postsArgs<ExtArgs>
    _count?: boolean | PostTagsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PostTagsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type PostTagsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PostTagsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PostTags"
    objects: {
      posts: Prisma.$ForumPostsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tagName: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["postTags"]>
    composites: {}
  }

  type PostTagsGetPayload<S extends boolean | null | undefined | PostTagsDefaultArgs> = $Result.GetResult<Prisma.$PostTagsPayload, S>

  type PostTagsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PostTagsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PostTagsCountAggregateInputType | true
    }

  export interface PostTagsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PostTags'], meta: { name: 'PostTags' } }
    /**
     * Find zero or one PostTags that matches the filter.
     * @param {PostTagsFindUniqueArgs} args - Arguments to find a PostTags
     * @example
     * // Get one PostTags
     * const postTags = await prisma.postTags.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PostTagsFindUniqueArgs>(args: SelectSubset<T, PostTagsFindUniqueArgs<ExtArgs>>): Prisma__PostTagsClient<$Result.GetResult<Prisma.$PostTagsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PostTags that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PostTagsFindUniqueOrThrowArgs} args - Arguments to find a PostTags
     * @example
     * // Get one PostTags
     * const postTags = await prisma.postTags.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PostTagsFindUniqueOrThrowArgs>(args: SelectSubset<T, PostTagsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PostTagsClient<$Result.GetResult<Prisma.$PostTagsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PostTags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostTagsFindFirstArgs} args - Arguments to find a PostTags
     * @example
     * // Get one PostTags
     * const postTags = await prisma.postTags.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PostTagsFindFirstArgs>(args?: SelectSubset<T, PostTagsFindFirstArgs<ExtArgs>>): Prisma__PostTagsClient<$Result.GetResult<Prisma.$PostTagsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PostTags that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostTagsFindFirstOrThrowArgs} args - Arguments to find a PostTags
     * @example
     * // Get one PostTags
     * const postTags = await prisma.postTags.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PostTagsFindFirstOrThrowArgs>(args?: SelectSubset<T, PostTagsFindFirstOrThrowArgs<ExtArgs>>): Prisma__PostTagsClient<$Result.GetResult<Prisma.$PostTagsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PostTags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostTagsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PostTags
     * const postTags = await prisma.postTags.findMany()
     * 
     * // Get first 10 PostTags
     * const postTags = await prisma.postTags.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const postTagsWithIdOnly = await prisma.postTags.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PostTagsFindManyArgs>(args?: SelectSubset<T, PostTagsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostTagsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PostTags.
     * @param {PostTagsCreateArgs} args - Arguments to create a PostTags.
     * @example
     * // Create one PostTags
     * const PostTags = await prisma.postTags.create({
     *   data: {
     *     // ... data to create a PostTags
     *   }
     * })
     * 
     */
    create<T extends PostTagsCreateArgs>(args: SelectSubset<T, PostTagsCreateArgs<ExtArgs>>): Prisma__PostTagsClient<$Result.GetResult<Prisma.$PostTagsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PostTags.
     * @param {PostTagsCreateManyArgs} args - Arguments to create many PostTags.
     * @example
     * // Create many PostTags
     * const postTags = await prisma.postTags.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PostTagsCreateManyArgs>(args?: SelectSubset<T, PostTagsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PostTags and returns the data saved in the database.
     * @param {PostTagsCreateManyAndReturnArgs} args - Arguments to create many PostTags.
     * @example
     * // Create many PostTags
     * const postTags = await prisma.postTags.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PostTags and only return the `id`
     * const postTagsWithIdOnly = await prisma.postTags.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PostTagsCreateManyAndReturnArgs>(args?: SelectSubset<T, PostTagsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostTagsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PostTags.
     * @param {PostTagsDeleteArgs} args - Arguments to delete one PostTags.
     * @example
     * // Delete one PostTags
     * const PostTags = await prisma.postTags.delete({
     *   where: {
     *     // ... filter to delete one PostTags
     *   }
     * })
     * 
     */
    delete<T extends PostTagsDeleteArgs>(args: SelectSubset<T, PostTagsDeleteArgs<ExtArgs>>): Prisma__PostTagsClient<$Result.GetResult<Prisma.$PostTagsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PostTags.
     * @param {PostTagsUpdateArgs} args - Arguments to update one PostTags.
     * @example
     * // Update one PostTags
     * const postTags = await prisma.postTags.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PostTagsUpdateArgs>(args: SelectSubset<T, PostTagsUpdateArgs<ExtArgs>>): Prisma__PostTagsClient<$Result.GetResult<Prisma.$PostTagsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PostTags.
     * @param {PostTagsDeleteManyArgs} args - Arguments to filter PostTags to delete.
     * @example
     * // Delete a few PostTags
     * const { count } = await prisma.postTags.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PostTagsDeleteManyArgs>(args?: SelectSubset<T, PostTagsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PostTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostTagsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PostTags
     * const postTags = await prisma.postTags.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PostTagsUpdateManyArgs>(args: SelectSubset<T, PostTagsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PostTags and returns the data updated in the database.
     * @param {PostTagsUpdateManyAndReturnArgs} args - Arguments to update many PostTags.
     * @example
     * // Update many PostTags
     * const postTags = await prisma.postTags.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PostTags and only return the `id`
     * const postTagsWithIdOnly = await prisma.postTags.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PostTagsUpdateManyAndReturnArgs>(args: SelectSubset<T, PostTagsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostTagsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PostTags.
     * @param {PostTagsUpsertArgs} args - Arguments to update or create a PostTags.
     * @example
     * // Update or create a PostTags
     * const postTags = await prisma.postTags.upsert({
     *   create: {
     *     // ... data to create a PostTags
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PostTags we want to update
     *   }
     * })
     */
    upsert<T extends PostTagsUpsertArgs>(args: SelectSubset<T, PostTagsUpsertArgs<ExtArgs>>): Prisma__PostTagsClient<$Result.GetResult<Prisma.$PostTagsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PostTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostTagsCountArgs} args - Arguments to filter PostTags to count.
     * @example
     * // Count the number of PostTags
     * const count = await prisma.postTags.count({
     *   where: {
     *     // ... the filter for the PostTags we want to count
     *   }
     * })
    **/
    count<T extends PostTagsCountArgs>(
      args?: Subset<T, PostTagsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PostTagsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PostTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostTagsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PostTagsAggregateArgs>(args: Subset<T, PostTagsAggregateArgs>): Prisma.PrismaPromise<GetPostTagsAggregateType<T>>

    /**
     * Group by PostTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostTagsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PostTagsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PostTagsGroupByArgs['orderBy'] }
        : { orderBy?: PostTagsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PostTagsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPostTagsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PostTags model
   */
  readonly fields: PostTagsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PostTags.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PostTagsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    posts<T extends PostTags$postsArgs<ExtArgs> = {}>(args?: Subset<T, PostTags$postsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ForumPostsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PostTags model
   */
  interface PostTagsFieldRefs {
    readonly id: FieldRef<"PostTags", 'String'>
    readonly tagName: FieldRef<"PostTags", 'String'>
    readonly createdAt: FieldRef<"PostTags", 'DateTime'>
    readonly updatedAt: FieldRef<"PostTags", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PostTags findUnique
   */
  export type PostTagsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostTags
     */
    select?: PostTagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostTags
     */
    omit?: PostTagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostTagsInclude<ExtArgs> | null
    /**
     * Filter, which PostTags to fetch.
     */
    where: PostTagsWhereUniqueInput
  }

  /**
   * PostTags findUniqueOrThrow
   */
  export type PostTagsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostTags
     */
    select?: PostTagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostTags
     */
    omit?: PostTagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostTagsInclude<ExtArgs> | null
    /**
     * Filter, which PostTags to fetch.
     */
    where: PostTagsWhereUniqueInput
  }

  /**
   * PostTags findFirst
   */
  export type PostTagsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostTags
     */
    select?: PostTagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostTags
     */
    omit?: PostTagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostTagsInclude<ExtArgs> | null
    /**
     * Filter, which PostTags to fetch.
     */
    where?: PostTagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostTags to fetch.
     */
    orderBy?: PostTagsOrderByWithRelationInput | PostTagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PostTags.
     */
    cursor?: PostTagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PostTags.
     */
    distinct?: PostTagsScalarFieldEnum | PostTagsScalarFieldEnum[]
  }

  /**
   * PostTags findFirstOrThrow
   */
  export type PostTagsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostTags
     */
    select?: PostTagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostTags
     */
    omit?: PostTagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostTagsInclude<ExtArgs> | null
    /**
     * Filter, which PostTags to fetch.
     */
    where?: PostTagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostTags to fetch.
     */
    orderBy?: PostTagsOrderByWithRelationInput | PostTagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PostTags.
     */
    cursor?: PostTagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PostTags.
     */
    distinct?: PostTagsScalarFieldEnum | PostTagsScalarFieldEnum[]
  }

  /**
   * PostTags findMany
   */
  export type PostTagsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostTags
     */
    select?: PostTagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostTags
     */
    omit?: PostTagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostTagsInclude<ExtArgs> | null
    /**
     * Filter, which PostTags to fetch.
     */
    where?: PostTagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostTags to fetch.
     */
    orderBy?: PostTagsOrderByWithRelationInput | PostTagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PostTags.
     */
    cursor?: PostTagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostTags.
     */
    skip?: number
    distinct?: PostTagsScalarFieldEnum | PostTagsScalarFieldEnum[]
  }

  /**
   * PostTags create
   */
  export type PostTagsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostTags
     */
    select?: PostTagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostTags
     */
    omit?: PostTagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostTagsInclude<ExtArgs> | null
    /**
     * The data needed to create a PostTags.
     */
    data: XOR<PostTagsCreateInput, PostTagsUncheckedCreateInput>
  }

  /**
   * PostTags createMany
   */
  export type PostTagsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PostTags.
     */
    data: PostTagsCreateManyInput | PostTagsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PostTags createManyAndReturn
   */
  export type PostTagsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostTags
     */
    select?: PostTagsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PostTags
     */
    omit?: PostTagsOmit<ExtArgs> | null
    /**
     * The data used to create many PostTags.
     */
    data: PostTagsCreateManyInput | PostTagsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PostTags update
   */
  export type PostTagsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostTags
     */
    select?: PostTagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostTags
     */
    omit?: PostTagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostTagsInclude<ExtArgs> | null
    /**
     * The data needed to update a PostTags.
     */
    data: XOR<PostTagsUpdateInput, PostTagsUncheckedUpdateInput>
    /**
     * Choose, which PostTags to update.
     */
    where: PostTagsWhereUniqueInput
  }

  /**
   * PostTags updateMany
   */
  export type PostTagsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PostTags.
     */
    data: XOR<PostTagsUpdateManyMutationInput, PostTagsUncheckedUpdateManyInput>
    /**
     * Filter which PostTags to update
     */
    where?: PostTagsWhereInput
    /**
     * Limit how many PostTags to update.
     */
    limit?: number
  }

  /**
   * PostTags updateManyAndReturn
   */
  export type PostTagsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostTags
     */
    select?: PostTagsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PostTags
     */
    omit?: PostTagsOmit<ExtArgs> | null
    /**
     * The data used to update PostTags.
     */
    data: XOR<PostTagsUpdateManyMutationInput, PostTagsUncheckedUpdateManyInput>
    /**
     * Filter which PostTags to update
     */
    where?: PostTagsWhereInput
    /**
     * Limit how many PostTags to update.
     */
    limit?: number
  }

  /**
   * PostTags upsert
   */
  export type PostTagsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostTags
     */
    select?: PostTagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostTags
     */
    omit?: PostTagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostTagsInclude<ExtArgs> | null
    /**
     * The filter to search for the PostTags to update in case it exists.
     */
    where: PostTagsWhereUniqueInput
    /**
     * In case the PostTags found by the `where` argument doesn't exist, create a new PostTags with this data.
     */
    create: XOR<PostTagsCreateInput, PostTagsUncheckedCreateInput>
    /**
     * In case the PostTags was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PostTagsUpdateInput, PostTagsUncheckedUpdateInput>
  }

  /**
   * PostTags delete
   */
  export type PostTagsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostTags
     */
    select?: PostTagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostTags
     */
    omit?: PostTagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostTagsInclude<ExtArgs> | null
    /**
     * Filter which PostTags to delete.
     */
    where: PostTagsWhereUniqueInput
  }

  /**
   * PostTags deleteMany
   */
  export type PostTagsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PostTags to delete
     */
    where?: PostTagsWhereInput
    /**
     * Limit how many PostTags to delete.
     */
    limit?: number
  }

  /**
   * PostTags.posts
   */
  export type PostTags$postsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumPosts
     */
    select?: ForumPostsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ForumPosts
     */
    omit?: ForumPostsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumPostsInclude<ExtArgs> | null
    where?: ForumPostsWhereInput
    orderBy?: ForumPostsOrderByWithRelationInput | ForumPostsOrderByWithRelationInput[]
    cursor?: ForumPostsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ForumPostsScalarFieldEnum | ForumPostsScalarFieldEnum[]
  }

  /**
   * PostTags without action
   */
  export type PostTagsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostTags
     */
    select?: PostTagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostTags
     */
    omit?: PostTagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostTagsInclude<ExtArgs> | null
  }


  /**
   * Model ForumComments
   */

  export type AggregateForumComments = {
    _count: ForumCommentsCountAggregateOutputType | null
    _min: ForumCommentsMinAggregateOutputType | null
    _max: ForumCommentsMaxAggregateOutputType | null
  }

  export type ForumCommentsMinAggregateOutputType = {
    id: string | null
    content: string | null
    userId: string | null
    postId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ForumCommentsMaxAggregateOutputType = {
    id: string | null
    content: string | null
    userId: string | null
    postId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ForumCommentsCountAggregateOutputType = {
    id: number
    content: number
    userId: number
    postId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ForumCommentsMinAggregateInputType = {
    id?: true
    content?: true
    userId?: true
    postId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ForumCommentsMaxAggregateInputType = {
    id?: true
    content?: true
    userId?: true
    postId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ForumCommentsCountAggregateInputType = {
    id?: true
    content?: true
    userId?: true
    postId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ForumCommentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ForumComments to aggregate.
     */
    where?: ForumCommentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ForumComments to fetch.
     */
    orderBy?: ForumCommentsOrderByWithRelationInput | ForumCommentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ForumCommentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ForumComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ForumComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ForumComments
    **/
    _count?: true | ForumCommentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ForumCommentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ForumCommentsMaxAggregateInputType
  }

  export type GetForumCommentsAggregateType<T extends ForumCommentsAggregateArgs> = {
        [P in keyof T & keyof AggregateForumComments]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateForumComments[P]>
      : GetScalarType<T[P], AggregateForumComments[P]>
  }




  export type ForumCommentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ForumCommentsWhereInput
    orderBy?: ForumCommentsOrderByWithAggregationInput | ForumCommentsOrderByWithAggregationInput[]
    by: ForumCommentsScalarFieldEnum[] | ForumCommentsScalarFieldEnum
    having?: ForumCommentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ForumCommentsCountAggregateInputType | true
    _min?: ForumCommentsMinAggregateInputType
    _max?: ForumCommentsMaxAggregateInputType
  }

  export type ForumCommentsGroupByOutputType = {
    id: string
    content: string
    userId: string
    postId: string
    createdAt: Date
    updatedAt: Date
    _count: ForumCommentsCountAggregateOutputType | null
    _min: ForumCommentsMinAggregateOutputType | null
    _max: ForumCommentsMaxAggregateOutputType | null
  }

  type GetForumCommentsGroupByPayload<T extends ForumCommentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ForumCommentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ForumCommentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ForumCommentsGroupByOutputType[P]>
            : GetScalarType<T[P], ForumCommentsGroupByOutputType[P]>
        }
      >
    >


  export type ForumCommentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    userId?: boolean
    postId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UsersDefaultArgs<ExtArgs>
    post?: boolean | ForumPostsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["forumComments"]>

  export type ForumCommentsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    userId?: boolean
    postId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UsersDefaultArgs<ExtArgs>
    post?: boolean | ForumPostsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["forumComments"]>

  export type ForumCommentsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    userId?: boolean
    postId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UsersDefaultArgs<ExtArgs>
    post?: boolean | ForumPostsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["forumComments"]>

  export type ForumCommentsSelectScalar = {
    id?: boolean
    content?: boolean
    userId?: boolean
    postId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ForumCommentsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "content" | "userId" | "postId" | "createdAt" | "updatedAt", ExtArgs["result"]["forumComments"]>
  export type ForumCommentsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UsersDefaultArgs<ExtArgs>
    post?: boolean | ForumPostsDefaultArgs<ExtArgs>
  }
  export type ForumCommentsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UsersDefaultArgs<ExtArgs>
    post?: boolean | ForumPostsDefaultArgs<ExtArgs>
  }
  export type ForumCommentsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UsersDefaultArgs<ExtArgs>
    post?: boolean | ForumPostsDefaultArgs<ExtArgs>
  }

  export type $ForumCommentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ForumComments"
    objects: {
      user: Prisma.$UsersPayload<ExtArgs>
      post: Prisma.$ForumPostsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      content: string
      userId: string
      postId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["forumComments"]>
    composites: {}
  }

  type ForumCommentsGetPayload<S extends boolean | null | undefined | ForumCommentsDefaultArgs> = $Result.GetResult<Prisma.$ForumCommentsPayload, S>

  type ForumCommentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ForumCommentsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ForumCommentsCountAggregateInputType | true
    }

  export interface ForumCommentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ForumComments'], meta: { name: 'ForumComments' } }
    /**
     * Find zero or one ForumComments that matches the filter.
     * @param {ForumCommentsFindUniqueArgs} args - Arguments to find a ForumComments
     * @example
     * // Get one ForumComments
     * const forumComments = await prisma.forumComments.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ForumCommentsFindUniqueArgs>(args: SelectSubset<T, ForumCommentsFindUniqueArgs<ExtArgs>>): Prisma__ForumCommentsClient<$Result.GetResult<Prisma.$ForumCommentsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ForumComments that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ForumCommentsFindUniqueOrThrowArgs} args - Arguments to find a ForumComments
     * @example
     * // Get one ForumComments
     * const forumComments = await prisma.forumComments.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ForumCommentsFindUniqueOrThrowArgs>(args: SelectSubset<T, ForumCommentsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ForumCommentsClient<$Result.GetResult<Prisma.$ForumCommentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ForumComments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumCommentsFindFirstArgs} args - Arguments to find a ForumComments
     * @example
     * // Get one ForumComments
     * const forumComments = await prisma.forumComments.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ForumCommentsFindFirstArgs>(args?: SelectSubset<T, ForumCommentsFindFirstArgs<ExtArgs>>): Prisma__ForumCommentsClient<$Result.GetResult<Prisma.$ForumCommentsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ForumComments that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumCommentsFindFirstOrThrowArgs} args - Arguments to find a ForumComments
     * @example
     * // Get one ForumComments
     * const forumComments = await prisma.forumComments.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ForumCommentsFindFirstOrThrowArgs>(args?: SelectSubset<T, ForumCommentsFindFirstOrThrowArgs<ExtArgs>>): Prisma__ForumCommentsClient<$Result.GetResult<Prisma.$ForumCommentsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ForumComments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumCommentsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ForumComments
     * const forumComments = await prisma.forumComments.findMany()
     * 
     * // Get first 10 ForumComments
     * const forumComments = await prisma.forumComments.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const forumCommentsWithIdOnly = await prisma.forumComments.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ForumCommentsFindManyArgs>(args?: SelectSubset<T, ForumCommentsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ForumCommentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ForumComments.
     * @param {ForumCommentsCreateArgs} args - Arguments to create a ForumComments.
     * @example
     * // Create one ForumComments
     * const ForumComments = await prisma.forumComments.create({
     *   data: {
     *     // ... data to create a ForumComments
     *   }
     * })
     * 
     */
    create<T extends ForumCommentsCreateArgs>(args: SelectSubset<T, ForumCommentsCreateArgs<ExtArgs>>): Prisma__ForumCommentsClient<$Result.GetResult<Prisma.$ForumCommentsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ForumComments.
     * @param {ForumCommentsCreateManyArgs} args - Arguments to create many ForumComments.
     * @example
     * // Create many ForumComments
     * const forumComments = await prisma.forumComments.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ForumCommentsCreateManyArgs>(args?: SelectSubset<T, ForumCommentsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ForumComments and returns the data saved in the database.
     * @param {ForumCommentsCreateManyAndReturnArgs} args - Arguments to create many ForumComments.
     * @example
     * // Create many ForumComments
     * const forumComments = await prisma.forumComments.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ForumComments and only return the `id`
     * const forumCommentsWithIdOnly = await prisma.forumComments.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ForumCommentsCreateManyAndReturnArgs>(args?: SelectSubset<T, ForumCommentsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ForumCommentsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ForumComments.
     * @param {ForumCommentsDeleteArgs} args - Arguments to delete one ForumComments.
     * @example
     * // Delete one ForumComments
     * const ForumComments = await prisma.forumComments.delete({
     *   where: {
     *     // ... filter to delete one ForumComments
     *   }
     * })
     * 
     */
    delete<T extends ForumCommentsDeleteArgs>(args: SelectSubset<T, ForumCommentsDeleteArgs<ExtArgs>>): Prisma__ForumCommentsClient<$Result.GetResult<Prisma.$ForumCommentsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ForumComments.
     * @param {ForumCommentsUpdateArgs} args - Arguments to update one ForumComments.
     * @example
     * // Update one ForumComments
     * const forumComments = await prisma.forumComments.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ForumCommentsUpdateArgs>(args: SelectSubset<T, ForumCommentsUpdateArgs<ExtArgs>>): Prisma__ForumCommentsClient<$Result.GetResult<Prisma.$ForumCommentsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ForumComments.
     * @param {ForumCommentsDeleteManyArgs} args - Arguments to filter ForumComments to delete.
     * @example
     * // Delete a few ForumComments
     * const { count } = await prisma.forumComments.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ForumCommentsDeleteManyArgs>(args?: SelectSubset<T, ForumCommentsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ForumComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumCommentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ForumComments
     * const forumComments = await prisma.forumComments.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ForumCommentsUpdateManyArgs>(args: SelectSubset<T, ForumCommentsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ForumComments and returns the data updated in the database.
     * @param {ForumCommentsUpdateManyAndReturnArgs} args - Arguments to update many ForumComments.
     * @example
     * // Update many ForumComments
     * const forumComments = await prisma.forumComments.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ForumComments and only return the `id`
     * const forumCommentsWithIdOnly = await prisma.forumComments.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ForumCommentsUpdateManyAndReturnArgs>(args: SelectSubset<T, ForumCommentsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ForumCommentsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ForumComments.
     * @param {ForumCommentsUpsertArgs} args - Arguments to update or create a ForumComments.
     * @example
     * // Update or create a ForumComments
     * const forumComments = await prisma.forumComments.upsert({
     *   create: {
     *     // ... data to create a ForumComments
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ForumComments we want to update
     *   }
     * })
     */
    upsert<T extends ForumCommentsUpsertArgs>(args: SelectSubset<T, ForumCommentsUpsertArgs<ExtArgs>>): Prisma__ForumCommentsClient<$Result.GetResult<Prisma.$ForumCommentsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ForumComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumCommentsCountArgs} args - Arguments to filter ForumComments to count.
     * @example
     * // Count the number of ForumComments
     * const count = await prisma.forumComments.count({
     *   where: {
     *     // ... the filter for the ForumComments we want to count
     *   }
     * })
    **/
    count<T extends ForumCommentsCountArgs>(
      args?: Subset<T, ForumCommentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ForumCommentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ForumComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumCommentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ForumCommentsAggregateArgs>(args: Subset<T, ForumCommentsAggregateArgs>): Prisma.PrismaPromise<GetForumCommentsAggregateType<T>>

    /**
     * Group by ForumComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumCommentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ForumCommentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ForumCommentsGroupByArgs['orderBy'] }
        : { orderBy?: ForumCommentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ForumCommentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetForumCommentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ForumComments model
   */
  readonly fields: ForumCommentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ForumComments.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ForumCommentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    post<T extends ForumPostsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ForumPostsDefaultArgs<ExtArgs>>): Prisma__ForumPostsClient<$Result.GetResult<Prisma.$ForumPostsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ForumComments model
   */
  interface ForumCommentsFieldRefs {
    readonly id: FieldRef<"ForumComments", 'String'>
    readonly content: FieldRef<"ForumComments", 'String'>
    readonly userId: FieldRef<"ForumComments", 'String'>
    readonly postId: FieldRef<"ForumComments", 'String'>
    readonly createdAt: FieldRef<"ForumComments", 'DateTime'>
    readonly updatedAt: FieldRef<"ForumComments", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ForumComments findUnique
   */
  export type ForumCommentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumComments
     */
    select?: ForumCommentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ForumComments
     */
    omit?: ForumCommentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumCommentsInclude<ExtArgs> | null
    /**
     * Filter, which ForumComments to fetch.
     */
    where: ForumCommentsWhereUniqueInput
  }

  /**
   * ForumComments findUniqueOrThrow
   */
  export type ForumCommentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumComments
     */
    select?: ForumCommentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ForumComments
     */
    omit?: ForumCommentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumCommentsInclude<ExtArgs> | null
    /**
     * Filter, which ForumComments to fetch.
     */
    where: ForumCommentsWhereUniqueInput
  }

  /**
   * ForumComments findFirst
   */
  export type ForumCommentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumComments
     */
    select?: ForumCommentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ForumComments
     */
    omit?: ForumCommentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumCommentsInclude<ExtArgs> | null
    /**
     * Filter, which ForumComments to fetch.
     */
    where?: ForumCommentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ForumComments to fetch.
     */
    orderBy?: ForumCommentsOrderByWithRelationInput | ForumCommentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ForumComments.
     */
    cursor?: ForumCommentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ForumComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ForumComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ForumComments.
     */
    distinct?: ForumCommentsScalarFieldEnum | ForumCommentsScalarFieldEnum[]
  }

  /**
   * ForumComments findFirstOrThrow
   */
  export type ForumCommentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumComments
     */
    select?: ForumCommentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ForumComments
     */
    omit?: ForumCommentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumCommentsInclude<ExtArgs> | null
    /**
     * Filter, which ForumComments to fetch.
     */
    where?: ForumCommentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ForumComments to fetch.
     */
    orderBy?: ForumCommentsOrderByWithRelationInput | ForumCommentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ForumComments.
     */
    cursor?: ForumCommentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ForumComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ForumComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ForumComments.
     */
    distinct?: ForumCommentsScalarFieldEnum | ForumCommentsScalarFieldEnum[]
  }

  /**
   * ForumComments findMany
   */
  export type ForumCommentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumComments
     */
    select?: ForumCommentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ForumComments
     */
    omit?: ForumCommentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumCommentsInclude<ExtArgs> | null
    /**
     * Filter, which ForumComments to fetch.
     */
    where?: ForumCommentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ForumComments to fetch.
     */
    orderBy?: ForumCommentsOrderByWithRelationInput | ForumCommentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ForumComments.
     */
    cursor?: ForumCommentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ForumComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ForumComments.
     */
    skip?: number
    distinct?: ForumCommentsScalarFieldEnum | ForumCommentsScalarFieldEnum[]
  }

  /**
   * ForumComments create
   */
  export type ForumCommentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumComments
     */
    select?: ForumCommentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ForumComments
     */
    omit?: ForumCommentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumCommentsInclude<ExtArgs> | null
    /**
     * The data needed to create a ForumComments.
     */
    data: XOR<ForumCommentsCreateInput, ForumCommentsUncheckedCreateInput>
  }

  /**
   * ForumComments createMany
   */
  export type ForumCommentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ForumComments.
     */
    data: ForumCommentsCreateManyInput | ForumCommentsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ForumComments createManyAndReturn
   */
  export type ForumCommentsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumComments
     */
    select?: ForumCommentsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ForumComments
     */
    omit?: ForumCommentsOmit<ExtArgs> | null
    /**
     * The data used to create many ForumComments.
     */
    data: ForumCommentsCreateManyInput | ForumCommentsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumCommentsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ForumComments update
   */
  export type ForumCommentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumComments
     */
    select?: ForumCommentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ForumComments
     */
    omit?: ForumCommentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumCommentsInclude<ExtArgs> | null
    /**
     * The data needed to update a ForumComments.
     */
    data: XOR<ForumCommentsUpdateInput, ForumCommentsUncheckedUpdateInput>
    /**
     * Choose, which ForumComments to update.
     */
    where: ForumCommentsWhereUniqueInput
  }

  /**
   * ForumComments updateMany
   */
  export type ForumCommentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ForumComments.
     */
    data: XOR<ForumCommentsUpdateManyMutationInput, ForumCommentsUncheckedUpdateManyInput>
    /**
     * Filter which ForumComments to update
     */
    where?: ForumCommentsWhereInput
    /**
     * Limit how many ForumComments to update.
     */
    limit?: number
  }

  /**
   * ForumComments updateManyAndReturn
   */
  export type ForumCommentsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumComments
     */
    select?: ForumCommentsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ForumComments
     */
    omit?: ForumCommentsOmit<ExtArgs> | null
    /**
     * The data used to update ForumComments.
     */
    data: XOR<ForumCommentsUpdateManyMutationInput, ForumCommentsUncheckedUpdateManyInput>
    /**
     * Filter which ForumComments to update
     */
    where?: ForumCommentsWhereInput
    /**
     * Limit how many ForumComments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumCommentsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ForumComments upsert
   */
  export type ForumCommentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumComments
     */
    select?: ForumCommentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ForumComments
     */
    omit?: ForumCommentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumCommentsInclude<ExtArgs> | null
    /**
     * The filter to search for the ForumComments to update in case it exists.
     */
    where: ForumCommentsWhereUniqueInput
    /**
     * In case the ForumComments found by the `where` argument doesn't exist, create a new ForumComments with this data.
     */
    create: XOR<ForumCommentsCreateInput, ForumCommentsUncheckedCreateInput>
    /**
     * In case the ForumComments was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ForumCommentsUpdateInput, ForumCommentsUncheckedUpdateInput>
  }

  /**
   * ForumComments delete
   */
  export type ForumCommentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumComments
     */
    select?: ForumCommentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ForumComments
     */
    omit?: ForumCommentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumCommentsInclude<ExtArgs> | null
    /**
     * Filter which ForumComments to delete.
     */
    where: ForumCommentsWhereUniqueInput
  }

  /**
   * ForumComments deleteMany
   */
  export type ForumCommentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ForumComments to delete
     */
    where?: ForumCommentsWhereInput
    /**
     * Limit how many ForumComments to delete.
     */
    limit?: number
  }

  /**
   * ForumComments without action
   */
  export type ForumCommentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumComments
     */
    select?: ForumCommentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ForumComments
     */
    omit?: ForumCommentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumCommentsInclude<ExtArgs> | null
  }


  /**
   * Model Units
   */

  export type AggregateUnits = {
    _count: UnitsCountAggregateOutputType | null
    _avg: UnitsAvgAggregateOutputType | null
    _sum: UnitsSumAggregateOutputType | null
    _min: UnitsMinAggregateOutputType | null
    _max: UnitsMaxAggregateOutputType | null
  }

  export type UnitsAvgAggregateOutputType = {
    floorNumber: number | null
    numberOfRooms: number | null
    priceSale: number | null
    squareFootage: number | null
  }

  export type UnitsSumAggregateOutputType = {
    floorNumber: number | null
    numberOfRooms: number | null
    priceSale: number | null
    squareFootage: number | null
  }

  export type UnitsMinAggregateOutputType = {
    id: string | null
    unitNumber: string | null
    buildingName: string | null
    floorNumber: number | null
    numberOfRooms: number | null
    priceSale: number | null
    squareFootage: number | null
    location: string | null
    status: $Enums.UnitStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UnitsMaxAggregateOutputType = {
    id: string | null
    unitNumber: string | null
    buildingName: string | null
    floorNumber: number | null
    numberOfRooms: number | null
    priceSale: number | null
    squareFootage: number | null
    location: string | null
    status: $Enums.UnitStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UnitsCountAggregateOutputType = {
    id: number
    unitNumber: number
    buildingName: number
    floorNumber: number
    numberOfRooms: number
    priceSale: number
    squareFootage: number
    location: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UnitsAvgAggregateInputType = {
    floorNumber?: true
    numberOfRooms?: true
    priceSale?: true
    squareFootage?: true
  }

  export type UnitsSumAggregateInputType = {
    floorNumber?: true
    numberOfRooms?: true
    priceSale?: true
    squareFootage?: true
  }

  export type UnitsMinAggregateInputType = {
    id?: true
    unitNumber?: true
    buildingName?: true
    floorNumber?: true
    numberOfRooms?: true
    priceSale?: true
    squareFootage?: true
    location?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UnitsMaxAggregateInputType = {
    id?: true
    unitNumber?: true
    buildingName?: true
    floorNumber?: true
    numberOfRooms?: true
    priceSale?: true
    squareFootage?: true
    location?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UnitsCountAggregateInputType = {
    id?: true
    unitNumber?: true
    buildingName?: true
    floorNumber?: true
    numberOfRooms?: true
    priceSale?: true
    squareFootage?: true
    location?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UnitsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Units to aggregate.
     */
    where?: UnitsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Units to fetch.
     */
    orderBy?: UnitsOrderByWithRelationInput | UnitsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UnitsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Units from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Units.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Units
    **/
    _count?: true | UnitsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UnitsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UnitsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UnitsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UnitsMaxAggregateInputType
  }

  export type GetUnitsAggregateType<T extends UnitsAggregateArgs> = {
        [P in keyof T & keyof AggregateUnits]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUnits[P]>
      : GetScalarType<T[P], AggregateUnits[P]>
  }




  export type UnitsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnitsWhereInput
    orderBy?: UnitsOrderByWithAggregationInput | UnitsOrderByWithAggregationInput[]
    by: UnitsScalarFieldEnum[] | UnitsScalarFieldEnum
    having?: UnitsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UnitsCountAggregateInputType | true
    _avg?: UnitsAvgAggregateInputType
    _sum?: UnitsSumAggregateInputType
    _min?: UnitsMinAggregateInputType
    _max?: UnitsMaxAggregateInputType
  }

  export type UnitsGroupByOutputType = {
    id: string
    unitNumber: string
    buildingName: string | null
    floorNumber: number | null
    numberOfRooms: number | null
    priceSale: number
    squareFootage: number | null
    location: string
    status: $Enums.UnitStatus
    createdAt: Date
    updatedAt: Date
    _count: UnitsCountAggregateOutputType | null
    _avg: UnitsAvgAggregateOutputType | null
    _sum: UnitsSumAggregateOutputType | null
    _min: UnitsMinAggregateOutputType | null
    _max: UnitsMaxAggregateOutputType | null
  }

  type GetUnitsGroupByPayload<T extends UnitsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UnitsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UnitsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UnitsGroupByOutputType[P]>
            : GetScalarType<T[P], UnitsGroupByOutputType[P]>
        }
      >
    >


  export type UnitsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    unitNumber?: boolean
    buildingName?: boolean
    floorNumber?: boolean
    numberOfRooms?: boolean
    priceSale?: boolean
    squareFootage?: boolean
    location?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Residents?: boolean | Units$ResidentsArgs<ExtArgs>
    Payments?: boolean | Units$PaymentsArgs<ExtArgs>
    Bills?: boolean | Units$BillsArgs<ExtArgs>
    Complaints?: boolean | Units$ComplaintsArgs<ExtArgs>
    _count?: boolean | UnitsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["units"]>

  export type UnitsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    unitNumber?: boolean
    buildingName?: boolean
    floorNumber?: boolean
    numberOfRooms?: boolean
    priceSale?: boolean
    squareFootage?: boolean
    location?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["units"]>

  export type UnitsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    unitNumber?: boolean
    buildingName?: boolean
    floorNumber?: boolean
    numberOfRooms?: boolean
    priceSale?: boolean
    squareFootage?: boolean
    location?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["units"]>

  export type UnitsSelectScalar = {
    id?: boolean
    unitNumber?: boolean
    buildingName?: boolean
    floorNumber?: boolean
    numberOfRooms?: boolean
    priceSale?: boolean
    squareFootage?: boolean
    location?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UnitsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "unitNumber" | "buildingName" | "floorNumber" | "numberOfRooms" | "priceSale" | "squareFootage" | "location" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["units"]>
  export type UnitsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Residents?: boolean | Units$ResidentsArgs<ExtArgs>
    Payments?: boolean | Units$PaymentsArgs<ExtArgs>
    Bills?: boolean | Units$BillsArgs<ExtArgs>
    Complaints?: boolean | Units$ComplaintsArgs<ExtArgs>
    _count?: boolean | UnitsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UnitsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UnitsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UnitsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Units"
    objects: {
      Residents: Prisma.$ResidentsPayload<ExtArgs>[]
      Payments: Prisma.$PaymentsPayload<ExtArgs>[]
      Bills: Prisma.$BillsPayload<ExtArgs>[]
      Complaints: Prisma.$ComplaintsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      unitNumber: string
      buildingName: string | null
      floorNumber: number | null
      numberOfRooms: number | null
      priceSale: number
      squareFootage: number | null
      location: string
      status: $Enums.UnitStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["units"]>
    composites: {}
  }

  type UnitsGetPayload<S extends boolean | null | undefined | UnitsDefaultArgs> = $Result.GetResult<Prisma.$UnitsPayload, S>

  type UnitsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UnitsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UnitsCountAggregateInputType | true
    }

  export interface UnitsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Units'], meta: { name: 'Units' } }
    /**
     * Find zero or one Units that matches the filter.
     * @param {UnitsFindUniqueArgs} args - Arguments to find a Units
     * @example
     * // Get one Units
     * const units = await prisma.units.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UnitsFindUniqueArgs>(args: SelectSubset<T, UnitsFindUniqueArgs<ExtArgs>>): Prisma__UnitsClient<$Result.GetResult<Prisma.$UnitsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Units that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UnitsFindUniqueOrThrowArgs} args - Arguments to find a Units
     * @example
     * // Get one Units
     * const units = await prisma.units.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UnitsFindUniqueOrThrowArgs>(args: SelectSubset<T, UnitsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UnitsClient<$Result.GetResult<Prisma.$UnitsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Units that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitsFindFirstArgs} args - Arguments to find a Units
     * @example
     * // Get one Units
     * const units = await prisma.units.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UnitsFindFirstArgs>(args?: SelectSubset<T, UnitsFindFirstArgs<ExtArgs>>): Prisma__UnitsClient<$Result.GetResult<Prisma.$UnitsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Units that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitsFindFirstOrThrowArgs} args - Arguments to find a Units
     * @example
     * // Get one Units
     * const units = await prisma.units.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UnitsFindFirstOrThrowArgs>(args?: SelectSubset<T, UnitsFindFirstOrThrowArgs<ExtArgs>>): Prisma__UnitsClient<$Result.GetResult<Prisma.$UnitsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Units that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Units
     * const units = await prisma.units.findMany()
     * 
     * // Get first 10 Units
     * const units = await prisma.units.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const unitsWithIdOnly = await prisma.units.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UnitsFindManyArgs>(args?: SelectSubset<T, UnitsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Units.
     * @param {UnitsCreateArgs} args - Arguments to create a Units.
     * @example
     * // Create one Units
     * const Units = await prisma.units.create({
     *   data: {
     *     // ... data to create a Units
     *   }
     * })
     * 
     */
    create<T extends UnitsCreateArgs>(args: SelectSubset<T, UnitsCreateArgs<ExtArgs>>): Prisma__UnitsClient<$Result.GetResult<Prisma.$UnitsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Units.
     * @param {UnitsCreateManyArgs} args - Arguments to create many Units.
     * @example
     * // Create many Units
     * const units = await prisma.units.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UnitsCreateManyArgs>(args?: SelectSubset<T, UnitsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Units and returns the data saved in the database.
     * @param {UnitsCreateManyAndReturnArgs} args - Arguments to create many Units.
     * @example
     * // Create many Units
     * const units = await prisma.units.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Units and only return the `id`
     * const unitsWithIdOnly = await prisma.units.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UnitsCreateManyAndReturnArgs>(args?: SelectSubset<T, UnitsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Units.
     * @param {UnitsDeleteArgs} args - Arguments to delete one Units.
     * @example
     * // Delete one Units
     * const Units = await prisma.units.delete({
     *   where: {
     *     // ... filter to delete one Units
     *   }
     * })
     * 
     */
    delete<T extends UnitsDeleteArgs>(args: SelectSubset<T, UnitsDeleteArgs<ExtArgs>>): Prisma__UnitsClient<$Result.GetResult<Prisma.$UnitsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Units.
     * @param {UnitsUpdateArgs} args - Arguments to update one Units.
     * @example
     * // Update one Units
     * const units = await prisma.units.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UnitsUpdateArgs>(args: SelectSubset<T, UnitsUpdateArgs<ExtArgs>>): Prisma__UnitsClient<$Result.GetResult<Prisma.$UnitsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Units.
     * @param {UnitsDeleteManyArgs} args - Arguments to filter Units to delete.
     * @example
     * // Delete a few Units
     * const { count } = await prisma.units.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UnitsDeleteManyArgs>(args?: SelectSubset<T, UnitsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Units.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Units
     * const units = await prisma.units.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UnitsUpdateManyArgs>(args: SelectSubset<T, UnitsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Units and returns the data updated in the database.
     * @param {UnitsUpdateManyAndReturnArgs} args - Arguments to update many Units.
     * @example
     * // Update many Units
     * const units = await prisma.units.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Units and only return the `id`
     * const unitsWithIdOnly = await prisma.units.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UnitsUpdateManyAndReturnArgs>(args: SelectSubset<T, UnitsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Units.
     * @param {UnitsUpsertArgs} args - Arguments to update or create a Units.
     * @example
     * // Update or create a Units
     * const units = await prisma.units.upsert({
     *   create: {
     *     // ... data to create a Units
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Units we want to update
     *   }
     * })
     */
    upsert<T extends UnitsUpsertArgs>(args: SelectSubset<T, UnitsUpsertArgs<ExtArgs>>): Prisma__UnitsClient<$Result.GetResult<Prisma.$UnitsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Units.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitsCountArgs} args - Arguments to filter Units to count.
     * @example
     * // Count the number of Units
     * const count = await prisma.units.count({
     *   where: {
     *     // ... the filter for the Units we want to count
     *   }
     * })
    **/
    count<T extends UnitsCountArgs>(
      args?: Subset<T, UnitsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UnitsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Units.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UnitsAggregateArgs>(args: Subset<T, UnitsAggregateArgs>): Prisma.PrismaPromise<GetUnitsAggregateType<T>>

    /**
     * Group by Units.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UnitsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UnitsGroupByArgs['orderBy'] }
        : { orderBy?: UnitsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UnitsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUnitsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Units model
   */
  readonly fields: UnitsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Units.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UnitsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Residents<T extends Units$ResidentsArgs<ExtArgs> = {}>(args?: Subset<T, Units$ResidentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResidentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Payments<T extends Units$PaymentsArgs<ExtArgs> = {}>(args?: Subset<T, Units$PaymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Bills<T extends Units$BillsArgs<ExtArgs> = {}>(args?: Subset<T, Units$BillsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Complaints<T extends Units$ComplaintsArgs<ExtArgs> = {}>(args?: Subset<T, Units$ComplaintsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComplaintsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Units model
   */
  interface UnitsFieldRefs {
    readonly id: FieldRef<"Units", 'String'>
    readonly unitNumber: FieldRef<"Units", 'String'>
    readonly buildingName: FieldRef<"Units", 'String'>
    readonly floorNumber: FieldRef<"Units", 'Int'>
    readonly numberOfRooms: FieldRef<"Units", 'Int'>
    readonly priceSale: FieldRef<"Units", 'Float'>
    readonly squareFootage: FieldRef<"Units", 'Int'>
    readonly location: FieldRef<"Units", 'String'>
    readonly status: FieldRef<"Units", 'UnitStatus'>
    readonly createdAt: FieldRef<"Units", 'DateTime'>
    readonly updatedAt: FieldRef<"Units", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Units findUnique
   */
  export type UnitsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Units
     */
    select?: UnitsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Units
     */
    omit?: UnitsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitsInclude<ExtArgs> | null
    /**
     * Filter, which Units to fetch.
     */
    where: UnitsWhereUniqueInput
  }

  /**
   * Units findUniqueOrThrow
   */
  export type UnitsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Units
     */
    select?: UnitsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Units
     */
    omit?: UnitsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitsInclude<ExtArgs> | null
    /**
     * Filter, which Units to fetch.
     */
    where: UnitsWhereUniqueInput
  }

  /**
   * Units findFirst
   */
  export type UnitsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Units
     */
    select?: UnitsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Units
     */
    omit?: UnitsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitsInclude<ExtArgs> | null
    /**
     * Filter, which Units to fetch.
     */
    where?: UnitsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Units to fetch.
     */
    orderBy?: UnitsOrderByWithRelationInput | UnitsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Units.
     */
    cursor?: UnitsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Units from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Units.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Units.
     */
    distinct?: UnitsScalarFieldEnum | UnitsScalarFieldEnum[]
  }

  /**
   * Units findFirstOrThrow
   */
  export type UnitsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Units
     */
    select?: UnitsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Units
     */
    omit?: UnitsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitsInclude<ExtArgs> | null
    /**
     * Filter, which Units to fetch.
     */
    where?: UnitsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Units to fetch.
     */
    orderBy?: UnitsOrderByWithRelationInput | UnitsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Units.
     */
    cursor?: UnitsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Units from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Units.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Units.
     */
    distinct?: UnitsScalarFieldEnum | UnitsScalarFieldEnum[]
  }

  /**
   * Units findMany
   */
  export type UnitsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Units
     */
    select?: UnitsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Units
     */
    omit?: UnitsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitsInclude<ExtArgs> | null
    /**
     * Filter, which Units to fetch.
     */
    where?: UnitsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Units to fetch.
     */
    orderBy?: UnitsOrderByWithRelationInput | UnitsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Units.
     */
    cursor?: UnitsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Units from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Units.
     */
    skip?: number
    distinct?: UnitsScalarFieldEnum | UnitsScalarFieldEnum[]
  }

  /**
   * Units create
   */
  export type UnitsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Units
     */
    select?: UnitsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Units
     */
    omit?: UnitsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitsInclude<ExtArgs> | null
    /**
     * The data needed to create a Units.
     */
    data: XOR<UnitsCreateInput, UnitsUncheckedCreateInput>
  }

  /**
   * Units createMany
   */
  export type UnitsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Units.
     */
    data: UnitsCreateManyInput | UnitsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Units createManyAndReturn
   */
  export type UnitsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Units
     */
    select?: UnitsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Units
     */
    omit?: UnitsOmit<ExtArgs> | null
    /**
     * The data used to create many Units.
     */
    data: UnitsCreateManyInput | UnitsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Units update
   */
  export type UnitsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Units
     */
    select?: UnitsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Units
     */
    omit?: UnitsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitsInclude<ExtArgs> | null
    /**
     * The data needed to update a Units.
     */
    data: XOR<UnitsUpdateInput, UnitsUncheckedUpdateInput>
    /**
     * Choose, which Units to update.
     */
    where: UnitsWhereUniqueInput
  }

  /**
   * Units updateMany
   */
  export type UnitsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Units.
     */
    data: XOR<UnitsUpdateManyMutationInput, UnitsUncheckedUpdateManyInput>
    /**
     * Filter which Units to update
     */
    where?: UnitsWhereInput
    /**
     * Limit how many Units to update.
     */
    limit?: number
  }

  /**
   * Units updateManyAndReturn
   */
  export type UnitsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Units
     */
    select?: UnitsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Units
     */
    omit?: UnitsOmit<ExtArgs> | null
    /**
     * The data used to update Units.
     */
    data: XOR<UnitsUpdateManyMutationInput, UnitsUncheckedUpdateManyInput>
    /**
     * Filter which Units to update
     */
    where?: UnitsWhereInput
    /**
     * Limit how many Units to update.
     */
    limit?: number
  }

  /**
   * Units upsert
   */
  export type UnitsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Units
     */
    select?: UnitsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Units
     */
    omit?: UnitsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitsInclude<ExtArgs> | null
    /**
     * The filter to search for the Units to update in case it exists.
     */
    where: UnitsWhereUniqueInput
    /**
     * In case the Units found by the `where` argument doesn't exist, create a new Units with this data.
     */
    create: XOR<UnitsCreateInput, UnitsUncheckedCreateInput>
    /**
     * In case the Units was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UnitsUpdateInput, UnitsUncheckedUpdateInput>
  }

  /**
   * Units delete
   */
  export type UnitsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Units
     */
    select?: UnitsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Units
     */
    omit?: UnitsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitsInclude<ExtArgs> | null
    /**
     * Filter which Units to delete.
     */
    where: UnitsWhereUniqueInput
  }

  /**
   * Units deleteMany
   */
  export type UnitsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Units to delete
     */
    where?: UnitsWhereInput
    /**
     * Limit how many Units to delete.
     */
    limit?: number
  }

  /**
   * Units.Residents
   */
  export type Units$ResidentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Residents
     */
    select?: ResidentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Residents
     */
    omit?: ResidentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResidentsInclude<ExtArgs> | null
    where?: ResidentsWhereInput
    orderBy?: ResidentsOrderByWithRelationInput | ResidentsOrderByWithRelationInput[]
    cursor?: ResidentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ResidentsScalarFieldEnum | ResidentsScalarFieldEnum[]
  }

  /**
   * Units.Payments
   */
  export type Units$PaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payments
     */
    select?: PaymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payments
     */
    omit?: PaymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentsInclude<ExtArgs> | null
    where?: PaymentsWhereInput
    orderBy?: PaymentsOrderByWithRelationInput | PaymentsOrderByWithRelationInput[]
    cursor?: PaymentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentsScalarFieldEnum | PaymentsScalarFieldEnum[]
  }

  /**
   * Units.Bills
   */
  export type Units$BillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bills
     */
    select?: BillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bills
     */
    omit?: BillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillsInclude<ExtArgs> | null
    where?: BillsWhereInput
    orderBy?: BillsOrderByWithRelationInput | BillsOrderByWithRelationInput[]
    cursor?: BillsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BillsScalarFieldEnum | BillsScalarFieldEnum[]
  }

  /**
   * Units.Complaints
   */
  export type Units$ComplaintsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Complaints
     */
    select?: ComplaintsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Complaints
     */
    omit?: ComplaintsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintsInclude<ExtArgs> | null
    where?: ComplaintsWhereInput
    orderBy?: ComplaintsOrderByWithRelationInput | ComplaintsOrderByWithRelationInput[]
    cursor?: ComplaintsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ComplaintsScalarFieldEnum | ComplaintsScalarFieldEnum[]
  }

  /**
   * Units without action
   */
  export type UnitsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Units
     */
    select?: UnitsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Units
     */
    omit?: UnitsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitsInclude<ExtArgs> | null
  }


  /**
   * Model Bills
   */

  export type AggregateBills = {
    _count: BillsCountAggregateOutputType | null
    _avg: BillsAvgAggregateOutputType | null
    _sum: BillsSumAggregateOutputType | null
    _min: BillsMinAggregateOutputType | null
    _max: BillsMaxAggregateOutputType | null
  }

  export type BillsAvgAggregateOutputType = {
    amount: number | null
  }

  export type BillsSumAggregateOutputType = {
    amount: number | null
  }

  export type BillsMinAggregateOutputType = {
    id: string | null
    amount: number | null
    type: $Enums.PaymentType | null
    dueDate: Date | null
    isPaid: boolean | null
    unitId: string | null
    employeeId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BillsMaxAggregateOutputType = {
    id: string | null
    amount: number | null
    type: $Enums.PaymentType | null
    dueDate: Date | null
    isPaid: boolean | null
    unitId: string | null
    employeeId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BillsCountAggregateOutputType = {
    id: number
    amount: number
    type: number
    dueDate: number
    isPaid: number
    unitId: number
    employeeId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BillsAvgAggregateInputType = {
    amount?: true
  }

  export type BillsSumAggregateInputType = {
    amount?: true
  }

  export type BillsMinAggregateInputType = {
    id?: true
    amount?: true
    type?: true
    dueDate?: true
    isPaid?: true
    unitId?: true
    employeeId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BillsMaxAggregateInputType = {
    id?: true
    amount?: true
    type?: true
    dueDate?: true
    isPaid?: true
    unitId?: true
    employeeId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BillsCountAggregateInputType = {
    id?: true
    amount?: true
    type?: true
    dueDate?: true
    isPaid?: true
    unitId?: true
    employeeId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BillsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bills to aggregate.
     */
    where?: BillsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bills to fetch.
     */
    orderBy?: BillsOrderByWithRelationInput | BillsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BillsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Bills
    **/
    _count?: true | BillsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BillsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BillsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BillsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BillsMaxAggregateInputType
  }

  export type GetBillsAggregateType<T extends BillsAggregateArgs> = {
        [P in keyof T & keyof AggregateBills]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBills[P]>
      : GetScalarType<T[P], AggregateBills[P]>
  }




  export type BillsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BillsWhereInput
    orderBy?: BillsOrderByWithAggregationInput | BillsOrderByWithAggregationInput[]
    by: BillsScalarFieldEnum[] | BillsScalarFieldEnum
    having?: BillsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BillsCountAggregateInputType | true
    _avg?: BillsAvgAggregateInputType
    _sum?: BillsSumAggregateInputType
    _min?: BillsMinAggregateInputType
    _max?: BillsMaxAggregateInputType
  }

  export type BillsGroupByOutputType = {
    id: string
    amount: number
    type: $Enums.PaymentType
    dueDate: Date
    isPaid: boolean
    unitId: string
    employeeId: string
    createdAt: Date
    updatedAt: Date
    _count: BillsCountAggregateOutputType | null
    _avg: BillsAvgAggregateOutputType | null
    _sum: BillsSumAggregateOutputType | null
    _min: BillsMinAggregateOutputType | null
    _max: BillsMaxAggregateOutputType | null
  }

  type GetBillsGroupByPayload<T extends BillsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BillsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BillsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BillsGroupByOutputType[P]>
            : GetScalarType<T[P], BillsGroupByOutputType[P]>
        }
      >
    >


  export type BillsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amount?: boolean
    type?: boolean
    dueDate?: boolean
    isPaid?: boolean
    unitId?: boolean
    employeeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    unit?: boolean | UnitsDefaultArgs<ExtArgs>
    employee?: boolean | EmployeesDefaultArgs<ExtArgs>
    Payments?: boolean | Bills$PaymentsArgs<ExtArgs>
    _count?: boolean | BillsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bills"]>

  export type BillsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amount?: boolean
    type?: boolean
    dueDate?: boolean
    isPaid?: boolean
    unitId?: boolean
    employeeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    unit?: boolean | UnitsDefaultArgs<ExtArgs>
    employee?: boolean | EmployeesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bills"]>

  export type BillsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amount?: boolean
    type?: boolean
    dueDate?: boolean
    isPaid?: boolean
    unitId?: boolean
    employeeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    unit?: boolean | UnitsDefaultArgs<ExtArgs>
    employee?: boolean | EmployeesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bills"]>

  export type BillsSelectScalar = {
    id?: boolean
    amount?: boolean
    type?: boolean
    dueDate?: boolean
    isPaid?: boolean
    unitId?: boolean
    employeeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BillsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "amount" | "type" | "dueDate" | "isPaid" | "unitId" | "employeeId" | "createdAt" | "updatedAt", ExtArgs["result"]["bills"]>
  export type BillsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    unit?: boolean | UnitsDefaultArgs<ExtArgs>
    employee?: boolean | EmployeesDefaultArgs<ExtArgs>
    Payments?: boolean | Bills$PaymentsArgs<ExtArgs>
    _count?: boolean | BillsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BillsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    unit?: boolean | UnitsDefaultArgs<ExtArgs>
    employee?: boolean | EmployeesDefaultArgs<ExtArgs>
  }
  export type BillsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    unit?: boolean | UnitsDefaultArgs<ExtArgs>
    employee?: boolean | EmployeesDefaultArgs<ExtArgs>
  }

  export type $BillsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Bills"
    objects: {
      unit: Prisma.$UnitsPayload<ExtArgs>
      employee: Prisma.$EmployeesPayload<ExtArgs>
      Payments: Prisma.$PaymentsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      amount: number
      type: $Enums.PaymentType
      dueDate: Date
      isPaid: boolean
      unitId: string
      employeeId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["bills"]>
    composites: {}
  }

  type BillsGetPayload<S extends boolean | null | undefined | BillsDefaultArgs> = $Result.GetResult<Prisma.$BillsPayload, S>

  type BillsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BillsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BillsCountAggregateInputType | true
    }

  export interface BillsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Bills'], meta: { name: 'Bills' } }
    /**
     * Find zero or one Bills that matches the filter.
     * @param {BillsFindUniqueArgs} args - Arguments to find a Bills
     * @example
     * // Get one Bills
     * const bills = await prisma.bills.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BillsFindUniqueArgs>(args: SelectSubset<T, BillsFindUniqueArgs<ExtArgs>>): Prisma__BillsClient<$Result.GetResult<Prisma.$BillsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Bills that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BillsFindUniqueOrThrowArgs} args - Arguments to find a Bills
     * @example
     * // Get one Bills
     * const bills = await prisma.bills.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BillsFindUniqueOrThrowArgs>(args: SelectSubset<T, BillsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BillsClient<$Result.GetResult<Prisma.$BillsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Bills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillsFindFirstArgs} args - Arguments to find a Bills
     * @example
     * // Get one Bills
     * const bills = await prisma.bills.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BillsFindFirstArgs>(args?: SelectSubset<T, BillsFindFirstArgs<ExtArgs>>): Prisma__BillsClient<$Result.GetResult<Prisma.$BillsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Bills that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillsFindFirstOrThrowArgs} args - Arguments to find a Bills
     * @example
     * // Get one Bills
     * const bills = await prisma.bills.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BillsFindFirstOrThrowArgs>(args?: SelectSubset<T, BillsFindFirstOrThrowArgs<ExtArgs>>): Prisma__BillsClient<$Result.GetResult<Prisma.$BillsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Bills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bills
     * const bills = await prisma.bills.findMany()
     * 
     * // Get first 10 Bills
     * const bills = await prisma.bills.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const billsWithIdOnly = await prisma.bills.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BillsFindManyArgs>(args?: SelectSubset<T, BillsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Bills.
     * @param {BillsCreateArgs} args - Arguments to create a Bills.
     * @example
     * // Create one Bills
     * const Bills = await prisma.bills.create({
     *   data: {
     *     // ... data to create a Bills
     *   }
     * })
     * 
     */
    create<T extends BillsCreateArgs>(args: SelectSubset<T, BillsCreateArgs<ExtArgs>>): Prisma__BillsClient<$Result.GetResult<Prisma.$BillsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Bills.
     * @param {BillsCreateManyArgs} args - Arguments to create many Bills.
     * @example
     * // Create many Bills
     * const bills = await prisma.bills.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BillsCreateManyArgs>(args?: SelectSubset<T, BillsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Bills and returns the data saved in the database.
     * @param {BillsCreateManyAndReturnArgs} args - Arguments to create many Bills.
     * @example
     * // Create many Bills
     * const bills = await prisma.bills.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Bills and only return the `id`
     * const billsWithIdOnly = await prisma.bills.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BillsCreateManyAndReturnArgs>(args?: SelectSubset<T, BillsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Bills.
     * @param {BillsDeleteArgs} args - Arguments to delete one Bills.
     * @example
     * // Delete one Bills
     * const Bills = await prisma.bills.delete({
     *   where: {
     *     // ... filter to delete one Bills
     *   }
     * })
     * 
     */
    delete<T extends BillsDeleteArgs>(args: SelectSubset<T, BillsDeleteArgs<ExtArgs>>): Prisma__BillsClient<$Result.GetResult<Prisma.$BillsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Bills.
     * @param {BillsUpdateArgs} args - Arguments to update one Bills.
     * @example
     * // Update one Bills
     * const bills = await prisma.bills.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BillsUpdateArgs>(args: SelectSubset<T, BillsUpdateArgs<ExtArgs>>): Prisma__BillsClient<$Result.GetResult<Prisma.$BillsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Bills.
     * @param {BillsDeleteManyArgs} args - Arguments to filter Bills to delete.
     * @example
     * // Delete a few Bills
     * const { count } = await prisma.bills.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BillsDeleteManyArgs>(args?: SelectSubset<T, BillsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bills
     * const bills = await prisma.bills.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BillsUpdateManyArgs>(args: SelectSubset<T, BillsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bills and returns the data updated in the database.
     * @param {BillsUpdateManyAndReturnArgs} args - Arguments to update many Bills.
     * @example
     * // Update many Bills
     * const bills = await prisma.bills.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Bills and only return the `id`
     * const billsWithIdOnly = await prisma.bills.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BillsUpdateManyAndReturnArgs>(args: SelectSubset<T, BillsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Bills.
     * @param {BillsUpsertArgs} args - Arguments to update or create a Bills.
     * @example
     * // Update or create a Bills
     * const bills = await prisma.bills.upsert({
     *   create: {
     *     // ... data to create a Bills
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bills we want to update
     *   }
     * })
     */
    upsert<T extends BillsUpsertArgs>(args: SelectSubset<T, BillsUpsertArgs<ExtArgs>>): Prisma__BillsClient<$Result.GetResult<Prisma.$BillsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Bills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillsCountArgs} args - Arguments to filter Bills to count.
     * @example
     * // Count the number of Bills
     * const count = await prisma.bills.count({
     *   where: {
     *     // ... the filter for the Bills we want to count
     *   }
     * })
    **/
    count<T extends BillsCountArgs>(
      args?: Subset<T, BillsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BillsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BillsAggregateArgs>(args: Subset<T, BillsAggregateArgs>): Prisma.PrismaPromise<GetBillsAggregateType<T>>

    /**
     * Group by Bills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BillsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BillsGroupByArgs['orderBy'] }
        : { orderBy?: BillsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BillsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBillsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Bills model
   */
  readonly fields: BillsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Bills.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BillsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    unit<T extends UnitsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UnitsDefaultArgs<ExtArgs>>): Prisma__UnitsClient<$Result.GetResult<Prisma.$UnitsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    employee<T extends EmployeesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeesDefaultArgs<ExtArgs>>): Prisma__EmployeesClient<$Result.GetResult<Prisma.$EmployeesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Payments<T extends Bills$PaymentsArgs<ExtArgs> = {}>(args?: Subset<T, Bills$PaymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Bills model
   */
  interface BillsFieldRefs {
    readonly id: FieldRef<"Bills", 'String'>
    readonly amount: FieldRef<"Bills", 'Float'>
    readonly type: FieldRef<"Bills", 'PaymentType'>
    readonly dueDate: FieldRef<"Bills", 'DateTime'>
    readonly isPaid: FieldRef<"Bills", 'Boolean'>
    readonly unitId: FieldRef<"Bills", 'String'>
    readonly employeeId: FieldRef<"Bills", 'String'>
    readonly createdAt: FieldRef<"Bills", 'DateTime'>
    readonly updatedAt: FieldRef<"Bills", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Bills findUnique
   */
  export type BillsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bills
     */
    select?: BillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bills
     */
    omit?: BillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillsInclude<ExtArgs> | null
    /**
     * Filter, which Bills to fetch.
     */
    where: BillsWhereUniqueInput
  }

  /**
   * Bills findUniqueOrThrow
   */
  export type BillsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bills
     */
    select?: BillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bills
     */
    omit?: BillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillsInclude<ExtArgs> | null
    /**
     * Filter, which Bills to fetch.
     */
    where: BillsWhereUniqueInput
  }

  /**
   * Bills findFirst
   */
  export type BillsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bills
     */
    select?: BillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bills
     */
    omit?: BillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillsInclude<ExtArgs> | null
    /**
     * Filter, which Bills to fetch.
     */
    where?: BillsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bills to fetch.
     */
    orderBy?: BillsOrderByWithRelationInput | BillsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bills.
     */
    cursor?: BillsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bills.
     */
    distinct?: BillsScalarFieldEnum | BillsScalarFieldEnum[]
  }

  /**
   * Bills findFirstOrThrow
   */
  export type BillsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bills
     */
    select?: BillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bills
     */
    omit?: BillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillsInclude<ExtArgs> | null
    /**
     * Filter, which Bills to fetch.
     */
    where?: BillsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bills to fetch.
     */
    orderBy?: BillsOrderByWithRelationInput | BillsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bills.
     */
    cursor?: BillsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bills.
     */
    distinct?: BillsScalarFieldEnum | BillsScalarFieldEnum[]
  }

  /**
   * Bills findMany
   */
  export type BillsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bills
     */
    select?: BillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bills
     */
    omit?: BillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillsInclude<ExtArgs> | null
    /**
     * Filter, which Bills to fetch.
     */
    where?: BillsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bills to fetch.
     */
    orderBy?: BillsOrderByWithRelationInput | BillsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Bills.
     */
    cursor?: BillsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bills.
     */
    skip?: number
    distinct?: BillsScalarFieldEnum | BillsScalarFieldEnum[]
  }

  /**
   * Bills create
   */
  export type BillsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bills
     */
    select?: BillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bills
     */
    omit?: BillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillsInclude<ExtArgs> | null
    /**
     * The data needed to create a Bills.
     */
    data: XOR<BillsCreateInput, BillsUncheckedCreateInput>
  }

  /**
   * Bills createMany
   */
  export type BillsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Bills.
     */
    data: BillsCreateManyInput | BillsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Bills createManyAndReturn
   */
  export type BillsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bills
     */
    select?: BillsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Bills
     */
    omit?: BillsOmit<ExtArgs> | null
    /**
     * The data used to create many Bills.
     */
    data: BillsCreateManyInput | BillsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Bills update
   */
  export type BillsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bills
     */
    select?: BillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bills
     */
    omit?: BillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillsInclude<ExtArgs> | null
    /**
     * The data needed to update a Bills.
     */
    data: XOR<BillsUpdateInput, BillsUncheckedUpdateInput>
    /**
     * Choose, which Bills to update.
     */
    where: BillsWhereUniqueInput
  }

  /**
   * Bills updateMany
   */
  export type BillsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Bills.
     */
    data: XOR<BillsUpdateManyMutationInput, BillsUncheckedUpdateManyInput>
    /**
     * Filter which Bills to update
     */
    where?: BillsWhereInput
    /**
     * Limit how many Bills to update.
     */
    limit?: number
  }

  /**
   * Bills updateManyAndReturn
   */
  export type BillsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bills
     */
    select?: BillsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Bills
     */
    omit?: BillsOmit<ExtArgs> | null
    /**
     * The data used to update Bills.
     */
    data: XOR<BillsUpdateManyMutationInput, BillsUncheckedUpdateManyInput>
    /**
     * Filter which Bills to update
     */
    where?: BillsWhereInput
    /**
     * Limit how many Bills to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Bills upsert
   */
  export type BillsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bills
     */
    select?: BillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bills
     */
    omit?: BillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillsInclude<ExtArgs> | null
    /**
     * The filter to search for the Bills to update in case it exists.
     */
    where: BillsWhereUniqueInput
    /**
     * In case the Bills found by the `where` argument doesn't exist, create a new Bills with this data.
     */
    create: XOR<BillsCreateInput, BillsUncheckedCreateInput>
    /**
     * In case the Bills was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BillsUpdateInput, BillsUncheckedUpdateInput>
  }

  /**
   * Bills delete
   */
  export type BillsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bills
     */
    select?: BillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bills
     */
    omit?: BillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillsInclude<ExtArgs> | null
    /**
     * Filter which Bills to delete.
     */
    where: BillsWhereUniqueInput
  }

  /**
   * Bills deleteMany
   */
  export type BillsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bills to delete
     */
    where?: BillsWhereInput
    /**
     * Limit how many Bills to delete.
     */
    limit?: number
  }

  /**
   * Bills.Payments
   */
  export type Bills$PaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payments
     */
    select?: PaymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payments
     */
    omit?: PaymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentsInclude<ExtArgs> | null
    where?: PaymentsWhereInput
    orderBy?: PaymentsOrderByWithRelationInput | PaymentsOrderByWithRelationInput[]
    cursor?: PaymentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentsScalarFieldEnum | PaymentsScalarFieldEnum[]
  }

  /**
   * Bills without action
   */
  export type BillsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bills
     */
    select?: BillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bills
     */
    omit?: BillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillsInclude<ExtArgs> | null
  }


  /**
   * Model Payments
   */

  export type AggregatePayments = {
    _count: PaymentsCountAggregateOutputType | null
    _avg: PaymentsAvgAggregateOutputType | null
    _sum: PaymentsSumAggregateOutputType | null
    _min: PaymentsMinAggregateOutputType | null
    _max: PaymentsMaxAggregateOutputType | null
  }

  export type PaymentsAvgAggregateOutputType = {
    amount: number | null
  }

  export type PaymentsSumAggregateOutputType = {
    amount: number | null
  }

  export type PaymentsMinAggregateOutputType = {
    id: string | null
    amount: number | null
    paymentDate: Date | null
    paymentMethod: $Enums.PaymentMethod | null
    status: $Enums.PaymentStatus | null
    residentId: string | null
    unitId: string | null
    processedByEmployeeId: string | null
    billId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentsMaxAggregateOutputType = {
    id: string | null
    amount: number | null
    paymentDate: Date | null
    paymentMethod: $Enums.PaymentMethod | null
    status: $Enums.PaymentStatus | null
    residentId: string | null
    unitId: string | null
    processedByEmployeeId: string | null
    billId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentsCountAggregateOutputType = {
    id: number
    amount: number
    paymentDate: number
    paymentMethod: number
    status: number
    residentId: number
    unitId: number
    processedByEmployeeId: number
    billId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PaymentsAvgAggregateInputType = {
    amount?: true
  }

  export type PaymentsSumAggregateInputType = {
    amount?: true
  }

  export type PaymentsMinAggregateInputType = {
    id?: true
    amount?: true
    paymentDate?: true
    paymentMethod?: true
    status?: true
    residentId?: true
    unitId?: true
    processedByEmployeeId?: true
    billId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentsMaxAggregateInputType = {
    id?: true
    amount?: true
    paymentDate?: true
    paymentMethod?: true
    status?: true
    residentId?: true
    unitId?: true
    processedByEmployeeId?: true
    billId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentsCountAggregateInputType = {
    id?: true
    amount?: true
    paymentDate?: true
    paymentMethod?: true
    status?: true
    residentId?: true
    unitId?: true
    processedByEmployeeId?: true
    billId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PaymentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to aggregate.
     */
    where?: PaymentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentsOrderByWithRelationInput | PaymentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payments
    **/
    _count?: true | PaymentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentsMaxAggregateInputType
  }

  export type GetPaymentsAggregateType<T extends PaymentsAggregateArgs> = {
        [P in keyof T & keyof AggregatePayments]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayments[P]>
      : GetScalarType<T[P], AggregatePayments[P]>
  }




  export type PaymentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentsWhereInput
    orderBy?: PaymentsOrderByWithAggregationInput | PaymentsOrderByWithAggregationInput[]
    by: PaymentsScalarFieldEnum[] | PaymentsScalarFieldEnum
    having?: PaymentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentsCountAggregateInputType | true
    _avg?: PaymentsAvgAggregateInputType
    _sum?: PaymentsSumAggregateInputType
    _min?: PaymentsMinAggregateInputType
    _max?: PaymentsMaxAggregateInputType
  }

  export type PaymentsGroupByOutputType = {
    id: string
    amount: number
    paymentDate: Date
    paymentMethod: $Enums.PaymentMethod
    status: $Enums.PaymentStatus
    residentId: string
    unitId: string | null
    processedByEmployeeId: string | null
    billId: string | null
    createdAt: Date
    updatedAt: Date
    _count: PaymentsCountAggregateOutputType | null
    _avg: PaymentsAvgAggregateOutputType | null
    _sum: PaymentsSumAggregateOutputType | null
    _min: PaymentsMinAggregateOutputType | null
    _max: PaymentsMaxAggregateOutputType | null
  }

  type GetPaymentsGroupByPayload<T extends PaymentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentsGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentsGroupByOutputType[P]>
        }
      >
    >


  export type PaymentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amount?: boolean
    paymentDate?: boolean
    paymentMethod?: boolean
    status?: boolean
    residentId?: boolean
    unitId?: boolean
    processedByEmployeeId?: boolean
    billId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    resident?: boolean | ResidentsDefaultArgs<ExtArgs>
    unit?: boolean | Payments$unitArgs<ExtArgs>
    processedBy?: boolean | Payments$processedByArgs<ExtArgs>
    bill?: boolean | Payments$billArgs<ExtArgs>
  }, ExtArgs["result"]["payments"]>

  export type PaymentsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amount?: boolean
    paymentDate?: boolean
    paymentMethod?: boolean
    status?: boolean
    residentId?: boolean
    unitId?: boolean
    processedByEmployeeId?: boolean
    billId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    resident?: boolean | ResidentsDefaultArgs<ExtArgs>
    unit?: boolean | Payments$unitArgs<ExtArgs>
    processedBy?: boolean | Payments$processedByArgs<ExtArgs>
    bill?: boolean | Payments$billArgs<ExtArgs>
  }, ExtArgs["result"]["payments"]>

  export type PaymentsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amount?: boolean
    paymentDate?: boolean
    paymentMethod?: boolean
    status?: boolean
    residentId?: boolean
    unitId?: boolean
    processedByEmployeeId?: boolean
    billId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    resident?: boolean | ResidentsDefaultArgs<ExtArgs>
    unit?: boolean | Payments$unitArgs<ExtArgs>
    processedBy?: boolean | Payments$processedByArgs<ExtArgs>
    bill?: boolean | Payments$billArgs<ExtArgs>
  }, ExtArgs["result"]["payments"]>

  export type PaymentsSelectScalar = {
    id?: boolean
    amount?: boolean
    paymentDate?: boolean
    paymentMethod?: boolean
    status?: boolean
    residentId?: boolean
    unitId?: boolean
    processedByEmployeeId?: boolean
    billId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PaymentsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "amount" | "paymentDate" | "paymentMethod" | "status" | "residentId" | "unitId" | "processedByEmployeeId" | "billId" | "createdAt" | "updatedAt", ExtArgs["result"]["payments"]>
  export type PaymentsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    resident?: boolean | ResidentsDefaultArgs<ExtArgs>
    unit?: boolean | Payments$unitArgs<ExtArgs>
    processedBy?: boolean | Payments$processedByArgs<ExtArgs>
    bill?: boolean | Payments$billArgs<ExtArgs>
  }
  export type PaymentsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    resident?: boolean | ResidentsDefaultArgs<ExtArgs>
    unit?: boolean | Payments$unitArgs<ExtArgs>
    processedBy?: boolean | Payments$processedByArgs<ExtArgs>
    bill?: boolean | Payments$billArgs<ExtArgs>
  }
  export type PaymentsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    resident?: boolean | ResidentsDefaultArgs<ExtArgs>
    unit?: boolean | Payments$unitArgs<ExtArgs>
    processedBy?: boolean | Payments$processedByArgs<ExtArgs>
    bill?: boolean | Payments$billArgs<ExtArgs>
  }

  export type $PaymentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payments"
    objects: {
      resident: Prisma.$ResidentsPayload<ExtArgs>
      unit: Prisma.$UnitsPayload<ExtArgs> | null
      processedBy: Prisma.$EmployeesPayload<ExtArgs> | null
      bill: Prisma.$BillsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      amount: number
      paymentDate: Date
      paymentMethod: $Enums.PaymentMethod
      status: $Enums.PaymentStatus
      residentId: string
      unitId: string | null
      processedByEmployeeId: string | null
      billId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["payments"]>
    composites: {}
  }

  type PaymentsGetPayload<S extends boolean | null | undefined | PaymentsDefaultArgs> = $Result.GetResult<Prisma.$PaymentsPayload, S>

  type PaymentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentsCountAggregateInputType | true
    }

  export interface PaymentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payments'], meta: { name: 'Payments' } }
    /**
     * Find zero or one Payments that matches the filter.
     * @param {PaymentsFindUniqueArgs} args - Arguments to find a Payments
     * @example
     * // Get one Payments
     * const payments = await prisma.payments.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentsFindUniqueArgs>(args: SelectSubset<T, PaymentsFindUniqueArgs<ExtArgs>>): Prisma__PaymentsClient<$Result.GetResult<Prisma.$PaymentsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Payments that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentsFindUniqueOrThrowArgs} args - Arguments to find a Payments
     * @example
     * // Get one Payments
     * const payments = await prisma.payments.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentsFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentsClient<$Result.GetResult<Prisma.$PaymentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentsFindFirstArgs} args - Arguments to find a Payments
     * @example
     * // Get one Payments
     * const payments = await prisma.payments.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentsFindFirstArgs>(args?: SelectSubset<T, PaymentsFindFirstArgs<ExtArgs>>): Prisma__PaymentsClient<$Result.GetResult<Prisma.$PaymentsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payments that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentsFindFirstOrThrowArgs} args - Arguments to find a Payments
     * @example
     * // Get one Payments
     * const payments = await prisma.payments.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentsFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentsFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentsClient<$Result.GetResult<Prisma.$PaymentsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payments.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payments.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentsWithIdOnly = await prisma.payments.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentsFindManyArgs>(args?: SelectSubset<T, PaymentsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Payments.
     * @param {PaymentsCreateArgs} args - Arguments to create a Payments.
     * @example
     * // Create one Payments
     * const Payments = await prisma.payments.create({
     *   data: {
     *     // ... data to create a Payments
     *   }
     * })
     * 
     */
    create<T extends PaymentsCreateArgs>(args: SelectSubset<T, PaymentsCreateArgs<ExtArgs>>): Prisma__PaymentsClient<$Result.GetResult<Prisma.$PaymentsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Payments.
     * @param {PaymentsCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payments = await prisma.payments.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentsCreateManyArgs>(args?: SelectSubset<T, PaymentsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payments and returns the data saved in the database.
     * @param {PaymentsCreateManyAndReturnArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payments = await prisma.payments.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payments and only return the `id`
     * const paymentsWithIdOnly = await prisma.payments.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentsCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Payments.
     * @param {PaymentsDeleteArgs} args - Arguments to delete one Payments.
     * @example
     * // Delete one Payments
     * const Payments = await prisma.payments.delete({
     *   where: {
     *     // ... filter to delete one Payments
     *   }
     * })
     * 
     */
    delete<T extends PaymentsDeleteArgs>(args: SelectSubset<T, PaymentsDeleteArgs<ExtArgs>>): Prisma__PaymentsClient<$Result.GetResult<Prisma.$PaymentsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Payments.
     * @param {PaymentsUpdateArgs} args - Arguments to update one Payments.
     * @example
     * // Update one Payments
     * const payments = await prisma.payments.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentsUpdateArgs>(args: SelectSubset<T, PaymentsUpdateArgs<ExtArgs>>): Prisma__PaymentsClient<$Result.GetResult<Prisma.$PaymentsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Payments.
     * @param {PaymentsDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payments.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentsDeleteManyArgs>(args?: SelectSubset<T, PaymentsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payments = await prisma.payments.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentsUpdateManyArgs>(args: SelectSubset<T, PaymentsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments and returns the data updated in the database.
     * @param {PaymentsUpdateManyAndReturnArgs} args - Arguments to update many Payments.
     * @example
     * // Update many Payments
     * const payments = await prisma.payments.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Payments and only return the `id`
     * const paymentsWithIdOnly = await prisma.payments.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PaymentsUpdateManyAndReturnArgs>(args: SelectSubset<T, PaymentsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Payments.
     * @param {PaymentsUpsertArgs} args - Arguments to update or create a Payments.
     * @example
     * // Update or create a Payments
     * const payments = await prisma.payments.upsert({
     *   create: {
     *     // ... data to create a Payments
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payments we want to update
     *   }
     * })
     */
    upsert<T extends PaymentsUpsertArgs>(args: SelectSubset<T, PaymentsUpsertArgs<ExtArgs>>): Prisma__PaymentsClient<$Result.GetResult<Prisma.$PaymentsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentsCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payments.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends PaymentsCountArgs>(
      args?: Subset<T, PaymentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentsAggregateArgs>(args: Subset<T, PaymentsAggregateArgs>): Prisma.PrismaPromise<GetPaymentsAggregateType<T>>

    /**
     * Group by Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentsGroupByArgs['orderBy'] }
        : { orderBy?: PaymentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payments model
   */
  readonly fields: PaymentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payments.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    resident<T extends ResidentsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ResidentsDefaultArgs<ExtArgs>>): Prisma__ResidentsClient<$Result.GetResult<Prisma.$ResidentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    unit<T extends Payments$unitArgs<ExtArgs> = {}>(args?: Subset<T, Payments$unitArgs<ExtArgs>>): Prisma__UnitsClient<$Result.GetResult<Prisma.$UnitsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    processedBy<T extends Payments$processedByArgs<ExtArgs> = {}>(args?: Subset<T, Payments$processedByArgs<ExtArgs>>): Prisma__EmployeesClient<$Result.GetResult<Prisma.$EmployeesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    bill<T extends Payments$billArgs<ExtArgs> = {}>(args?: Subset<T, Payments$billArgs<ExtArgs>>): Prisma__BillsClient<$Result.GetResult<Prisma.$BillsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Payments model
   */
  interface PaymentsFieldRefs {
    readonly id: FieldRef<"Payments", 'String'>
    readonly amount: FieldRef<"Payments", 'Float'>
    readonly paymentDate: FieldRef<"Payments", 'DateTime'>
    readonly paymentMethod: FieldRef<"Payments", 'PaymentMethod'>
    readonly status: FieldRef<"Payments", 'PaymentStatus'>
    readonly residentId: FieldRef<"Payments", 'String'>
    readonly unitId: FieldRef<"Payments", 'String'>
    readonly processedByEmployeeId: FieldRef<"Payments", 'String'>
    readonly billId: FieldRef<"Payments", 'String'>
    readonly createdAt: FieldRef<"Payments", 'DateTime'>
    readonly updatedAt: FieldRef<"Payments", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Payments findUnique
   */
  export type PaymentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payments
     */
    select?: PaymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payments
     */
    omit?: PaymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentsInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where: PaymentsWhereUniqueInput
  }

  /**
   * Payments findUniqueOrThrow
   */
  export type PaymentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payments
     */
    select?: PaymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payments
     */
    omit?: PaymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentsInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where: PaymentsWhereUniqueInput
  }

  /**
   * Payments findFirst
   */
  export type PaymentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payments
     */
    select?: PaymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payments
     */
    omit?: PaymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentsInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentsOrderByWithRelationInput | PaymentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentsScalarFieldEnum | PaymentsScalarFieldEnum[]
  }

  /**
   * Payments findFirstOrThrow
   */
  export type PaymentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payments
     */
    select?: PaymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payments
     */
    omit?: PaymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentsInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentsOrderByWithRelationInput | PaymentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentsScalarFieldEnum | PaymentsScalarFieldEnum[]
  }

  /**
   * Payments findMany
   */
  export type PaymentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payments
     */
    select?: PaymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payments
     */
    omit?: PaymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentsInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentsOrderByWithRelationInput | PaymentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payments.
     */
    cursor?: PaymentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    distinct?: PaymentsScalarFieldEnum | PaymentsScalarFieldEnum[]
  }

  /**
   * Payments create
   */
  export type PaymentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payments
     */
    select?: PaymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payments
     */
    omit?: PaymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentsInclude<ExtArgs> | null
    /**
     * The data needed to create a Payments.
     */
    data: XOR<PaymentsCreateInput, PaymentsUncheckedCreateInput>
  }

  /**
   * Payments createMany
   */
  export type PaymentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payments.
     */
    data: PaymentsCreateManyInput | PaymentsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Payments createManyAndReturn
   */
  export type PaymentsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payments
     */
    select?: PaymentsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payments
     */
    omit?: PaymentsOmit<ExtArgs> | null
    /**
     * The data used to create many Payments.
     */
    data: PaymentsCreateManyInput | PaymentsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payments update
   */
  export type PaymentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payments
     */
    select?: PaymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payments
     */
    omit?: PaymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentsInclude<ExtArgs> | null
    /**
     * The data needed to update a Payments.
     */
    data: XOR<PaymentsUpdateInput, PaymentsUncheckedUpdateInput>
    /**
     * Choose, which Payments to update.
     */
    where: PaymentsWhereUniqueInput
  }

  /**
   * Payments updateMany
   */
  export type PaymentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentsUpdateManyMutationInput, PaymentsUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentsWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
  }

  /**
   * Payments updateManyAndReturn
   */
  export type PaymentsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payments
     */
    select?: PaymentsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payments
     */
    omit?: PaymentsOmit<ExtArgs> | null
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentsUpdateManyMutationInput, PaymentsUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentsWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payments upsert
   */
  export type PaymentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payments
     */
    select?: PaymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payments
     */
    omit?: PaymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentsInclude<ExtArgs> | null
    /**
     * The filter to search for the Payments to update in case it exists.
     */
    where: PaymentsWhereUniqueInput
    /**
     * In case the Payments found by the `where` argument doesn't exist, create a new Payments with this data.
     */
    create: XOR<PaymentsCreateInput, PaymentsUncheckedCreateInput>
    /**
     * In case the Payments was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentsUpdateInput, PaymentsUncheckedUpdateInput>
  }

  /**
   * Payments delete
   */
  export type PaymentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payments
     */
    select?: PaymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payments
     */
    omit?: PaymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentsInclude<ExtArgs> | null
    /**
     * Filter which Payments to delete.
     */
    where: PaymentsWhereUniqueInput
  }

  /**
   * Payments deleteMany
   */
  export type PaymentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to delete
     */
    where?: PaymentsWhereInput
    /**
     * Limit how many Payments to delete.
     */
    limit?: number
  }

  /**
   * Payments.unit
   */
  export type Payments$unitArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Units
     */
    select?: UnitsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Units
     */
    omit?: UnitsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitsInclude<ExtArgs> | null
    where?: UnitsWhereInput
  }

  /**
   * Payments.processedBy
   */
  export type Payments$processedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employees
     */
    select?: EmployeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employees
     */
    omit?: EmployeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeesInclude<ExtArgs> | null
    where?: EmployeesWhereInput
  }

  /**
   * Payments.bill
   */
  export type Payments$billArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bills
     */
    select?: BillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bills
     */
    omit?: BillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillsInclude<ExtArgs> | null
    where?: BillsWhereInput
  }

  /**
   * Payments without action
   */
  export type PaymentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payments
     */
    select?: PaymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payments
     */
    omit?: PaymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentsInclude<ExtArgs> | null
  }


  /**
   * Model Contacts
   */

  export type AggregateContacts = {
    _count: ContactsCountAggregateOutputType | null
    _min: ContactsMinAggregateOutputType | null
    _max: ContactsMaxAggregateOutputType | null
  }

  export type ContactsMinAggregateOutputType = {
    id: string | null
    name: string | null
    role: $Enums.ContactRole | null
    phoneNumber: string | null
    email: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContactsMaxAggregateOutputType = {
    id: string | null
    name: string | null
    role: $Enums.ContactRole | null
    phoneNumber: string | null
    email: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContactsCountAggregateOutputType = {
    id: number
    name: number
    role: number
    phoneNumber: number
    email: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ContactsMinAggregateInputType = {
    id?: true
    name?: true
    role?: true
    phoneNumber?: true
    email?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContactsMaxAggregateInputType = {
    id?: true
    name?: true
    role?: true
    phoneNumber?: true
    email?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContactsCountAggregateInputType = {
    id?: true
    name?: true
    role?: true
    phoneNumber?: true
    email?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ContactsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contacts to aggregate.
     */
    where?: ContactsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactsOrderByWithRelationInput | ContactsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContactsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Contacts
    **/
    _count?: true | ContactsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContactsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContactsMaxAggregateInputType
  }

  export type GetContactsAggregateType<T extends ContactsAggregateArgs> = {
        [P in keyof T & keyof AggregateContacts]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContacts[P]>
      : GetScalarType<T[P], AggregateContacts[P]>
  }




  export type ContactsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactsWhereInput
    orderBy?: ContactsOrderByWithAggregationInput | ContactsOrderByWithAggregationInput[]
    by: ContactsScalarFieldEnum[] | ContactsScalarFieldEnum
    having?: ContactsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContactsCountAggregateInputType | true
    _min?: ContactsMinAggregateInputType
    _max?: ContactsMaxAggregateInputType
  }

  export type ContactsGroupByOutputType = {
    id: string
    name: string
    role: $Enums.ContactRole
    phoneNumber: string
    email: string | null
    createdAt: Date
    updatedAt: Date
    _count: ContactsCountAggregateOutputType | null
    _min: ContactsMinAggregateOutputType | null
    _max: ContactsMaxAggregateOutputType | null
  }

  type GetContactsGroupByPayload<T extends ContactsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContactsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContactsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContactsGroupByOutputType[P]>
            : GetScalarType<T[P], ContactsGroupByOutputType[P]>
        }
      >
    >


  export type ContactsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    role?: boolean
    phoneNumber?: boolean
    email?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["contacts"]>

  export type ContactsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    role?: boolean
    phoneNumber?: boolean
    email?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["contacts"]>

  export type ContactsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    role?: boolean
    phoneNumber?: boolean
    email?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["contacts"]>

  export type ContactsSelectScalar = {
    id?: boolean
    name?: boolean
    role?: boolean
    phoneNumber?: boolean
    email?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ContactsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "role" | "phoneNumber" | "email" | "createdAt" | "updatedAt", ExtArgs["result"]["contacts"]>

  export type $ContactsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Contacts"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      role: $Enums.ContactRole
      phoneNumber: string
      email: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["contacts"]>
    composites: {}
  }

  type ContactsGetPayload<S extends boolean | null | undefined | ContactsDefaultArgs> = $Result.GetResult<Prisma.$ContactsPayload, S>

  type ContactsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContactsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContactsCountAggregateInputType | true
    }

  export interface ContactsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Contacts'], meta: { name: 'Contacts' } }
    /**
     * Find zero or one Contacts that matches the filter.
     * @param {ContactsFindUniqueArgs} args - Arguments to find a Contacts
     * @example
     * // Get one Contacts
     * const contacts = await prisma.contacts.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContactsFindUniqueArgs>(args: SelectSubset<T, ContactsFindUniqueArgs<ExtArgs>>): Prisma__ContactsClient<$Result.GetResult<Prisma.$ContactsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Contacts that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContactsFindUniqueOrThrowArgs} args - Arguments to find a Contacts
     * @example
     * // Get one Contacts
     * const contacts = await prisma.contacts.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContactsFindUniqueOrThrowArgs>(args: SelectSubset<T, ContactsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContactsClient<$Result.GetResult<Prisma.$ContactsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Contacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactsFindFirstArgs} args - Arguments to find a Contacts
     * @example
     * // Get one Contacts
     * const contacts = await prisma.contacts.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContactsFindFirstArgs>(args?: SelectSubset<T, ContactsFindFirstArgs<ExtArgs>>): Prisma__ContactsClient<$Result.GetResult<Prisma.$ContactsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Contacts that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactsFindFirstOrThrowArgs} args - Arguments to find a Contacts
     * @example
     * // Get one Contacts
     * const contacts = await prisma.contacts.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContactsFindFirstOrThrowArgs>(args?: SelectSubset<T, ContactsFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContactsClient<$Result.GetResult<Prisma.$ContactsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Contacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contacts
     * const contacts = await prisma.contacts.findMany()
     * 
     * // Get first 10 Contacts
     * const contacts = await prisma.contacts.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contactsWithIdOnly = await prisma.contacts.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContactsFindManyArgs>(args?: SelectSubset<T, ContactsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Contacts.
     * @param {ContactsCreateArgs} args - Arguments to create a Contacts.
     * @example
     * // Create one Contacts
     * const Contacts = await prisma.contacts.create({
     *   data: {
     *     // ... data to create a Contacts
     *   }
     * })
     * 
     */
    create<T extends ContactsCreateArgs>(args: SelectSubset<T, ContactsCreateArgs<ExtArgs>>): Prisma__ContactsClient<$Result.GetResult<Prisma.$ContactsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Contacts.
     * @param {ContactsCreateManyArgs} args - Arguments to create many Contacts.
     * @example
     * // Create many Contacts
     * const contacts = await prisma.contacts.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContactsCreateManyArgs>(args?: SelectSubset<T, ContactsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Contacts and returns the data saved in the database.
     * @param {ContactsCreateManyAndReturnArgs} args - Arguments to create many Contacts.
     * @example
     * // Create many Contacts
     * const contacts = await prisma.contacts.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Contacts and only return the `id`
     * const contactsWithIdOnly = await prisma.contacts.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContactsCreateManyAndReturnArgs>(args?: SelectSubset<T, ContactsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Contacts.
     * @param {ContactsDeleteArgs} args - Arguments to delete one Contacts.
     * @example
     * // Delete one Contacts
     * const Contacts = await prisma.contacts.delete({
     *   where: {
     *     // ... filter to delete one Contacts
     *   }
     * })
     * 
     */
    delete<T extends ContactsDeleteArgs>(args: SelectSubset<T, ContactsDeleteArgs<ExtArgs>>): Prisma__ContactsClient<$Result.GetResult<Prisma.$ContactsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Contacts.
     * @param {ContactsUpdateArgs} args - Arguments to update one Contacts.
     * @example
     * // Update one Contacts
     * const contacts = await prisma.contacts.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContactsUpdateArgs>(args: SelectSubset<T, ContactsUpdateArgs<ExtArgs>>): Prisma__ContactsClient<$Result.GetResult<Prisma.$ContactsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Contacts.
     * @param {ContactsDeleteManyArgs} args - Arguments to filter Contacts to delete.
     * @example
     * // Delete a few Contacts
     * const { count } = await prisma.contacts.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContactsDeleteManyArgs>(args?: SelectSubset<T, ContactsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contacts
     * const contacts = await prisma.contacts.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContactsUpdateManyArgs>(args: SelectSubset<T, ContactsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contacts and returns the data updated in the database.
     * @param {ContactsUpdateManyAndReturnArgs} args - Arguments to update many Contacts.
     * @example
     * // Update many Contacts
     * const contacts = await prisma.contacts.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Contacts and only return the `id`
     * const contactsWithIdOnly = await prisma.contacts.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ContactsUpdateManyAndReturnArgs>(args: SelectSubset<T, ContactsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Contacts.
     * @param {ContactsUpsertArgs} args - Arguments to update or create a Contacts.
     * @example
     * // Update or create a Contacts
     * const contacts = await prisma.contacts.upsert({
     *   create: {
     *     // ... data to create a Contacts
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Contacts we want to update
     *   }
     * })
     */
    upsert<T extends ContactsUpsertArgs>(args: SelectSubset<T, ContactsUpsertArgs<ExtArgs>>): Prisma__ContactsClient<$Result.GetResult<Prisma.$ContactsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactsCountArgs} args - Arguments to filter Contacts to count.
     * @example
     * // Count the number of Contacts
     * const count = await prisma.contacts.count({
     *   where: {
     *     // ... the filter for the Contacts we want to count
     *   }
     * })
    **/
    count<T extends ContactsCountArgs>(
      args?: Subset<T, ContactsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContactsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContactsAggregateArgs>(args: Subset<T, ContactsAggregateArgs>): Prisma.PrismaPromise<GetContactsAggregateType<T>>

    /**
     * Group by Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContactsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContactsGroupByArgs['orderBy'] }
        : { orderBy?: ContactsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContactsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContactsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Contacts model
   */
  readonly fields: ContactsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Contacts.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContactsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Contacts model
   */
  interface ContactsFieldRefs {
    readonly id: FieldRef<"Contacts", 'String'>
    readonly name: FieldRef<"Contacts", 'String'>
    readonly role: FieldRef<"Contacts", 'ContactRole'>
    readonly phoneNumber: FieldRef<"Contacts", 'String'>
    readonly email: FieldRef<"Contacts", 'String'>
    readonly createdAt: FieldRef<"Contacts", 'DateTime'>
    readonly updatedAt: FieldRef<"Contacts", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Contacts findUnique
   */
  export type ContactsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contacts
     */
    select?: ContactsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contacts
     */
    omit?: ContactsOmit<ExtArgs> | null
    /**
     * Filter, which Contacts to fetch.
     */
    where: ContactsWhereUniqueInput
  }

  /**
   * Contacts findUniqueOrThrow
   */
  export type ContactsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contacts
     */
    select?: ContactsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contacts
     */
    omit?: ContactsOmit<ExtArgs> | null
    /**
     * Filter, which Contacts to fetch.
     */
    where: ContactsWhereUniqueInput
  }

  /**
   * Contacts findFirst
   */
  export type ContactsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contacts
     */
    select?: ContactsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contacts
     */
    omit?: ContactsOmit<ExtArgs> | null
    /**
     * Filter, which Contacts to fetch.
     */
    where?: ContactsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactsOrderByWithRelationInput | ContactsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contacts.
     */
    cursor?: ContactsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contacts.
     */
    distinct?: ContactsScalarFieldEnum | ContactsScalarFieldEnum[]
  }

  /**
   * Contacts findFirstOrThrow
   */
  export type ContactsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contacts
     */
    select?: ContactsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contacts
     */
    omit?: ContactsOmit<ExtArgs> | null
    /**
     * Filter, which Contacts to fetch.
     */
    where?: ContactsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactsOrderByWithRelationInput | ContactsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contacts.
     */
    cursor?: ContactsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contacts.
     */
    distinct?: ContactsScalarFieldEnum | ContactsScalarFieldEnum[]
  }

  /**
   * Contacts findMany
   */
  export type ContactsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contacts
     */
    select?: ContactsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contacts
     */
    omit?: ContactsOmit<ExtArgs> | null
    /**
     * Filter, which Contacts to fetch.
     */
    where?: ContactsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactsOrderByWithRelationInput | ContactsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Contacts.
     */
    cursor?: ContactsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    distinct?: ContactsScalarFieldEnum | ContactsScalarFieldEnum[]
  }

  /**
   * Contacts create
   */
  export type ContactsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contacts
     */
    select?: ContactsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contacts
     */
    omit?: ContactsOmit<ExtArgs> | null
    /**
     * The data needed to create a Contacts.
     */
    data: XOR<ContactsCreateInput, ContactsUncheckedCreateInput>
  }

  /**
   * Contacts createMany
   */
  export type ContactsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Contacts.
     */
    data: ContactsCreateManyInput | ContactsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Contacts createManyAndReturn
   */
  export type ContactsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contacts
     */
    select?: ContactsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Contacts
     */
    omit?: ContactsOmit<ExtArgs> | null
    /**
     * The data used to create many Contacts.
     */
    data: ContactsCreateManyInput | ContactsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Contacts update
   */
  export type ContactsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contacts
     */
    select?: ContactsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contacts
     */
    omit?: ContactsOmit<ExtArgs> | null
    /**
     * The data needed to update a Contacts.
     */
    data: XOR<ContactsUpdateInput, ContactsUncheckedUpdateInput>
    /**
     * Choose, which Contacts to update.
     */
    where: ContactsWhereUniqueInput
  }

  /**
   * Contacts updateMany
   */
  export type ContactsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Contacts.
     */
    data: XOR<ContactsUpdateManyMutationInput, ContactsUncheckedUpdateManyInput>
    /**
     * Filter which Contacts to update
     */
    where?: ContactsWhereInput
    /**
     * Limit how many Contacts to update.
     */
    limit?: number
  }

  /**
   * Contacts updateManyAndReturn
   */
  export type ContactsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contacts
     */
    select?: ContactsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Contacts
     */
    omit?: ContactsOmit<ExtArgs> | null
    /**
     * The data used to update Contacts.
     */
    data: XOR<ContactsUpdateManyMutationInput, ContactsUncheckedUpdateManyInput>
    /**
     * Filter which Contacts to update
     */
    where?: ContactsWhereInput
    /**
     * Limit how many Contacts to update.
     */
    limit?: number
  }

  /**
   * Contacts upsert
   */
  export type ContactsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contacts
     */
    select?: ContactsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contacts
     */
    omit?: ContactsOmit<ExtArgs> | null
    /**
     * The filter to search for the Contacts to update in case it exists.
     */
    where: ContactsWhereUniqueInput
    /**
     * In case the Contacts found by the `where` argument doesn't exist, create a new Contacts with this data.
     */
    create: XOR<ContactsCreateInput, ContactsUncheckedCreateInput>
    /**
     * In case the Contacts was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContactsUpdateInput, ContactsUncheckedUpdateInput>
  }

  /**
   * Contacts delete
   */
  export type ContactsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contacts
     */
    select?: ContactsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contacts
     */
    omit?: ContactsOmit<ExtArgs> | null
    /**
     * Filter which Contacts to delete.
     */
    where: ContactsWhereUniqueInput
  }

  /**
   * Contacts deleteMany
   */
  export type ContactsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contacts to delete
     */
    where?: ContactsWhereInput
    /**
     * Limit how many Contacts to delete.
     */
    limit?: number
  }

  /**
   * Contacts without action
   */
  export type ContactsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contacts
     */
    select?: ContactsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contacts
     */
    omit?: ContactsOmit<ExtArgs> | null
  }


  /**
   * Model SecurityReports
   */

  export type AggregateSecurityReports = {
    _count: SecurityReportsCountAggregateOutputType | null
    _min: SecurityReportsMinAggregateOutputType | null
    _max: SecurityReportsMaxAggregateOutputType | null
  }

  export type SecurityReportsMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    location: string | null
    incidentDate: Date | null
    status: $Enums.MaintenanceStatus | null
    isPublished: boolean | null
    employeeId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SecurityReportsMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    location: string | null
    incidentDate: Date | null
    status: $Enums.MaintenanceStatus | null
    isPublished: boolean | null
    employeeId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SecurityReportsCountAggregateOutputType = {
    id: number
    title: number
    description: number
    location: number
    incidentDate: number
    status: number
    isPublished: number
    employeeId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SecurityReportsMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    location?: true
    incidentDate?: true
    status?: true
    isPublished?: true
    employeeId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SecurityReportsMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    location?: true
    incidentDate?: true
    status?: true
    isPublished?: true
    employeeId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SecurityReportsCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    location?: true
    incidentDate?: true
    status?: true
    isPublished?: true
    employeeId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SecurityReportsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SecurityReports to aggregate.
     */
    where?: SecurityReportsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SecurityReports to fetch.
     */
    orderBy?: SecurityReportsOrderByWithRelationInput | SecurityReportsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SecurityReportsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SecurityReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SecurityReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SecurityReports
    **/
    _count?: true | SecurityReportsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SecurityReportsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SecurityReportsMaxAggregateInputType
  }

  export type GetSecurityReportsAggregateType<T extends SecurityReportsAggregateArgs> = {
        [P in keyof T & keyof AggregateSecurityReports]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSecurityReports[P]>
      : GetScalarType<T[P], AggregateSecurityReports[P]>
  }




  export type SecurityReportsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SecurityReportsWhereInput
    orderBy?: SecurityReportsOrderByWithAggregationInput | SecurityReportsOrderByWithAggregationInput[]
    by: SecurityReportsScalarFieldEnum[] | SecurityReportsScalarFieldEnum
    having?: SecurityReportsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SecurityReportsCountAggregateInputType | true
    _min?: SecurityReportsMinAggregateInputType
    _max?: SecurityReportsMaxAggregateInputType
  }

  export type SecurityReportsGroupByOutputType = {
    id: string
    title: string
    description: string
    location: string
    incidentDate: Date
    status: $Enums.MaintenanceStatus
    isPublished: boolean
    employeeId: string
    createdAt: Date
    updatedAt: Date
    _count: SecurityReportsCountAggregateOutputType | null
    _min: SecurityReportsMinAggregateOutputType | null
    _max: SecurityReportsMaxAggregateOutputType | null
  }

  type GetSecurityReportsGroupByPayload<T extends SecurityReportsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SecurityReportsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SecurityReportsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SecurityReportsGroupByOutputType[P]>
            : GetScalarType<T[P], SecurityReportsGroupByOutputType[P]>
        }
      >
    >


  export type SecurityReportsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    location?: boolean
    incidentDate?: boolean
    status?: boolean
    isPublished?: boolean
    employeeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | EmployeesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["securityReports"]>

  export type SecurityReportsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    location?: boolean
    incidentDate?: boolean
    status?: boolean
    isPublished?: boolean
    employeeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | EmployeesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["securityReports"]>

  export type SecurityReportsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    location?: boolean
    incidentDate?: boolean
    status?: boolean
    isPublished?: boolean
    employeeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | EmployeesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["securityReports"]>

  export type SecurityReportsSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    location?: boolean
    incidentDate?: boolean
    status?: boolean
    isPublished?: boolean
    employeeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SecurityReportsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "location" | "incidentDate" | "status" | "isPublished" | "employeeId" | "createdAt" | "updatedAt", ExtArgs["result"]["securityReports"]>
  export type SecurityReportsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeesDefaultArgs<ExtArgs>
  }
  export type SecurityReportsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeesDefaultArgs<ExtArgs>
  }
  export type SecurityReportsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeesDefaultArgs<ExtArgs>
  }

  export type $SecurityReportsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SecurityReports"
    objects: {
      employee: Prisma.$EmployeesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string
      location: string
      incidentDate: Date
      status: $Enums.MaintenanceStatus
      isPublished: boolean
      employeeId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["securityReports"]>
    composites: {}
  }

  type SecurityReportsGetPayload<S extends boolean | null | undefined | SecurityReportsDefaultArgs> = $Result.GetResult<Prisma.$SecurityReportsPayload, S>

  type SecurityReportsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SecurityReportsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SecurityReportsCountAggregateInputType | true
    }

  export interface SecurityReportsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SecurityReports'], meta: { name: 'SecurityReports' } }
    /**
     * Find zero or one SecurityReports that matches the filter.
     * @param {SecurityReportsFindUniqueArgs} args - Arguments to find a SecurityReports
     * @example
     * // Get one SecurityReports
     * const securityReports = await prisma.securityReports.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SecurityReportsFindUniqueArgs>(args: SelectSubset<T, SecurityReportsFindUniqueArgs<ExtArgs>>): Prisma__SecurityReportsClient<$Result.GetResult<Prisma.$SecurityReportsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SecurityReports that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SecurityReportsFindUniqueOrThrowArgs} args - Arguments to find a SecurityReports
     * @example
     * // Get one SecurityReports
     * const securityReports = await prisma.securityReports.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SecurityReportsFindUniqueOrThrowArgs>(args: SelectSubset<T, SecurityReportsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SecurityReportsClient<$Result.GetResult<Prisma.$SecurityReportsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SecurityReports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityReportsFindFirstArgs} args - Arguments to find a SecurityReports
     * @example
     * // Get one SecurityReports
     * const securityReports = await prisma.securityReports.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SecurityReportsFindFirstArgs>(args?: SelectSubset<T, SecurityReportsFindFirstArgs<ExtArgs>>): Prisma__SecurityReportsClient<$Result.GetResult<Prisma.$SecurityReportsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SecurityReports that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityReportsFindFirstOrThrowArgs} args - Arguments to find a SecurityReports
     * @example
     * // Get one SecurityReports
     * const securityReports = await prisma.securityReports.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SecurityReportsFindFirstOrThrowArgs>(args?: SelectSubset<T, SecurityReportsFindFirstOrThrowArgs<ExtArgs>>): Prisma__SecurityReportsClient<$Result.GetResult<Prisma.$SecurityReportsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SecurityReports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityReportsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SecurityReports
     * const securityReports = await prisma.securityReports.findMany()
     * 
     * // Get first 10 SecurityReports
     * const securityReports = await prisma.securityReports.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const securityReportsWithIdOnly = await prisma.securityReports.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SecurityReportsFindManyArgs>(args?: SelectSubset<T, SecurityReportsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SecurityReportsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SecurityReports.
     * @param {SecurityReportsCreateArgs} args - Arguments to create a SecurityReports.
     * @example
     * // Create one SecurityReports
     * const SecurityReports = await prisma.securityReports.create({
     *   data: {
     *     // ... data to create a SecurityReports
     *   }
     * })
     * 
     */
    create<T extends SecurityReportsCreateArgs>(args: SelectSubset<T, SecurityReportsCreateArgs<ExtArgs>>): Prisma__SecurityReportsClient<$Result.GetResult<Prisma.$SecurityReportsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SecurityReports.
     * @param {SecurityReportsCreateManyArgs} args - Arguments to create many SecurityReports.
     * @example
     * // Create many SecurityReports
     * const securityReports = await prisma.securityReports.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SecurityReportsCreateManyArgs>(args?: SelectSubset<T, SecurityReportsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SecurityReports and returns the data saved in the database.
     * @param {SecurityReportsCreateManyAndReturnArgs} args - Arguments to create many SecurityReports.
     * @example
     * // Create many SecurityReports
     * const securityReports = await prisma.securityReports.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SecurityReports and only return the `id`
     * const securityReportsWithIdOnly = await prisma.securityReports.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SecurityReportsCreateManyAndReturnArgs>(args?: SelectSubset<T, SecurityReportsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SecurityReportsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SecurityReports.
     * @param {SecurityReportsDeleteArgs} args - Arguments to delete one SecurityReports.
     * @example
     * // Delete one SecurityReports
     * const SecurityReports = await prisma.securityReports.delete({
     *   where: {
     *     // ... filter to delete one SecurityReports
     *   }
     * })
     * 
     */
    delete<T extends SecurityReportsDeleteArgs>(args: SelectSubset<T, SecurityReportsDeleteArgs<ExtArgs>>): Prisma__SecurityReportsClient<$Result.GetResult<Prisma.$SecurityReportsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SecurityReports.
     * @param {SecurityReportsUpdateArgs} args - Arguments to update one SecurityReports.
     * @example
     * // Update one SecurityReports
     * const securityReports = await prisma.securityReports.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SecurityReportsUpdateArgs>(args: SelectSubset<T, SecurityReportsUpdateArgs<ExtArgs>>): Prisma__SecurityReportsClient<$Result.GetResult<Prisma.$SecurityReportsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SecurityReports.
     * @param {SecurityReportsDeleteManyArgs} args - Arguments to filter SecurityReports to delete.
     * @example
     * // Delete a few SecurityReports
     * const { count } = await prisma.securityReports.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SecurityReportsDeleteManyArgs>(args?: SelectSubset<T, SecurityReportsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SecurityReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityReportsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SecurityReports
     * const securityReports = await prisma.securityReports.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SecurityReportsUpdateManyArgs>(args: SelectSubset<T, SecurityReportsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SecurityReports and returns the data updated in the database.
     * @param {SecurityReportsUpdateManyAndReturnArgs} args - Arguments to update many SecurityReports.
     * @example
     * // Update many SecurityReports
     * const securityReports = await prisma.securityReports.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SecurityReports and only return the `id`
     * const securityReportsWithIdOnly = await prisma.securityReports.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SecurityReportsUpdateManyAndReturnArgs>(args: SelectSubset<T, SecurityReportsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SecurityReportsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SecurityReports.
     * @param {SecurityReportsUpsertArgs} args - Arguments to update or create a SecurityReports.
     * @example
     * // Update or create a SecurityReports
     * const securityReports = await prisma.securityReports.upsert({
     *   create: {
     *     // ... data to create a SecurityReports
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SecurityReports we want to update
     *   }
     * })
     */
    upsert<T extends SecurityReportsUpsertArgs>(args: SelectSubset<T, SecurityReportsUpsertArgs<ExtArgs>>): Prisma__SecurityReportsClient<$Result.GetResult<Prisma.$SecurityReportsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SecurityReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityReportsCountArgs} args - Arguments to filter SecurityReports to count.
     * @example
     * // Count the number of SecurityReports
     * const count = await prisma.securityReports.count({
     *   where: {
     *     // ... the filter for the SecurityReports we want to count
     *   }
     * })
    **/
    count<T extends SecurityReportsCountArgs>(
      args?: Subset<T, SecurityReportsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SecurityReportsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SecurityReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityReportsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SecurityReportsAggregateArgs>(args: Subset<T, SecurityReportsAggregateArgs>): Prisma.PrismaPromise<GetSecurityReportsAggregateType<T>>

    /**
     * Group by SecurityReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityReportsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SecurityReportsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SecurityReportsGroupByArgs['orderBy'] }
        : { orderBy?: SecurityReportsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SecurityReportsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSecurityReportsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SecurityReports model
   */
  readonly fields: SecurityReportsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SecurityReports.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SecurityReportsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends EmployeesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeesDefaultArgs<ExtArgs>>): Prisma__EmployeesClient<$Result.GetResult<Prisma.$EmployeesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SecurityReports model
   */
  interface SecurityReportsFieldRefs {
    readonly id: FieldRef<"SecurityReports", 'String'>
    readonly title: FieldRef<"SecurityReports", 'String'>
    readonly description: FieldRef<"SecurityReports", 'String'>
    readonly location: FieldRef<"SecurityReports", 'String'>
    readonly incidentDate: FieldRef<"SecurityReports", 'DateTime'>
    readonly status: FieldRef<"SecurityReports", 'MaintenanceStatus'>
    readonly isPublished: FieldRef<"SecurityReports", 'Boolean'>
    readonly employeeId: FieldRef<"SecurityReports", 'String'>
    readonly createdAt: FieldRef<"SecurityReports", 'DateTime'>
    readonly updatedAt: FieldRef<"SecurityReports", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SecurityReports findUnique
   */
  export type SecurityReportsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityReports
     */
    select?: SecurityReportsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityReports
     */
    omit?: SecurityReportsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityReportsInclude<ExtArgs> | null
    /**
     * Filter, which SecurityReports to fetch.
     */
    where: SecurityReportsWhereUniqueInput
  }

  /**
   * SecurityReports findUniqueOrThrow
   */
  export type SecurityReportsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityReports
     */
    select?: SecurityReportsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityReports
     */
    omit?: SecurityReportsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityReportsInclude<ExtArgs> | null
    /**
     * Filter, which SecurityReports to fetch.
     */
    where: SecurityReportsWhereUniqueInput
  }

  /**
   * SecurityReports findFirst
   */
  export type SecurityReportsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityReports
     */
    select?: SecurityReportsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityReports
     */
    omit?: SecurityReportsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityReportsInclude<ExtArgs> | null
    /**
     * Filter, which SecurityReports to fetch.
     */
    where?: SecurityReportsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SecurityReports to fetch.
     */
    orderBy?: SecurityReportsOrderByWithRelationInput | SecurityReportsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SecurityReports.
     */
    cursor?: SecurityReportsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SecurityReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SecurityReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SecurityReports.
     */
    distinct?: SecurityReportsScalarFieldEnum | SecurityReportsScalarFieldEnum[]
  }

  /**
   * SecurityReports findFirstOrThrow
   */
  export type SecurityReportsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityReports
     */
    select?: SecurityReportsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityReports
     */
    omit?: SecurityReportsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityReportsInclude<ExtArgs> | null
    /**
     * Filter, which SecurityReports to fetch.
     */
    where?: SecurityReportsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SecurityReports to fetch.
     */
    orderBy?: SecurityReportsOrderByWithRelationInput | SecurityReportsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SecurityReports.
     */
    cursor?: SecurityReportsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SecurityReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SecurityReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SecurityReports.
     */
    distinct?: SecurityReportsScalarFieldEnum | SecurityReportsScalarFieldEnum[]
  }

  /**
   * SecurityReports findMany
   */
  export type SecurityReportsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityReports
     */
    select?: SecurityReportsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityReports
     */
    omit?: SecurityReportsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityReportsInclude<ExtArgs> | null
    /**
     * Filter, which SecurityReports to fetch.
     */
    where?: SecurityReportsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SecurityReports to fetch.
     */
    orderBy?: SecurityReportsOrderByWithRelationInput | SecurityReportsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SecurityReports.
     */
    cursor?: SecurityReportsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SecurityReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SecurityReports.
     */
    skip?: number
    distinct?: SecurityReportsScalarFieldEnum | SecurityReportsScalarFieldEnum[]
  }

  /**
   * SecurityReports create
   */
  export type SecurityReportsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityReports
     */
    select?: SecurityReportsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityReports
     */
    omit?: SecurityReportsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityReportsInclude<ExtArgs> | null
    /**
     * The data needed to create a SecurityReports.
     */
    data: XOR<SecurityReportsCreateInput, SecurityReportsUncheckedCreateInput>
  }

  /**
   * SecurityReports createMany
   */
  export type SecurityReportsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SecurityReports.
     */
    data: SecurityReportsCreateManyInput | SecurityReportsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SecurityReports createManyAndReturn
   */
  export type SecurityReportsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityReports
     */
    select?: SecurityReportsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityReports
     */
    omit?: SecurityReportsOmit<ExtArgs> | null
    /**
     * The data used to create many SecurityReports.
     */
    data: SecurityReportsCreateManyInput | SecurityReportsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityReportsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SecurityReports update
   */
  export type SecurityReportsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityReports
     */
    select?: SecurityReportsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityReports
     */
    omit?: SecurityReportsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityReportsInclude<ExtArgs> | null
    /**
     * The data needed to update a SecurityReports.
     */
    data: XOR<SecurityReportsUpdateInput, SecurityReportsUncheckedUpdateInput>
    /**
     * Choose, which SecurityReports to update.
     */
    where: SecurityReportsWhereUniqueInput
  }

  /**
   * SecurityReports updateMany
   */
  export type SecurityReportsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SecurityReports.
     */
    data: XOR<SecurityReportsUpdateManyMutationInput, SecurityReportsUncheckedUpdateManyInput>
    /**
     * Filter which SecurityReports to update
     */
    where?: SecurityReportsWhereInput
    /**
     * Limit how many SecurityReports to update.
     */
    limit?: number
  }

  /**
   * SecurityReports updateManyAndReturn
   */
  export type SecurityReportsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityReports
     */
    select?: SecurityReportsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityReports
     */
    omit?: SecurityReportsOmit<ExtArgs> | null
    /**
     * The data used to update SecurityReports.
     */
    data: XOR<SecurityReportsUpdateManyMutationInput, SecurityReportsUncheckedUpdateManyInput>
    /**
     * Filter which SecurityReports to update
     */
    where?: SecurityReportsWhereInput
    /**
     * Limit how many SecurityReports to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityReportsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SecurityReports upsert
   */
  export type SecurityReportsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityReports
     */
    select?: SecurityReportsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityReports
     */
    omit?: SecurityReportsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityReportsInclude<ExtArgs> | null
    /**
     * The filter to search for the SecurityReports to update in case it exists.
     */
    where: SecurityReportsWhereUniqueInput
    /**
     * In case the SecurityReports found by the `where` argument doesn't exist, create a new SecurityReports with this data.
     */
    create: XOR<SecurityReportsCreateInput, SecurityReportsUncheckedCreateInput>
    /**
     * In case the SecurityReports was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SecurityReportsUpdateInput, SecurityReportsUncheckedUpdateInput>
  }

  /**
   * SecurityReports delete
   */
  export type SecurityReportsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityReports
     */
    select?: SecurityReportsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityReports
     */
    omit?: SecurityReportsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityReportsInclude<ExtArgs> | null
    /**
     * Filter which SecurityReports to delete.
     */
    where: SecurityReportsWhereUniqueInput
  }

  /**
   * SecurityReports deleteMany
   */
  export type SecurityReportsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SecurityReports to delete
     */
    where?: SecurityReportsWhereInput
    /**
     * Limit how many SecurityReports to delete.
     */
    limit?: number
  }

  /**
   * SecurityReports without action
   */
  export type SecurityReportsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityReports
     */
    select?: SecurityReportsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityReports
     */
    omit?: SecurityReportsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityReportsInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UsersScalarFieldEnum: {
    id: 'id',
    fullName: 'fullName',
    firstName: 'firstName',
    lastName: 'lastName',
    username: 'username',
    dateOfBirth: 'dateOfBirth',
    contactNumber: 'contactNumber',
    primaryEmail: 'primaryEmail',
    secondaryEmail: 'secondaryEmail',
    password: 'password',
    sessionToken: 'sessionToken',
    emailVerificationToken: 'emailVerificationToken',
    passwordResetToken: 'passwordResetToken',
    role: 'role',
    gender: 'gender',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UsersScalarFieldEnum = (typeof UsersScalarFieldEnum)[keyof typeof UsersScalarFieldEnum]


  export const ResidentsScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    emergencyContactName: 'emergencyContactName',
    emergencyContactNumber: 'emergencyContactNumber',
    movedInDate: 'movedInDate',
    movedOutDate: 'movedOutDate',
    residentStatus: 'residentStatus',
    unitId: 'unitId',
    kprPaymentAmount: 'kprPaymentAmount',
    kprDueDate: 'kprDueDate',
    isKprPaid: 'isKprPaid',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ResidentsScalarFieldEnum = (typeof ResidentsScalarFieldEnum)[keyof typeof ResidentsScalarFieldEnum]


  export const EmployeesScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    employeeNumberId: 'employeeNumberId',
    hireDate: 'hireDate',
    employeePosition: 'employeePosition',
    workingHours: 'workingHours',
    salary: 'salary',
    bonus: 'bonus',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EmployeesScalarFieldEnum = (typeof EmployeesScalarFieldEnum)[keyof typeof EmployeesScalarFieldEnum]


  export const ComplaintsScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    category: 'category',
    status: 'status',
    images: 'images',
    submittedAt: 'submittedAt',
    resolvedAt: 'resolvedAt',
    resolutionDetails: 'resolutionDetails',
    residentId: 'residentId',
    employeeId: 'employeeId',
    unitId: 'unitId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ComplaintsScalarFieldEnum = (typeof ComplaintsScalarFieldEnum)[keyof typeof ComplaintsScalarFieldEnum]


  export const AnnouncementsScalarFieldEnum: {
    id: 'id',
    title: 'title',
    content: 'content',
    attachments: 'attachments',
    publishDate: 'publishDate',
    expiryDate: 'expiryDate',
    employeeId: 'employeeId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AnnouncementsScalarFieldEnum = (typeof AnnouncementsScalarFieldEnum)[keyof typeof AnnouncementsScalarFieldEnum]


  export const ForumPostsScalarFieldEnum: {
    id: 'id',
    title: 'title',
    content: 'content',
    attachments: 'attachments',
    authorRole: 'authorRole',
    userId: 'userId',
    publishedAt: 'publishedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ForumPostsScalarFieldEnum = (typeof ForumPostsScalarFieldEnum)[keyof typeof ForumPostsScalarFieldEnum]


  export const PostTagsScalarFieldEnum: {
    id: 'id',
    tagName: 'tagName',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PostTagsScalarFieldEnum = (typeof PostTagsScalarFieldEnum)[keyof typeof PostTagsScalarFieldEnum]


  export const ForumCommentsScalarFieldEnum: {
    id: 'id',
    content: 'content',
    userId: 'userId',
    postId: 'postId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ForumCommentsScalarFieldEnum = (typeof ForumCommentsScalarFieldEnum)[keyof typeof ForumCommentsScalarFieldEnum]


  export const UnitsScalarFieldEnum: {
    id: 'id',
    unitNumber: 'unitNumber',
    buildingName: 'buildingName',
    floorNumber: 'floorNumber',
    numberOfRooms: 'numberOfRooms',
    priceSale: 'priceSale',
    squareFootage: 'squareFootage',
    location: 'location',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UnitsScalarFieldEnum = (typeof UnitsScalarFieldEnum)[keyof typeof UnitsScalarFieldEnum]


  export const BillsScalarFieldEnum: {
    id: 'id',
    amount: 'amount',
    type: 'type',
    dueDate: 'dueDate',
    isPaid: 'isPaid',
    unitId: 'unitId',
    employeeId: 'employeeId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BillsScalarFieldEnum = (typeof BillsScalarFieldEnum)[keyof typeof BillsScalarFieldEnum]


  export const PaymentsScalarFieldEnum: {
    id: 'id',
    amount: 'amount',
    paymentDate: 'paymentDate',
    paymentMethod: 'paymentMethod',
    status: 'status',
    residentId: 'residentId',
    unitId: 'unitId',
    processedByEmployeeId: 'processedByEmployeeId',
    billId: 'billId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PaymentsScalarFieldEnum = (typeof PaymentsScalarFieldEnum)[keyof typeof PaymentsScalarFieldEnum]


  export const ContactsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    role: 'role',
    phoneNumber: 'phoneNumber',
    email: 'email',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ContactsScalarFieldEnum = (typeof ContactsScalarFieldEnum)[keyof typeof ContactsScalarFieldEnum]


  export const SecurityReportsScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    location: 'location',
    incidentDate: 'incidentDate',
    status: 'status',
    isPublished: 'isPublished',
    employeeId: 'employeeId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SecurityReportsScalarFieldEnum = (typeof SecurityReportsScalarFieldEnum)[keyof typeof SecurityReportsScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'Gender'
   */
  export type EnumGenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Gender'>
    


  /**
   * Reference to a field of type 'Gender[]'
   */
  export type ListEnumGenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Gender[]'>
    


  /**
   * Reference to a field of type 'ResidentStatus'
   */
  export type EnumResidentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ResidentStatus'>
    


  /**
   * Reference to a field of type 'ResidentStatus[]'
   */
  export type ListEnumResidentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ResidentStatus[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'EmployeeRole'
   */
  export type EnumEmployeeRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EmployeeRole'>
    


  /**
   * Reference to a field of type 'EmployeeRole[]'
   */
  export type ListEnumEmployeeRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EmployeeRole[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'MaintenanceCategory'
   */
  export type EnumMaintenanceCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MaintenanceCategory'>
    


  /**
   * Reference to a field of type 'MaintenanceCategory[]'
   */
  export type ListEnumMaintenanceCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MaintenanceCategory[]'>
    


  /**
   * Reference to a field of type 'ComplaintStatus'
   */
  export type EnumComplaintStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ComplaintStatus'>
    


  /**
   * Reference to a field of type 'ComplaintStatus[]'
   */
  export type ListEnumComplaintStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ComplaintStatus[]'>
    


  /**
   * Reference to a field of type 'UnitStatus'
   */
  export type EnumUnitStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UnitStatus'>
    


  /**
   * Reference to a field of type 'UnitStatus[]'
   */
  export type ListEnumUnitStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UnitStatus[]'>
    


  /**
   * Reference to a field of type 'PaymentType'
   */
  export type EnumPaymentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentType'>
    


  /**
   * Reference to a field of type 'PaymentType[]'
   */
  export type ListEnumPaymentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentType[]'>
    


  /**
   * Reference to a field of type 'PaymentMethod'
   */
  export type EnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod'>
    


  /**
   * Reference to a field of type 'PaymentMethod[]'
   */
  export type ListEnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod[]'>
    


  /**
   * Reference to a field of type 'PaymentStatus'
   */
  export type EnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus'>
    


  /**
   * Reference to a field of type 'PaymentStatus[]'
   */
  export type ListEnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus[]'>
    


  /**
   * Reference to a field of type 'ContactRole'
   */
  export type EnumContactRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContactRole'>
    


  /**
   * Reference to a field of type 'ContactRole[]'
   */
  export type ListEnumContactRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContactRole[]'>
    


  /**
   * Reference to a field of type 'MaintenanceStatus'
   */
  export type EnumMaintenanceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MaintenanceStatus'>
    


  /**
   * Reference to a field of type 'MaintenanceStatus[]'
   */
  export type ListEnumMaintenanceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MaintenanceStatus[]'>
    
  /**
   * Deep Input Types
   */


  export type UsersWhereInput = {
    AND?: UsersWhereInput | UsersWhereInput[]
    OR?: UsersWhereInput[]
    NOT?: UsersWhereInput | UsersWhereInput[]
    id?: UuidFilter<"Users"> | string
    fullName?: StringFilter<"Users"> | string
    firstName?: StringFilter<"Users"> | string
    lastName?: StringFilter<"Users"> | string
    username?: StringFilter<"Users"> | string
    dateOfBirth?: DateTimeNullableFilter<"Users"> | Date | string | null
    contactNumber?: StringNullableFilter<"Users"> | string | null
    primaryEmail?: StringFilter<"Users"> | string
    secondaryEmail?: StringNullableFilter<"Users"> | string | null
    password?: StringFilter<"Users"> | string
    sessionToken?: StringNullableFilter<"Users"> | string | null
    emailVerificationToken?: StringNullableFilter<"Users"> | string | null
    passwordResetToken?: StringNullableFilter<"Users"> | string | null
    role?: EnumUserRoleFilter<"Users"> | $Enums.UserRole
    gender?: EnumGenderNullableFilter<"Users"> | $Enums.Gender | null
    createdAt?: DateTimeFilter<"Users"> | Date | string
    updatedAt?: DateTimeFilter<"Users"> | Date | string
    Resident?: XOR<ResidentsNullableScalarRelationFilter, ResidentsWhereInput> | null
    Employee?: XOR<EmployeesNullableScalarRelationFilter, EmployeesWhereInput> | null
    ForumPosts?: ForumPostsListRelationFilter
    ForumComments?: ForumCommentsListRelationFilter
  }

  export type UsersOrderByWithRelationInput = {
    id?: SortOrder
    fullName?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    username?: SortOrder
    dateOfBirth?: SortOrderInput | SortOrder
    contactNumber?: SortOrderInput | SortOrder
    primaryEmail?: SortOrder
    secondaryEmail?: SortOrderInput | SortOrder
    password?: SortOrder
    sessionToken?: SortOrderInput | SortOrder
    emailVerificationToken?: SortOrderInput | SortOrder
    passwordResetToken?: SortOrderInput | SortOrder
    role?: SortOrder
    gender?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Resident?: ResidentsOrderByWithRelationInput
    Employee?: EmployeesOrderByWithRelationInput
    ForumPosts?: ForumPostsOrderByRelationAggregateInput
    ForumComments?: ForumCommentsOrderByRelationAggregateInput
  }

  export type UsersWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    username?: string
    primaryEmail?: string
    secondaryEmail?: string
    sessionToken?: string
    emailVerificationToken?: string
    passwordResetToken?: string
    AND?: UsersWhereInput | UsersWhereInput[]
    OR?: UsersWhereInput[]
    NOT?: UsersWhereInput | UsersWhereInput[]
    fullName?: StringFilter<"Users"> | string
    firstName?: StringFilter<"Users"> | string
    lastName?: StringFilter<"Users"> | string
    dateOfBirth?: DateTimeNullableFilter<"Users"> | Date | string | null
    contactNumber?: StringNullableFilter<"Users"> | string | null
    password?: StringFilter<"Users"> | string
    role?: EnumUserRoleFilter<"Users"> | $Enums.UserRole
    gender?: EnumGenderNullableFilter<"Users"> | $Enums.Gender | null
    createdAt?: DateTimeFilter<"Users"> | Date | string
    updatedAt?: DateTimeFilter<"Users"> | Date | string
    Resident?: XOR<ResidentsNullableScalarRelationFilter, ResidentsWhereInput> | null
    Employee?: XOR<EmployeesNullableScalarRelationFilter, EmployeesWhereInput> | null
    ForumPosts?: ForumPostsListRelationFilter
    ForumComments?: ForumCommentsListRelationFilter
  }, "id" | "username" | "primaryEmail" | "secondaryEmail" | "sessionToken" | "emailVerificationToken" | "passwordResetToken">

  export type UsersOrderByWithAggregationInput = {
    id?: SortOrder
    fullName?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    username?: SortOrder
    dateOfBirth?: SortOrderInput | SortOrder
    contactNumber?: SortOrderInput | SortOrder
    primaryEmail?: SortOrder
    secondaryEmail?: SortOrderInput | SortOrder
    password?: SortOrder
    sessionToken?: SortOrderInput | SortOrder
    emailVerificationToken?: SortOrderInput | SortOrder
    passwordResetToken?: SortOrderInput | SortOrder
    role?: SortOrder
    gender?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UsersCountOrderByAggregateInput
    _max?: UsersMaxOrderByAggregateInput
    _min?: UsersMinOrderByAggregateInput
  }

  export type UsersScalarWhereWithAggregatesInput = {
    AND?: UsersScalarWhereWithAggregatesInput | UsersScalarWhereWithAggregatesInput[]
    OR?: UsersScalarWhereWithAggregatesInput[]
    NOT?: UsersScalarWhereWithAggregatesInput | UsersScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Users"> | string
    fullName?: StringWithAggregatesFilter<"Users"> | string
    firstName?: StringWithAggregatesFilter<"Users"> | string
    lastName?: StringWithAggregatesFilter<"Users"> | string
    username?: StringWithAggregatesFilter<"Users"> | string
    dateOfBirth?: DateTimeNullableWithAggregatesFilter<"Users"> | Date | string | null
    contactNumber?: StringNullableWithAggregatesFilter<"Users"> | string | null
    primaryEmail?: StringWithAggregatesFilter<"Users"> | string
    secondaryEmail?: StringNullableWithAggregatesFilter<"Users"> | string | null
    password?: StringWithAggregatesFilter<"Users"> | string
    sessionToken?: StringNullableWithAggregatesFilter<"Users"> | string | null
    emailVerificationToken?: StringNullableWithAggregatesFilter<"Users"> | string | null
    passwordResetToken?: StringNullableWithAggregatesFilter<"Users"> | string | null
    role?: EnumUserRoleWithAggregatesFilter<"Users"> | $Enums.UserRole
    gender?: EnumGenderNullableWithAggregatesFilter<"Users"> | $Enums.Gender | null
    createdAt?: DateTimeWithAggregatesFilter<"Users"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Users"> | Date | string
  }

  export type ResidentsWhereInput = {
    AND?: ResidentsWhereInput | ResidentsWhereInput[]
    OR?: ResidentsWhereInput[]
    NOT?: ResidentsWhereInput | ResidentsWhereInput[]
    id?: UuidFilter<"Residents"> | string
    userId?: UuidFilter<"Residents"> | string
    emergencyContactName?: StringNullableFilter<"Residents"> | string | null
    emergencyContactNumber?: StringNullableFilter<"Residents"> | string | null
    movedInDate?: DateTimeFilter<"Residents"> | Date | string
    movedOutDate?: DateTimeNullableFilter<"Residents"> | Date | string | null
    residentStatus?: EnumResidentStatusNullableFilter<"Residents"> | $Enums.ResidentStatus | null
    unitId?: UuidNullableFilter<"Residents"> | string | null
    kprPaymentAmount?: FloatNullableFilter<"Residents"> | number | null
    kprDueDate?: DateTimeNullableFilter<"Residents"> | Date | string | null
    isKprPaid?: BoolNullableFilter<"Residents"> | boolean | null
    createdAt?: DateTimeFilter<"Residents"> | Date | string
    updatedAt?: DateTimeFilter<"Residents"> | Date | string
    user?: XOR<UsersScalarRelationFilter, UsersWhereInput>
    unit?: XOR<UnitsNullableScalarRelationFilter, UnitsWhereInput> | null
    Complaints?: ComplaintsListRelationFilter
    Payments?: PaymentsListRelationFilter
  }

  export type ResidentsOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    emergencyContactName?: SortOrderInput | SortOrder
    emergencyContactNumber?: SortOrderInput | SortOrder
    movedInDate?: SortOrder
    movedOutDate?: SortOrderInput | SortOrder
    residentStatus?: SortOrderInput | SortOrder
    unitId?: SortOrderInput | SortOrder
    kprPaymentAmount?: SortOrderInput | SortOrder
    kprDueDate?: SortOrderInput | SortOrder
    isKprPaid?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UsersOrderByWithRelationInput
    unit?: UnitsOrderByWithRelationInput
    Complaints?: ComplaintsOrderByRelationAggregateInput
    Payments?: PaymentsOrderByRelationAggregateInput
  }

  export type ResidentsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: ResidentsWhereInput | ResidentsWhereInput[]
    OR?: ResidentsWhereInput[]
    NOT?: ResidentsWhereInput | ResidentsWhereInput[]
    emergencyContactName?: StringNullableFilter<"Residents"> | string | null
    emergencyContactNumber?: StringNullableFilter<"Residents"> | string | null
    movedInDate?: DateTimeFilter<"Residents"> | Date | string
    movedOutDate?: DateTimeNullableFilter<"Residents"> | Date | string | null
    residentStatus?: EnumResidentStatusNullableFilter<"Residents"> | $Enums.ResidentStatus | null
    unitId?: UuidNullableFilter<"Residents"> | string | null
    kprPaymentAmount?: FloatNullableFilter<"Residents"> | number | null
    kprDueDate?: DateTimeNullableFilter<"Residents"> | Date | string | null
    isKprPaid?: BoolNullableFilter<"Residents"> | boolean | null
    createdAt?: DateTimeFilter<"Residents"> | Date | string
    updatedAt?: DateTimeFilter<"Residents"> | Date | string
    user?: XOR<UsersScalarRelationFilter, UsersWhereInput>
    unit?: XOR<UnitsNullableScalarRelationFilter, UnitsWhereInput> | null
    Complaints?: ComplaintsListRelationFilter
    Payments?: PaymentsListRelationFilter
  }, "id" | "userId">

  export type ResidentsOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    emergencyContactName?: SortOrderInput | SortOrder
    emergencyContactNumber?: SortOrderInput | SortOrder
    movedInDate?: SortOrder
    movedOutDate?: SortOrderInput | SortOrder
    residentStatus?: SortOrderInput | SortOrder
    unitId?: SortOrderInput | SortOrder
    kprPaymentAmount?: SortOrderInput | SortOrder
    kprDueDate?: SortOrderInput | SortOrder
    isKprPaid?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ResidentsCountOrderByAggregateInput
    _avg?: ResidentsAvgOrderByAggregateInput
    _max?: ResidentsMaxOrderByAggregateInput
    _min?: ResidentsMinOrderByAggregateInput
    _sum?: ResidentsSumOrderByAggregateInput
  }

  export type ResidentsScalarWhereWithAggregatesInput = {
    AND?: ResidentsScalarWhereWithAggregatesInput | ResidentsScalarWhereWithAggregatesInput[]
    OR?: ResidentsScalarWhereWithAggregatesInput[]
    NOT?: ResidentsScalarWhereWithAggregatesInput | ResidentsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Residents"> | string
    userId?: UuidWithAggregatesFilter<"Residents"> | string
    emergencyContactName?: StringNullableWithAggregatesFilter<"Residents"> | string | null
    emergencyContactNumber?: StringNullableWithAggregatesFilter<"Residents"> | string | null
    movedInDate?: DateTimeWithAggregatesFilter<"Residents"> | Date | string
    movedOutDate?: DateTimeNullableWithAggregatesFilter<"Residents"> | Date | string | null
    residentStatus?: EnumResidentStatusNullableWithAggregatesFilter<"Residents"> | $Enums.ResidentStatus | null
    unitId?: UuidNullableWithAggregatesFilter<"Residents"> | string | null
    kprPaymentAmount?: FloatNullableWithAggregatesFilter<"Residents"> | number | null
    kprDueDate?: DateTimeNullableWithAggregatesFilter<"Residents"> | Date | string | null
    isKprPaid?: BoolNullableWithAggregatesFilter<"Residents"> | boolean | null
    createdAt?: DateTimeWithAggregatesFilter<"Residents"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Residents"> | Date | string
  }

  export type EmployeesWhereInput = {
    AND?: EmployeesWhereInput | EmployeesWhereInput[]
    OR?: EmployeesWhereInput[]
    NOT?: EmployeesWhereInput | EmployeesWhereInput[]
    id?: UuidFilter<"Employees"> | string
    userId?: UuidFilter<"Employees"> | string
    employeeNumberId?: StringFilter<"Employees"> | string
    hireDate?: DateTimeFilter<"Employees"> | Date | string
    employeePosition?: EnumEmployeeRoleFilter<"Employees"> | $Enums.EmployeeRole
    workingHours?: IntFilter<"Employees"> | number
    salary?: FloatFilter<"Employees"> | number
    bonus?: FloatNullableFilter<"Employees"> | number | null
    createdAt?: DateTimeFilter<"Employees"> | Date | string
    updatedAt?: DateTimeFilter<"Employees"> | Date | string
    user?: XOR<UsersScalarRelationFilter, UsersWhereInput>
    Announcements?: AnnouncementsListRelationFilter
    Complaints?: ComplaintsListRelationFilter
    Bills?: BillsListRelationFilter
    Payments?: PaymentsListRelationFilter
    SecurityReports?: SecurityReportsListRelationFilter
  }

  export type EmployeesOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    employeeNumberId?: SortOrder
    hireDate?: SortOrder
    employeePosition?: SortOrder
    workingHours?: SortOrder
    salary?: SortOrder
    bonus?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UsersOrderByWithRelationInput
    Announcements?: AnnouncementsOrderByRelationAggregateInput
    Complaints?: ComplaintsOrderByRelationAggregateInput
    Bills?: BillsOrderByRelationAggregateInput
    Payments?: PaymentsOrderByRelationAggregateInput
    SecurityReports?: SecurityReportsOrderByRelationAggregateInput
  }

  export type EmployeesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    employeeNumberId?: string
    AND?: EmployeesWhereInput | EmployeesWhereInput[]
    OR?: EmployeesWhereInput[]
    NOT?: EmployeesWhereInput | EmployeesWhereInput[]
    hireDate?: DateTimeFilter<"Employees"> | Date | string
    employeePosition?: EnumEmployeeRoleFilter<"Employees"> | $Enums.EmployeeRole
    workingHours?: IntFilter<"Employees"> | number
    salary?: FloatFilter<"Employees"> | number
    bonus?: FloatNullableFilter<"Employees"> | number | null
    createdAt?: DateTimeFilter<"Employees"> | Date | string
    updatedAt?: DateTimeFilter<"Employees"> | Date | string
    user?: XOR<UsersScalarRelationFilter, UsersWhereInput>
    Announcements?: AnnouncementsListRelationFilter
    Complaints?: ComplaintsListRelationFilter
    Bills?: BillsListRelationFilter
    Payments?: PaymentsListRelationFilter
    SecurityReports?: SecurityReportsListRelationFilter
  }, "id" | "userId" | "employeeNumberId">

  export type EmployeesOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    employeeNumberId?: SortOrder
    hireDate?: SortOrder
    employeePosition?: SortOrder
    workingHours?: SortOrder
    salary?: SortOrder
    bonus?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EmployeesCountOrderByAggregateInput
    _avg?: EmployeesAvgOrderByAggregateInput
    _max?: EmployeesMaxOrderByAggregateInput
    _min?: EmployeesMinOrderByAggregateInput
    _sum?: EmployeesSumOrderByAggregateInput
  }

  export type EmployeesScalarWhereWithAggregatesInput = {
    AND?: EmployeesScalarWhereWithAggregatesInput | EmployeesScalarWhereWithAggregatesInput[]
    OR?: EmployeesScalarWhereWithAggregatesInput[]
    NOT?: EmployeesScalarWhereWithAggregatesInput | EmployeesScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Employees"> | string
    userId?: UuidWithAggregatesFilter<"Employees"> | string
    employeeNumberId?: StringWithAggregatesFilter<"Employees"> | string
    hireDate?: DateTimeWithAggregatesFilter<"Employees"> | Date | string
    employeePosition?: EnumEmployeeRoleWithAggregatesFilter<"Employees"> | $Enums.EmployeeRole
    workingHours?: IntWithAggregatesFilter<"Employees"> | number
    salary?: FloatWithAggregatesFilter<"Employees"> | number
    bonus?: FloatNullableWithAggregatesFilter<"Employees"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Employees"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Employees"> | Date | string
  }

  export type ComplaintsWhereInput = {
    AND?: ComplaintsWhereInput | ComplaintsWhereInput[]
    OR?: ComplaintsWhereInput[]
    NOT?: ComplaintsWhereInput | ComplaintsWhereInput[]
    id?: UuidFilter<"Complaints"> | string
    title?: StringFilter<"Complaints"> | string
    description?: StringFilter<"Complaints"> | string
    category?: EnumMaintenanceCategoryFilter<"Complaints"> | $Enums.MaintenanceCategory
    status?: EnumComplaintStatusFilter<"Complaints"> | $Enums.ComplaintStatus
    images?: StringNullableListFilter<"Complaints">
    submittedAt?: DateTimeFilter<"Complaints"> | Date | string
    resolvedAt?: DateTimeNullableFilter<"Complaints"> | Date | string | null
    resolutionDetails?: StringNullableFilter<"Complaints"> | string | null
    residentId?: UuidFilter<"Complaints"> | string
    employeeId?: UuidNullableFilter<"Complaints"> | string | null
    unitId?: UuidNullableFilter<"Complaints"> | string | null
    createdAt?: DateTimeFilter<"Complaints"> | Date | string
    updatedAt?: DateTimeFilter<"Complaints"> | Date | string
    resident?: XOR<ResidentsScalarRelationFilter, ResidentsWhereInput>
    employee?: XOR<EmployeesNullableScalarRelationFilter, EmployeesWhereInput> | null
    unit?: XOR<UnitsNullableScalarRelationFilter, UnitsWhereInput> | null
  }

  export type ComplaintsOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    status?: SortOrder
    images?: SortOrder
    submittedAt?: SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    resolutionDetails?: SortOrderInput | SortOrder
    residentId?: SortOrder
    employeeId?: SortOrderInput | SortOrder
    unitId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    resident?: ResidentsOrderByWithRelationInput
    employee?: EmployeesOrderByWithRelationInput
    unit?: UnitsOrderByWithRelationInput
  }

  export type ComplaintsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ComplaintsWhereInput | ComplaintsWhereInput[]
    OR?: ComplaintsWhereInput[]
    NOT?: ComplaintsWhereInput | ComplaintsWhereInput[]
    title?: StringFilter<"Complaints"> | string
    description?: StringFilter<"Complaints"> | string
    category?: EnumMaintenanceCategoryFilter<"Complaints"> | $Enums.MaintenanceCategory
    status?: EnumComplaintStatusFilter<"Complaints"> | $Enums.ComplaintStatus
    images?: StringNullableListFilter<"Complaints">
    submittedAt?: DateTimeFilter<"Complaints"> | Date | string
    resolvedAt?: DateTimeNullableFilter<"Complaints"> | Date | string | null
    resolutionDetails?: StringNullableFilter<"Complaints"> | string | null
    residentId?: UuidFilter<"Complaints"> | string
    employeeId?: UuidNullableFilter<"Complaints"> | string | null
    unitId?: UuidNullableFilter<"Complaints"> | string | null
    createdAt?: DateTimeFilter<"Complaints"> | Date | string
    updatedAt?: DateTimeFilter<"Complaints"> | Date | string
    resident?: XOR<ResidentsScalarRelationFilter, ResidentsWhereInput>
    employee?: XOR<EmployeesNullableScalarRelationFilter, EmployeesWhereInput> | null
    unit?: XOR<UnitsNullableScalarRelationFilter, UnitsWhereInput> | null
  }, "id">

  export type ComplaintsOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    status?: SortOrder
    images?: SortOrder
    submittedAt?: SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    resolutionDetails?: SortOrderInput | SortOrder
    residentId?: SortOrder
    employeeId?: SortOrderInput | SortOrder
    unitId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ComplaintsCountOrderByAggregateInput
    _max?: ComplaintsMaxOrderByAggregateInput
    _min?: ComplaintsMinOrderByAggregateInput
  }

  export type ComplaintsScalarWhereWithAggregatesInput = {
    AND?: ComplaintsScalarWhereWithAggregatesInput | ComplaintsScalarWhereWithAggregatesInput[]
    OR?: ComplaintsScalarWhereWithAggregatesInput[]
    NOT?: ComplaintsScalarWhereWithAggregatesInput | ComplaintsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Complaints"> | string
    title?: StringWithAggregatesFilter<"Complaints"> | string
    description?: StringWithAggregatesFilter<"Complaints"> | string
    category?: EnumMaintenanceCategoryWithAggregatesFilter<"Complaints"> | $Enums.MaintenanceCategory
    status?: EnumComplaintStatusWithAggregatesFilter<"Complaints"> | $Enums.ComplaintStatus
    images?: StringNullableListFilter<"Complaints">
    submittedAt?: DateTimeWithAggregatesFilter<"Complaints"> | Date | string
    resolvedAt?: DateTimeNullableWithAggregatesFilter<"Complaints"> | Date | string | null
    resolutionDetails?: StringNullableWithAggregatesFilter<"Complaints"> | string | null
    residentId?: UuidWithAggregatesFilter<"Complaints"> | string
    employeeId?: UuidNullableWithAggregatesFilter<"Complaints"> | string | null
    unitId?: UuidNullableWithAggregatesFilter<"Complaints"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Complaints"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Complaints"> | Date | string
  }

  export type AnnouncementsWhereInput = {
    AND?: AnnouncementsWhereInput | AnnouncementsWhereInput[]
    OR?: AnnouncementsWhereInput[]
    NOT?: AnnouncementsWhereInput | AnnouncementsWhereInput[]
    id?: UuidFilter<"Announcements"> | string
    title?: StringFilter<"Announcements"> | string
    content?: StringFilter<"Announcements"> | string
    attachments?: StringNullableListFilter<"Announcements">
    publishDate?: DateTimeFilter<"Announcements"> | Date | string
    expiryDate?: DateTimeNullableFilter<"Announcements"> | Date | string | null
    employeeId?: UuidFilter<"Announcements"> | string
    createdAt?: DateTimeFilter<"Announcements"> | Date | string
    updatedAt?: DateTimeFilter<"Announcements"> | Date | string
    employee?: XOR<EmployeesScalarRelationFilter, EmployeesWhereInput>
  }

  export type AnnouncementsOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    attachments?: SortOrder
    publishDate?: SortOrder
    expiryDate?: SortOrderInput | SortOrder
    employeeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    employee?: EmployeesOrderByWithRelationInput
  }

  export type AnnouncementsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AnnouncementsWhereInput | AnnouncementsWhereInput[]
    OR?: AnnouncementsWhereInput[]
    NOT?: AnnouncementsWhereInput | AnnouncementsWhereInput[]
    title?: StringFilter<"Announcements"> | string
    content?: StringFilter<"Announcements"> | string
    attachments?: StringNullableListFilter<"Announcements">
    publishDate?: DateTimeFilter<"Announcements"> | Date | string
    expiryDate?: DateTimeNullableFilter<"Announcements"> | Date | string | null
    employeeId?: UuidFilter<"Announcements"> | string
    createdAt?: DateTimeFilter<"Announcements"> | Date | string
    updatedAt?: DateTimeFilter<"Announcements"> | Date | string
    employee?: XOR<EmployeesScalarRelationFilter, EmployeesWhereInput>
  }, "id">

  export type AnnouncementsOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    attachments?: SortOrder
    publishDate?: SortOrder
    expiryDate?: SortOrderInput | SortOrder
    employeeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AnnouncementsCountOrderByAggregateInput
    _max?: AnnouncementsMaxOrderByAggregateInput
    _min?: AnnouncementsMinOrderByAggregateInput
  }

  export type AnnouncementsScalarWhereWithAggregatesInput = {
    AND?: AnnouncementsScalarWhereWithAggregatesInput | AnnouncementsScalarWhereWithAggregatesInput[]
    OR?: AnnouncementsScalarWhereWithAggregatesInput[]
    NOT?: AnnouncementsScalarWhereWithAggregatesInput | AnnouncementsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Announcements"> | string
    title?: StringWithAggregatesFilter<"Announcements"> | string
    content?: StringWithAggregatesFilter<"Announcements"> | string
    attachments?: StringNullableListFilter<"Announcements">
    publishDate?: DateTimeWithAggregatesFilter<"Announcements"> | Date | string
    expiryDate?: DateTimeNullableWithAggregatesFilter<"Announcements"> | Date | string | null
    employeeId?: UuidWithAggregatesFilter<"Announcements"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Announcements"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Announcements"> | Date | string
  }

  export type ForumPostsWhereInput = {
    AND?: ForumPostsWhereInput | ForumPostsWhereInput[]
    OR?: ForumPostsWhereInput[]
    NOT?: ForumPostsWhereInput | ForumPostsWhereInput[]
    id?: UuidFilter<"ForumPosts"> | string
    title?: StringFilter<"ForumPosts"> | string
    content?: StringFilter<"ForumPosts"> | string
    attachments?: StringNullableListFilter<"ForumPosts">
    authorRole?: EnumUserRoleFilter<"ForumPosts"> | $Enums.UserRole
    userId?: UuidFilter<"ForumPosts"> | string
    publishedAt?: DateTimeFilter<"ForumPosts"> | Date | string
    createdAt?: DateTimeFilter<"ForumPosts"> | Date | string
    updatedAt?: DateTimeFilter<"ForumPosts"> | Date | string
    user?: XOR<UsersScalarRelationFilter, UsersWhereInput>
    tags?: PostTagsListRelationFilter
    comments?: ForumCommentsListRelationFilter
  }

  export type ForumPostsOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    attachments?: SortOrder
    authorRole?: SortOrder
    userId?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UsersOrderByWithRelationInput
    tags?: PostTagsOrderByRelationAggregateInput
    comments?: ForumCommentsOrderByRelationAggregateInput
  }

  export type ForumPostsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ForumPostsWhereInput | ForumPostsWhereInput[]
    OR?: ForumPostsWhereInput[]
    NOT?: ForumPostsWhereInput | ForumPostsWhereInput[]
    title?: StringFilter<"ForumPosts"> | string
    content?: StringFilter<"ForumPosts"> | string
    attachments?: StringNullableListFilter<"ForumPosts">
    authorRole?: EnumUserRoleFilter<"ForumPosts"> | $Enums.UserRole
    userId?: UuidFilter<"ForumPosts"> | string
    publishedAt?: DateTimeFilter<"ForumPosts"> | Date | string
    createdAt?: DateTimeFilter<"ForumPosts"> | Date | string
    updatedAt?: DateTimeFilter<"ForumPosts"> | Date | string
    user?: XOR<UsersScalarRelationFilter, UsersWhereInput>
    tags?: PostTagsListRelationFilter
    comments?: ForumCommentsListRelationFilter
  }, "id">

  export type ForumPostsOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    attachments?: SortOrder
    authorRole?: SortOrder
    userId?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ForumPostsCountOrderByAggregateInput
    _max?: ForumPostsMaxOrderByAggregateInput
    _min?: ForumPostsMinOrderByAggregateInput
  }

  export type ForumPostsScalarWhereWithAggregatesInput = {
    AND?: ForumPostsScalarWhereWithAggregatesInput | ForumPostsScalarWhereWithAggregatesInput[]
    OR?: ForumPostsScalarWhereWithAggregatesInput[]
    NOT?: ForumPostsScalarWhereWithAggregatesInput | ForumPostsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"ForumPosts"> | string
    title?: StringWithAggregatesFilter<"ForumPosts"> | string
    content?: StringWithAggregatesFilter<"ForumPosts"> | string
    attachments?: StringNullableListFilter<"ForumPosts">
    authorRole?: EnumUserRoleWithAggregatesFilter<"ForumPosts"> | $Enums.UserRole
    userId?: UuidWithAggregatesFilter<"ForumPosts"> | string
    publishedAt?: DateTimeWithAggregatesFilter<"ForumPosts"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"ForumPosts"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ForumPosts"> | Date | string
  }

  export type PostTagsWhereInput = {
    AND?: PostTagsWhereInput | PostTagsWhereInput[]
    OR?: PostTagsWhereInput[]
    NOT?: PostTagsWhereInput | PostTagsWhereInput[]
    id?: UuidFilter<"PostTags"> | string
    tagName?: StringFilter<"PostTags"> | string
    createdAt?: DateTimeFilter<"PostTags"> | Date | string
    updatedAt?: DateTimeFilter<"PostTags"> | Date | string
    posts?: ForumPostsListRelationFilter
  }

  export type PostTagsOrderByWithRelationInput = {
    id?: SortOrder
    tagName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    posts?: ForumPostsOrderByRelationAggregateInput
  }

  export type PostTagsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tagName?: string
    AND?: PostTagsWhereInput | PostTagsWhereInput[]
    OR?: PostTagsWhereInput[]
    NOT?: PostTagsWhereInput | PostTagsWhereInput[]
    createdAt?: DateTimeFilter<"PostTags"> | Date | string
    updatedAt?: DateTimeFilter<"PostTags"> | Date | string
    posts?: ForumPostsListRelationFilter
  }, "id" | "tagName">

  export type PostTagsOrderByWithAggregationInput = {
    id?: SortOrder
    tagName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PostTagsCountOrderByAggregateInput
    _max?: PostTagsMaxOrderByAggregateInput
    _min?: PostTagsMinOrderByAggregateInput
  }

  export type PostTagsScalarWhereWithAggregatesInput = {
    AND?: PostTagsScalarWhereWithAggregatesInput | PostTagsScalarWhereWithAggregatesInput[]
    OR?: PostTagsScalarWhereWithAggregatesInput[]
    NOT?: PostTagsScalarWhereWithAggregatesInput | PostTagsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"PostTags"> | string
    tagName?: StringWithAggregatesFilter<"PostTags"> | string
    createdAt?: DateTimeWithAggregatesFilter<"PostTags"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PostTags"> | Date | string
  }

  export type ForumCommentsWhereInput = {
    AND?: ForumCommentsWhereInput | ForumCommentsWhereInput[]
    OR?: ForumCommentsWhereInput[]
    NOT?: ForumCommentsWhereInput | ForumCommentsWhereInput[]
    id?: UuidFilter<"ForumComments"> | string
    content?: StringFilter<"ForumComments"> | string
    userId?: UuidFilter<"ForumComments"> | string
    postId?: UuidFilter<"ForumComments"> | string
    createdAt?: DateTimeFilter<"ForumComments"> | Date | string
    updatedAt?: DateTimeFilter<"ForumComments"> | Date | string
    user?: XOR<UsersScalarRelationFilter, UsersWhereInput>
    post?: XOR<ForumPostsScalarRelationFilter, ForumPostsWhereInput>
  }

  export type ForumCommentsOrderByWithRelationInput = {
    id?: SortOrder
    content?: SortOrder
    userId?: SortOrder
    postId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UsersOrderByWithRelationInput
    post?: ForumPostsOrderByWithRelationInput
  }

  export type ForumCommentsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ForumCommentsWhereInput | ForumCommentsWhereInput[]
    OR?: ForumCommentsWhereInput[]
    NOT?: ForumCommentsWhereInput | ForumCommentsWhereInput[]
    content?: StringFilter<"ForumComments"> | string
    userId?: UuidFilter<"ForumComments"> | string
    postId?: UuidFilter<"ForumComments"> | string
    createdAt?: DateTimeFilter<"ForumComments"> | Date | string
    updatedAt?: DateTimeFilter<"ForumComments"> | Date | string
    user?: XOR<UsersScalarRelationFilter, UsersWhereInput>
    post?: XOR<ForumPostsScalarRelationFilter, ForumPostsWhereInput>
  }, "id">

  export type ForumCommentsOrderByWithAggregationInput = {
    id?: SortOrder
    content?: SortOrder
    userId?: SortOrder
    postId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ForumCommentsCountOrderByAggregateInput
    _max?: ForumCommentsMaxOrderByAggregateInput
    _min?: ForumCommentsMinOrderByAggregateInput
  }

  export type ForumCommentsScalarWhereWithAggregatesInput = {
    AND?: ForumCommentsScalarWhereWithAggregatesInput | ForumCommentsScalarWhereWithAggregatesInput[]
    OR?: ForumCommentsScalarWhereWithAggregatesInput[]
    NOT?: ForumCommentsScalarWhereWithAggregatesInput | ForumCommentsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"ForumComments"> | string
    content?: StringWithAggregatesFilter<"ForumComments"> | string
    userId?: UuidWithAggregatesFilter<"ForumComments"> | string
    postId?: UuidWithAggregatesFilter<"ForumComments"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ForumComments"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ForumComments"> | Date | string
  }

  export type UnitsWhereInput = {
    AND?: UnitsWhereInput | UnitsWhereInput[]
    OR?: UnitsWhereInput[]
    NOT?: UnitsWhereInput | UnitsWhereInput[]
    id?: UuidFilter<"Units"> | string
    unitNumber?: StringFilter<"Units"> | string
    buildingName?: StringNullableFilter<"Units"> | string | null
    floorNumber?: IntNullableFilter<"Units"> | number | null
    numberOfRooms?: IntNullableFilter<"Units"> | number | null
    priceSale?: FloatFilter<"Units"> | number
    squareFootage?: IntNullableFilter<"Units"> | number | null
    location?: StringFilter<"Units"> | string
    status?: EnumUnitStatusFilter<"Units"> | $Enums.UnitStatus
    createdAt?: DateTimeFilter<"Units"> | Date | string
    updatedAt?: DateTimeFilter<"Units"> | Date | string
    Residents?: ResidentsListRelationFilter
    Payments?: PaymentsListRelationFilter
    Bills?: BillsListRelationFilter
    Complaints?: ComplaintsListRelationFilter
  }

  export type UnitsOrderByWithRelationInput = {
    id?: SortOrder
    unitNumber?: SortOrder
    buildingName?: SortOrderInput | SortOrder
    floorNumber?: SortOrderInput | SortOrder
    numberOfRooms?: SortOrderInput | SortOrder
    priceSale?: SortOrder
    squareFootage?: SortOrderInput | SortOrder
    location?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Residents?: ResidentsOrderByRelationAggregateInput
    Payments?: PaymentsOrderByRelationAggregateInput
    Bills?: BillsOrderByRelationAggregateInput
    Complaints?: ComplaintsOrderByRelationAggregateInput
  }

  export type UnitsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    unitNumber?: string
    AND?: UnitsWhereInput | UnitsWhereInput[]
    OR?: UnitsWhereInput[]
    NOT?: UnitsWhereInput | UnitsWhereInput[]
    buildingName?: StringNullableFilter<"Units"> | string | null
    floorNumber?: IntNullableFilter<"Units"> | number | null
    numberOfRooms?: IntNullableFilter<"Units"> | number | null
    priceSale?: FloatFilter<"Units"> | number
    squareFootage?: IntNullableFilter<"Units"> | number | null
    location?: StringFilter<"Units"> | string
    status?: EnumUnitStatusFilter<"Units"> | $Enums.UnitStatus
    createdAt?: DateTimeFilter<"Units"> | Date | string
    updatedAt?: DateTimeFilter<"Units"> | Date | string
    Residents?: ResidentsListRelationFilter
    Payments?: PaymentsListRelationFilter
    Bills?: BillsListRelationFilter
    Complaints?: ComplaintsListRelationFilter
  }, "id" | "unitNumber">

  export type UnitsOrderByWithAggregationInput = {
    id?: SortOrder
    unitNumber?: SortOrder
    buildingName?: SortOrderInput | SortOrder
    floorNumber?: SortOrderInput | SortOrder
    numberOfRooms?: SortOrderInput | SortOrder
    priceSale?: SortOrder
    squareFootage?: SortOrderInput | SortOrder
    location?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UnitsCountOrderByAggregateInput
    _avg?: UnitsAvgOrderByAggregateInput
    _max?: UnitsMaxOrderByAggregateInput
    _min?: UnitsMinOrderByAggregateInput
    _sum?: UnitsSumOrderByAggregateInput
  }

  export type UnitsScalarWhereWithAggregatesInput = {
    AND?: UnitsScalarWhereWithAggregatesInput | UnitsScalarWhereWithAggregatesInput[]
    OR?: UnitsScalarWhereWithAggregatesInput[]
    NOT?: UnitsScalarWhereWithAggregatesInput | UnitsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Units"> | string
    unitNumber?: StringWithAggregatesFilter<"Units"> | string
    buildingName?: StringNullableWithAggregatesFilter<"Units"> | string | null
    floorNumber?: IntNullableWithAggregatesFilter<"Units"> | number | null
    numberOfRooms?: IntNullableWithAggregatesFilter<"Units"> | number | null
    priceSale?: FloatWithAggregatesFilter<"Units"> | number
    squareFootage?: IntNullableWithAggregatesFilter<"Units"> | number | null
    location?: StringWithAggregatesFilter<"Units"> | string
    status?: EnumUnitStatusWithAggregatesFilter<"Units"> | $Enums.UnitStatus
    createdAt?: DateTimeWithAggregatesFilter<"Units"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Units"> | Date | string
  }

  export type BillsWhereInput = {
    AND?: BillsWhereInput | BillsWhereInput[]
    OR?: BillsWhereInput[]
    NOT?: BillsWhereInput | BillsWhereInput[]
    id?: UuidFilter<"Bills"> | string
    amount?: FloatFilter<"Bills"> | number
    type?: EnumPaymentTypeFilter<"Bills"> | $Enums.PaymentType
    dueDate?: DateTimeFilter<"Bills"> | Date | string
    isPaid?: BoolFilter<"Bills"> | boolean
    unitId?: UuidFilter<"Bills"> | string
    employeeId?: UuidFilter<"Bills"> | string
    createdAt?: DateTimeFilter<"Bills"> | Date | string
    updatedAt?: DateTimeFilter<"Bills"> | Date | string
    unit?: XOR<UnitsScalarRelationFilter, UnitsWhereInput>
    employee?: XOR<EmployeesScalarRelationFilter, EmployeesWhereInput>
    Payments?: PaymentsListRelationFilter
  }

  export type BillsOrderByWithRelationInput = {
    id?: SortOrder
    amount?: SortOrder
    type?: SortOrder
    dueDate?: SortOrder
    isPaid?: SortOrder
    unitId?: SortOrder
    employeeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    unit?: UnitsOrderByWithRelationInput
    employee?: EmployeesOrderByWithRelationInput
    Payments?: PaymentsOrderByRelationAggregateInput
  }

  export type BillsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BillsWhereInput | BillsWhereInput[]
    OR?: BillsWhereInput[]
    NOT?: BillsWhereInput | BillsWhereInput[]
    amount?: FloatFilter<"Bills"> | number
    type?: EnumPaymentTypeFilter<"Bills"> | $Enums.PaymentType
    dueDate?: DateTimeFilter<"Bills"> | Date | string
    isPaid?: BoolFilter<"Bills"> | boolean
    unitId?: UuidFilter<"Bills"> | string
    employeeId?: UuidFilter<"Bills"> | string
    createdAt?: DateTimeFilter<"Bills"> | Date | string
    updatedAt?: DateTimeFilter<"Bills"> | Date | string
    unit?: XOR<UnitsScalarRelationFilter, UnitsWhereInput>
    employee?: XOR<EmployeesScalarRelationFilter, EmployeesWhereInput>
    Payments?: PaymentsListRelationFilter
  }, "id">

  export type BillsOrderByWithAggregationInput = {
    id?: SortOrder
    amount?: SortOrder
    type?: SortOrder
    dueDate?: SortOrder
    isPaid?: SortOrder
    unitId?: SortOrder
    employeeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BillsCountOrderByAggregateInput
    _avg?: BillsAvgOrderByAggregateInput
    _max?: BillsMaxOrderByAggregateInput
    _min?: BillsMinOrderByAggregateInput
    _sum?: BillsSumOrderByAggregateInput
  }

  export type BillsScalarWhereWithAggregatesInput = {
    AND?: BillsScalarWhereWithAggregatesInput | BillsScalarWhereWithAggregatesInput[]
    OR?: BillsScalarWhereWithAggregatesInput[]
    NOT?: BillsScalarWhereWithAggregatesInput | BillsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Bills"> | string
    amount?: FloatWithAggregatesFilter<"Bills"> | number
    type?: EnumPaymentTypeWithAggregatesFilter<"Bills"> | $Enums.PaymentType
    dueDate?: DateTimeWithAggregatesFilter<"Bills"> | Date | string
    isPaid?: BoolWithAggregatesFilter<"Bills"> | boolean
    unitId?: UuidWithAggregatesFilter<"Bills"> | string
    employeeId?: UuidWithAggregatesFilter<"Bills"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Bills"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Bills"> | Date | string
  }

  export type PaymentsWhereInput = {
    AND?: PaymentsWhereInput | PaymentsWhereInput[]
    OR?: PaymentsWhereInput[]
    NOT?: PaymentsWhereInput | PaymentsWhereInput[]
    id?: UuidFilter<"Payments"> | string
    amount?: FloatFilter<"Payments"> | number
    paymentDate?: DateTimeFilter<"Payments"> | Date | string
    paymentMethod?: EnumPaymentMethodFilter<"Payments"> | $Enums.PaymentMethod
    status?: EnumPaymentStatusFilter<"Payments"> | $Enums.PaymentStatus
    residentId?: UuidFilter<"Payments"> | string
    unitId?: UuidNullableFilter<"Payments"> | string | null
    processedByEmployeeId?: UuidNullableFilter<"Payments"> | string | null
    billId?: UuidNullableFilter<"Payments"> | string | null
    createdAt?: DateTimeFilter<"Payments"> | Date | string
    updatedAt?: DateTimeFilter<"Payments"> | Date | string
    resident?: XOR<ResidentsScalarRelationFilter, ResidentsWhereInput>
    unit?: XOR<UnitsNullableScalarRelationFilter, UnitsWhereInput> | null
    processedBy?: XOR<EmployeesNullableScalarRelationFilter, EmployeesWhereInput> | null
    bill?: XOR<BillsNullableScalarRelationFilter, BillsWhereInput> | null
  }

  export type PaymentsOrderByWithRelationInput = {
    id?: SortOrder
    amount?: SortOrder
    paymentDate?: SortOrder
    paymentMethod?: SortOrder
    status?: SortOrder
    residentId?: SortOrder
    unitId?: SortOrderInput | SortOrder
    processedByEmployeeId?: SortOrderInput | SortOrder
    billId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    resident?: ResidentsOrderByWithRelationInput
    unit?: UnitsOrderByWithRelationInput
    processedBy?: EmployeesOrderByWithRelationInput
    bill?: BillsOrderByWithRelationInput
  }

  export type PaymentsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PaymentsWhereInput | PaymentsWhereInput[]
    OR?: PaymentsWhereInput[]
    NOT?: PaymentsWhereInput | PaymentsWhereInput[]
    amount?: FloatFilter<"Payments"> | number
    paymentDate?: DateTimeFilter<"Payments"> | Date | string
    paymentMethod?: EnumPaymentMethodFilter<"Payments"> | $Enums.PaymentMethod
    status?: EnumPaymentStatusFilter<"Payments"> | $Enums.PaymentStatus
    residentId?: UuidFilter<"Payments"> | string
    unitId?: UuidNullableFilter<"Payments"> | string | null
    processedByEmployeeId?: UuidNullableFilter<"Payments"> | string | null
    billId?: UuidNullableFilter<"Payments"> | string | null
    createdAt?: DateTimeFilter<"Payments"> | Date | string
    updatedAt?: DateTimeFilter<"Payments"> | Date | string
    resident?: XOR<ResidentsScalarRelationFilter, ResidentsWhereInput>
    unit?: XOR<UnitsNullableScalarRelationFilter, UnitsWhereInput> | null
    processedBy?: XOR<EmployeesNullableScalarRelationFilter, EmployeesWhereInput> | null
    bill?: XOR<BillsNullableScalarRelationFilter, BillsWhereInput> | null
  }, "id">

  export type PaymentsOrderByWithAggregationInput = {
    id?: SortOrder
    amount?: SortOrder
    paymentDate?: SortOrder
    paymentMethod?: SortOrder
    status?: SortOrder
    residentId?: SortOrder
    unitId?: SortOrderInput | SortOrder
    processedByEmployeeId?: SortOrderInput | SortOrder
    billId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PaymentsCountOrderByAggregateInput
    _avg?: PaymentsAvgOrderByAggregateInput
    _max?: PaymentsMaxOrderByAggregateInput
    _min?: PaymentsMinOrderByAggregateInput
    _sum?: PaymentsSumOrderByAggregateInput
  }

  export type PaymentsScalarWhereWithAggregatesInput = {
    AND?: PaymentsScalarWhereWithAggregatesInput | PaymentsScalarWhereWithAggregatesInput[]
    OR?: PaymentsScalarWhereWithAggregatesInput[]
    NOT?: PaymentsScalarWhereWithAggregatesInput | PaymentsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Payments"> | string
    amount?: FloatWithAggregatesFilter<"Payments"> | number
    paymentDate?: DateTimeWithAggregatesFilter<"Payments"> | Date | string
    paymentMethod?: EnumPaymentMethodWithAggregatesFilter<"Payments"> | $Enums.PaymentMethod
    status?: EnumPaymentStatusWithAggregatesFilter<"Payments"> | $Enums.PaymentStatus
    residentId?: UuidWithAggregatesFilter<"Payments"> | string
    unitId?: UuidNullableWithAggregatesFilter<"Payments"> | string | null
    processedByEmployeeId?: UuidNullableWithAggregatesFilter<"Payments"> | string | null
    billId?: UuidNullableWithAggregatesFilter<"Payments"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Payments"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Payments"> | Date | string
  }

  export type ContactsWhereInput = {
    AND?: ContactsWhereInput | ContactsWhereInput[]
    OR?: ContactsWhereInput[]
    NOT?: ContactsWhereInput | ContactsWhereInput[]
    id?: UuidFilter<"Contacts"> | string
    name?: StringFilter<"Contacts"> | string
    role?: EnumContactRoleFilter<"Contacts"> | $Enums.ContactRole
    phoneNumber?: StringFilter<"Contacts"> | string
    email?: StringNullableFilter<"Contacts"> | string | null
    createdAt?: DateTimeFilter<"Contacts"> | Date | string
    updatedAt?: DateTimeFilter<"Contacts"> | Date | string
  }

  export type ContactsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    role?: SortOrder
    phoneNumber?: SortOrder
    email?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContactsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ContactsWhereInput | ContactsWhereInput[]
    OR?: ContactsWhereInput[]
    NOT?: ContactsWhereInput | ContactsWhereInput[]
    name?: StringFilter<"Contacts"> | string
    role?: EnumContactRoleFilter<"Contacts"> | $Enums.ContactRole
    phoneNumber?: StringFilter<"Contacts"> | string
    email?: StringNullableFilter<"Contacts"> | string | null
    createdAt?: DateTimeFilter<"Contacts"> | Date | string
    updatedAt?: DateTimeFilter<"Contacts"> | Date | string
  }, "id">

  export type ContactsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    role?: SortOrder
    phoneNumber?: SortOrder
    email?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ContactsCountOrderByAggregateInput
    _max?: ContactsMaxOrderByAggregateInput
    _min?: ContactsMinOrderByAggregateInput
  }

  export type ContactsScalarWhereWithAggregatesInput = {
    AND?: ContactsScalarWhereWithAggregatesInput | ContactsScalarWhereWithAggregatesInput[]
    OR?: ContactsScalarWhereWithAggregatesInput[]
    NOT?: ContactsScalarWhereWithAggregatesInput | ContactsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Contacts"> | string
    name?: StringWithAggregatesFilter<"Contacts"> | string
    role?: EnumContactRoleWithAggregatesFilter<"Contacts"> | $Enums.ContactRole
    phoneNumber?: StringWithAggregatesFilter<"Contacts"> | string
    email?: StringNullableWithAggregatesFilter<"Contacts"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Contacts"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Contacts"> | Date | string
  }

  export type SecurityReportsWhereInput = {
    AND?: SecurityReportsWhereInput | SecurityReportsWhereInput[]
    OR?: SecurityReportsWhereInput[]
    NOT?: SecurityReportsWhereInput | SecurityReportsWhereInput[]
    id?: UuidFilter<"SecurityReports"> | string
    title?: StringFilter<"SecurityReports"> | string
    description?: StringFilter<"SecurityReports"> | string
    location?: StringFilter<"SecurityReports"> | string
    incidentDate?: DateTimeFilter<"SecurityReports"> | Date | string
    status?: EnumMaintenanceStatusFilter<"SecurityReports"> | $Enums.MaintenanceStatus
    isPublished?: BoolFilter<"SecurityReports"> | boolean
    employeeId?: UuidFilter<"SecurityReports"> | string
    createdAt?: DateTimeFilter<"SecurityReports"> | Date | string
    updatedAt?: DateTimeFilter<"SecurityReports"> | Date | string
    employee?: XOR<EmployeesScalarRelationFilter, EmployeesWhereInput>
  }

  export type SecurityReportsOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    location?: SortOrder
    incidentDate?: SortOrder
    status?: SortOrder
    isPublished?: SortOrder
    employeeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    employee?: EmployeesOrderByWithRelationInput
  }

  export type SecurityReportsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SecurityReportsWhereInput | SecurityReportsWhereInput[]
    OR?: SecurityReportsWhereInput[]
    NOT?: SecurityReportsWhereInput | SecurityReportsWhereInput[]
    title?: StringFilter<"SecurityReports"> | string
    description?: StringFilter<"SecurityReports"> | string
    location?: StringFilter<"SecurityReports"> | string
    incidentDate?: DateTimeFilter<"SecurityReports"> | Date | string
    status?: EnumMaintenanceStatusFilter<"SecurityReports"> | $Enums.MaintenanceStatus
    isPublished?: BoolFilter<"SecurityReports"> | boolean
    employeeId?: UuidFilter<"SecurityReports"> | string
    createdAt?: DateTimeFilter<"SecurityReports"> | Date | string
    updatedAt?: DateTimeFilter<"SecurityReports"> | Date | string
    employee?: XOR<EmployeesScalarRelationFilter, EmployeesWhereInput>
  }, "id">

  export type SecurityReportsOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    location?: SortOrder
    incidentDate?: SortOrder
    status?: SortOrder
    isPublished?: SortOrder
    employeeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SecurityReportsCountOrderByAggregateInput
    _max?: SecurityReportsMaxOrderByAggregateInput
    _min?: SecurityReportsMinOrderByAggregateInput
  }

  export type SecurityReportsScalarWhereWithAggregatesInput = {
    AND?: SecurityReportsScalarWhereWithAggregatesInput | SecurityReportsScalarWhereWithAggregatesInput[]
    OR?: SecurityReportsScalarWhereWithAggregatesInput[]
    NOT?: SecurityReportsScalarWhereWithAggregatesInput | SecurityReportsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"SecurityReports"> | string
    title?: StringWithAggregatesFilter<"SecurityReports"> | string
    description?: StringWithAggregatesFilter<"SecurityReports"> | string
    location?: StringWithAggregatesFilter<"SecurityReports"> | string
    incidentDate?: DateTimeWithAggregatesFilter<"SecurityReports"> | Date | string
    status?: EnumMaintenanceStatusWithAggregatesFilter<"SecurityReports"> | $Enums.MaintenanceStatus
    isPublished?: BoolWithAggregatesFilter<"SecurityReports"> | boolean
    employeeId?: UuidWithAggregatesFilter<"SecurityReports"> | string
    createdAt?: DateTimeWithAggregatesFilter<"SecurityReports"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SecurityReports"> | Date | string
  }

  export type UsersCreateInput = {
    id?: string
    fullName: string
    firstName: string
    lastName: string
    username: string
    dateOfBirth?: Date | string | null
    contactNumber?: string | null
    primaryEmail: string
    secondaryEmail?: string | null
    password: string
    sessionToken?: string | null
    emailVerificationToken?: string | null
    passwordResetToken?: string | null
    role: $Enums.UserRole
    gender?: $Enums.Gender | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Resident?: ResidentsCreateNestedOneWithoutUserInput
    Employee?: EmployeesCreateNestedOneWithoutUserInput
    ForumPosts?: ForumPostsCreateNestedManyWithoutUserInput
    ForumComments?: ForumCommentsCreateNestedManyWithoutUserInput
  }

  export type UsersUncheckedCreateInput = {
    id?: string
    fullName: string
    firstName: string
    lastName: string
    username: string
    dateOfBirth?: Date | string | null
    contactNumber?: string | null
    primaryEmail: string
    secondaryEmail?: string | null
    password: string
    sessionToken?: string | null
    emailVerificationToken?: string | null
    passwordResetToken?: string | null
    role: $Enums.UserRole
    gender?: $Enums.Gender | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Resident?: ResidentsUncheckedCreateNestedOneWithoutUserInput
    Employee?: EmployeesUncheckedCreateNestedOneWithoutUserInput
    ForumPosts?: ForumPostsUncheckedCreateNestedManyWithoutUserInput
    ForumComments?: ForumCommentsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UsersUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    primaryEmail?: StringFieldUpdateOperationsInput | string
    secondaryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    sessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Resident?: ResidentsUpdateOneWithoutUserNestedInput
    Employee?: EmployeesUpdateOneWithoutUserNestedInput
    ForumPosts?: ForumPostsUpdateManyWithoutUserNestedInput
    ForumComments?: ForumCommentsUpdateManyWithoutUserNestedInput
  }

  export type UsersUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    primaryEmail?: StringFieldUpdateOperationsInput | string
    secondaryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    sessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Resident?: ResidentsUncheckedUpdateOneWithoutUserNestedInput
    Employee?: EmployeesUncheckedUpdateOneWithoutUserNestedInput
    ForumPosts?: ForumPostsUncheckedUpdateManyWithoutUserNestedInput
    ForumComments?: ForumCommentsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UsersCreateManyInput = {
    id?: string
    fullName: string
    firstName: string
    lastName: string
    username: string
    dateOfBirth?: Date | string | null
    contactNumber?: string | null
    primaryEmail: string
    secondaryEmail?: string | null
    password: string
    sessionToken?: string | null
    emailVerificationToken?: string | null
    passwordResetToken?: string | null
    role: $Enums.UserRole
    gender?: $Enums.Gender | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UsersUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    primaryEmail?: StringFieldUpdateOperationsInput | string
    secondaryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    sessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsersUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    primaryEmail?: StringFieldUpdateOperationsInput | string
    secondaryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    sessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResidentsCreateInput = {
    id?: string
    emergencyContactName?: string | null
    emergencyContactNumber?: string | null
    movedInDate: Date | string
    movedOutDate?: Date | string | null
    residentStatus?: $Enums.ResidentStatus | null
    kprPaymentAmount?: number | null
    kprDueDate?: Date | string | null
    isKprPaid?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UsersCreateNestedOneWithoutResidentInput
    unit?: UnitsCreateNestedOneWithoutResidentsInput
    Complaints?: ComplaintsCreateNestedManyWithoutResidentInput
    Payments?: PaymentsCreateNestedManyWithoutResidentInput
  }

  export type ResidentsUncheckedCreateInput = {
    id?: string
    userId: string
    emergencyContactName?: string | null
    emergencyContactNumber?: string | null
    movedInDate: Date | string
    movedOutDate?: Date | string | null
    residentStatus?: $Enums.ResidentStatus | null
    unitId?: string | null
    kprPaymentAmount?: number | null
    kprDueDate?: Date | string | null
    isKprPaid?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Complaints?: ComplaintsUncheckedCreateNestedManyWithoutResidentInput
    Payments?: PaymentsUncheckedCreateNestedManyWithoutResidentInput
  }

  export type ResidentsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    movedInDate?: DateTimeFieldUpdateOperationsInput | Date | string
    movedOutDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    residentStatus?: NullableEnumResidentStatusFieldUpdateOperationsInput | $Enums.ResidentStatus | null
    kprPaymentAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    kprDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isKprPaid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UsersUpdateOneRequiredWithoutResidentNestedInput
    unit?: UnitsUpdateOneWithoutResidentsNestedInput
    Complaints?: ComplaintsUpdateManyWithoutResidentNestedInput
    Payments?: PaymentsUpdateManyWithoutResidentNestedInput
  }

  export type ResidentsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    movedInDate?: DateTimeFieldUpdateOperationsInput | Date | string
    movedOutDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    residentStatus?: NullableEnumResidentStatusFieldUpdateOperationsInput | $Enums.ResidentStatus | null
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
    kprPaymentAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    kprDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isKprPaid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Complaints?: ComplaintsUncheckedUpdateManyWithoutResidentNestedInput
    Payments?: PaymentsUncheckedUpdateManyWithoutResidentNestedInput
  }

  export type ResidentsCreateManyInput = {
    id?: string
    userId: string
    emergencyContactName?: string | null
    emergencyContactNumber?: string | null
    movedInDate: Date | string
    movedOutDate?: Date | string | null
    residentStatus?: $Enums.ResidentStatus | null
    unitId?: string | null
    kprPaymentAmount?: number | null
    kprDueDate?: Date | string | null
    isKprPaid?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResidentsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    movedInDate?: DateTimeFieldUpdateOperationsInput | Date | string
    movedOutDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    residentStatus?: NullableEnumResidentStatusFieldUpdateOperationsInput | $Enums.ResidentStatus | null
    kprPaymentAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    kprDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isKprPaid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResidentsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    movedInDate?: DateTimeFieldUpdateOperationsInput | Date | string
    movedOutDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    residentStatus?: NullableEnumResidentStatusFieldUpdateOperationsInput | $Enums.ResidentStatus | null
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
    kprPaymentAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    kprDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isKprPaid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeesCreateInput = {
    id?: string
    employeeNumberId: string
    hireDate: Date | string
    employeePosition?: $Enums.EmployeeRole
    workingHours: number
    salary: number
    bonus?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UsersCreateNestedOneWithoutEmployeeInput
    Announcements?: AnnouncementsCreateNestedManyWithoutEmployeeInput
    Complaints?: ComplaintsCreateNestedManyWithoutEmployeeInput
    Bills?: BillsCreateNestedManyWithoutEmployeeInput
    Payments?: PaymentsCreateNestedManyWithoutProcessedByInput
    SecurityReports?: SecurityReportsCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeesUncheckedCreateInput = {
    id?: string
    userId: string
    employeeNumberId: string
    hireDate: Date | string
    employeePosition?: $Enums.EmployeeRole
    workingHours: number
    salary: number
    bonus?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Announcements?: AnnouncementsUncheckedCreateNestedManyWithoutEmployeeInput
    Complaints?: ComplaintsUncheckedCreateNestedManyWithoutEmployeeInput
    Bills?: BillsUncheckedCreateNestedManyWithoutEmployeeInput
    Payments?: PaymentsUncheckedCreateNestedManyWithoutProcessedByInput
    SecurityReports?: SecurityReportsUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeNumberId?: StringFieldUpdateOperationsInput | string
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    employeePosition?: EnumEmployeeRoleFieldUpdateOperationsInput | $Enums.EmployeeRole
    workingHours?: IntFieldUpdateOperationsInput | number
    salary?: FloatFieldUpdateOperationsInput | number
    bonus?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UsersUpdateOneRequiredWithoutEmployeeNestedInput
    Announcements?: AnnouncementsUpdateManyWithoutEmployeeNestedInput
    Complaints?: ComplaintsUpdateManyWithoutEmployeeNestedInput
    Bills?: BillsUpdateManyWithoutEmployeeNestedInput
    Payments?: PaymentsUpdateManyWithoutProcessedByNestedInput
    SecurityReports?: SecurityReportsUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    employeeNumberId?: StringFieldUpdateOperationsInput | string
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    employeePosition?: EnumEmployeeRoleFieldUpdateOperationsInput | $Enums.EmployeeRole
    workingHours?: IntFieldUpdateOperationsInput | number
    salary?: FloatFieldUpdateOperationsInput | number
    bonus?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Announcements?: AnnouncementsUncheckedUpdateManyWithoutEmployeeNestedInput
    Complaints?: ComplaintsUncheckedUpdateManyWithoutEmployeeNestedInput
    Bills?: BillsUncheckedUpdateManyWithoutEmployeeNestedInput
    Payments?: PaymentsUncheckedUpdateManyWithoutProcessedByNestedInput
    SecurityReports?: SecurityReportsUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeesCreateManyInput = {
    id?: string
    userId: string
    employeeNumberId: string
    hireDate: Date | string
    employeePosition?: $Enums.EmployeeRole
    workingHours: number
    salary: number
    bonus?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeNumberId?: StringFieldUpdateOperationsInput | string
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    employeePosition?: EnumEmployeeRoleFieldUpdateOperationsInput | $Enums.EmployeeRole
    workingHours?: IntFieldUpdateOperationsInput | number
    salary?: FloatFieldUpdateOperationsInput | number
    bonus?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    employeeNumberId?: StringFieldUpdateOperationsInput | string
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    employeePosition?: EnumEmployeeRoleFieldUpdateOperationsInput | $Enums.EmployeeRole
    workingHours?: IntFieldUpdateOperationsInput | number
    salary?: FloatFieldUpdateOperationsInput | number
    bonus?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplaintsCreateInput = {
    id?: string
    title: string
    description: string
    category: $Enums.MaintenanceCategory
    status?: $Enums.ComplaintStatus
    images?: ComplaintsCreateimagesInput | string[]
    submittedAt?: Date | string
    resolvedAt?: Date | string | null
    resolutionDetails?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    resident: ResidentsCreateNestedOneWithoutComplaintsInput
    employee?: EmployeesCreateNestedOneWithoutComplaintsInput
    unit?: UnitsCreateNestedOneWithoutComplaintsInput
  }

  export type ComplaintsUncheckedCreateInput = {
    id?: string
    title: string
    description: string
    category: $Enums.MaintenanceCategory
    status?: $Enums.ComplaintStatus
    images?: ComplaintsCreateimagesInput | string[]
    submittedAt?: Date | string
    resolvedAt?: Date | string | null
    resolutionDetails?: string | null
    residentId: string
    employeeId?: string | null
    unitId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ComplaintsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumMaintenanceCategoryFieldUpdateOperationsInput | $Enums.MaintenanceCategory
    status?: EnumComplaintStatusFieldUpdateOperationsInput | $Enums.ComplaintStatus
    images?: ComplaintsUpdateimagesInput | string[]
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolutionDetails?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resident?: ResidentsUpdateOneRequiredWithoutComplaintsNestedInput
    employee?: EmployeesUpdateOneWithoutComplaintsNestedInput
    unit?: UnitsUpdateOneWithoutComplaintsNestedInput
  }

  export type ComplaintsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumMaintenanceCategoryFieldUpdateOperationsInput | $Enums.MaintenanceCategory
    status?: EnumComplaintStatusFieldUpdateOperationsInput | $Enums.ComplaintStatus
    images?: ComplaintsUpdateimagesInput | string[]
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolutionDetails?: NullableStringFieldUpdateOperationsInput | string | null
    residentId?: StringFieldUpdateOperationsInput | string
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplaintsCreateManyInput = {
    id?: string
    title: string
    description: string
    category: $Enums.MaintenanceCategory
    status?: $Enums.ComplaintStatus
    images?: ComplaintsCreateimagesInput | string[]
    submittedAt?: Date | string
    resolvedAt?: Date | string | null
    resolutionDetails?: string | null
    residentId: string
    employeeId?: string | null
    unitId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ComplaintsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumMaintenanceCategoryFieldUpdateOperationsInput | $Enums.MaintenanceCategory
    status?: EnumComplaintStatusFieldUpdateOperationsInput | $Enums.ComplaintStatus
    images?: ComplaintsUpdateimagesInput | string[]
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolutionDetails?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplaintsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumMaintenanceCategoryFieldUpdateOperationsInput | $Enums.MaintenanceCategory
    status?: EnumComplaintStatusFieldUpdateOperationsInput | $Enums.ComplaintStatus
    images?: ComplaintsUpdateimagesInput | string[]
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolutionDetails?: NullableStringFieldUpdateOperationsInput | string | null
    residentId?: StringFieldUpdateOperationsInput | string
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnnouncementsCreateInput = {
    id?: string
    title: string
    content: string
    attachments?: AnnouncementsCreateattachmentsInput | string[]
    publishDate?: Date | string
    expiryDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employee: EmployeesCreateNestedOneWithoutAnnouncementsInput
  }

  export type AnnouncementsUncheckedCreateInput = {
    id?: string
    title: string
    content: string
    attachments?: AnnouncementsCreateattachmentsInput | string[]
    publishDate?: Date | string
    expiryDate?: Date | string | null
    employeeId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AnnouncementsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    attachments?: AnnouncementsUpdateattachmentsInput | string[]
    publishDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeesUpdateOneRequiredWithoutAnnouncementsNestedInput
  }

  export type AnnouncementsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    attachments?: AnnouncementsUpdateattachmentsInput | string[]
    publishDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employeeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnnouncementsCreateManyInput = {
    id?: string
    title: string
    content: string
    attachments?: AnnouncementsCreateattachmentsInput | string[]
    publishDate?: Date | string
    expiryDate?: Date | string | null
    employeeId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AnnouncementsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    attachments?: AnnouncementsUpdateattachmentsInput | string[]
    publishDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnnouncementsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    attachments?: AnnouncementsUpdateattachmentsInput | string[]
    publishDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employeeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ForumPostsCreateInput = {
    id?: string
    title: string
    content: string
    attachments?: ForumPostsCreateattachmentsInput | string[]
    authorRole: $Enums.UserRole
    publishedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UsersCreateNestedOneWithoutForumPostsInput
    tags?: PostTagsCreateNestedManyWithoutPostsInput
    comments?: ForumCommentsCreateNestedManyWithoutPostInput
  }

  export type ForumPostsUncheckedCreateInput = {
    id?: string
    title: string
    content: string
    attachments?: ForumPostsCreateattachmentsInput | string[]
    authorRole: $Enums.UserRole
    userId: string
    publishedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    tags?: PostTagsUncheckedCreateNestedManyWithoutPostsInput
    comments?: ForumCommentsUncheckedCreateNestedManyWithoutPostInput
  }

  export type ForumPostsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    attachments?: ForumPostsUpdateattachmentsInput | string[]
    authorRole?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UsersUpdateOneRequiredWithoutForumPostsNestedInput
    tags?: PostTagsUpdateManyWithoutPostsNestedInput
    comments?: ForumCommentsUpdateManyWithoutPostNestedInput
  }

  export type ForumPostsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    attachments?: ForumPostsUpdateattachmentsInput | string[]
    authorRole?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    userId?: StringFieldUpdateOperationsInput | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tags?: PostTagsUncheckedUpdateManyWithoutPostsNestedInput
    comments?: ForumCommentsUncheckedUpdateManyWithoutPostNestedInput
  }

  export type ForumPostsCreateManyInput = {
    id?: string
    title: string
    content: string
    attachments?: ForumPostsCreateattachmentsInput | string[]
    authorRole: $Enums.UserRole
    userId: string
    publishedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ForumPostsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    attachments?: ForumPostsUpdateattachmentsInput | string[]
    authorRole?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ForumPostsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    attachments?: ForumPostsUpdateattachmentsInput | string[]
    authorRole?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    userId?: StringFieldUpdateOperationsInput | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostTagsCreateInput = {
    id?: string
    tagName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: ForumPostsCreateNestedManyWithoutTagsInput
  }

  export type PostTagsUncheckedCreateInput = {
    id?: string
    tagName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: ForumPostsUncheckedCreateNestedManyWithoutTagsInput
  }

  export type PostTagsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tagName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: ForumPostsUpdateManyWithoutTagsNestedInput
  }

  export type PostTagsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tagName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: ForumPostsUncheckedUpdateManyWithoutTagsNestedInput
  }

  export type PostTagsCreateManyInput = {
    id?: string
    tagName: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PostTagsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tagName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostTagsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tagName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ForumCommentsCreateInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UsersCreateNestedOneWithoutForumCommentsInput
    post: ForumPostsCreateNestedOneWithoutCommentsInput
  }

  export type ForumCommentsUncheckedCreateInput = {
    id?: string
    content: string
    userId: string
    postId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ForumCommentsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UsersUpdateOneRequiredWithoutForumCommentsNestedInput
    post?: ForumPostsUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type ForumCommentsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ForumCommentsCreateManyInput = {
    id?: string
    content: string
    userId: string
    postId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ForumCommentsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ForumCommentsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitsCreateInput = {
    id?: string
    unitNumber: string
    buildingName?: string | null
    floorNumber?: number | null
    numberOfRooms?: number | null
    priceSale: number
    squareFootage?: number | null
    location: string
    status: $Enums.UnitStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    Residents?: ResidentsCreateNestedManyWithoutUnitInput
    Payments?: PaymentsCreateNestedManyWithoutUnitInput
    Bills?: BillsCreateNestedManyWithoutUnitInput
    Complaints?: ComplaintsCreateNestedManyWithoutUnitInput
  }

  export type UnitsUncheckedCreateInput = {
    id?: string
    unitNumber: string
    buildingName?: string | null
    floorNumber?: number | null
    numberOfRooms?: number | null
    priceSale: number
    squareFootage?: number | null
    location: string
    status: $Enums.UnitStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    Residents?: ResidentsUncheckedCreateNestedManyWithoutUnitInput
    Payments?: PaymentsUncheckedCreateNestedManyWithoutUnitInput
    Bills?: BillsUncheckedCreateNestedManyWithoutUnitInput
    Complaints?: ComplaintsUncheckedCreateNestedManyWithoutUnitInput
  }

  export type UnitsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    unitNumber?: StringFieldUpdateOperationsInput | string
    buildingName?: NullableStringFieldUpdateOperationsInput | string | null
    floorNumber?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfRooms?: NullableIntFieldUpdateOperationsInput | number | null
    priceSale?: FloatFieldUpdateOperationsInput | number
    squareFootage?: NullableIntFieldUpdateOperationsInput | number | null
    location?: StringFieldUpdateOperationsInput | string
    status?: EnumUnitStatusFieldUpdateOperationsInput | $Enums.UnitStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Residents?: ResidentsUpdateManyWithoutUnitNestedInput
    Payments?: PaymentsUpdateManyWithoutUnitNestedInput
    Bills?: BillsUpdateManyWithoutUnitNestedInput
    Complaints?: ComplaintsUpdateManyWithoutUnitNestedInput
  }

  export type UnitsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    unitNumber?: StringFieldUpdateOperationsInput | string
    buildingName?: NullableStringFieldUpdateOperationsInput | string | null
    floorNumber?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfRooms?: NullableIntFieldUpdateOperationsInput | number | null
    priceSale?: FloatFieldUpdateOperationsInput | number
    squareFootage?: NullableIntFieldUpdateOperationsInput | number | null
    location?: StringFieldUpdateOperationsInput | string
    status?: EnumUnitStatusFieldUpdateOperationsInput | $Enums.UnitStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Residents?: ResidentsUncheckedUpdateManyWithoutUnitNestedInput
    Payments?: PaymentsUncheckedUpdateManyWithoutUnitNestedInput
    Bills?: BillsUncheckedUpdateManyWithoutUnitNestedInput
    Complaints?: ComplaintsUncheckedUpdateManyWithoutUnitNestedInput
  }

  export type UnitsCreateManyInput = {
    id?: string
    unitNumber: string
    buildingName?: string | null
    floorNumber?: number | null
    numberOfRooms?: number | null
    priceSale: number
    squareFootage?: number | null
    location: string
    status: $Enums.UnitStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UnitsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    unitNumber?: StringFieldUpdateOperationsInput | string
    buildingName?: NullableStringFieldUpdateOperationsInput | string | null
    floorNumber?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfRooms?: NullableIntFieldUpdateOperationsInput | number | null
    priceSale?: FloatFieldUpdateOperationsInput | number
    squareFootage?: NullableIntFieldUpdateOperationsInput | number | null
    location?: StringFieldUpdateOperationsInput | string
    status?: EnumUnitStatusFieldUpdateOperationsInput | $Enums.UnitStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    unitNumber?: StringFieldUpdateOperationsInput | string
    buildingName?: NullableStringFieldUpdateOperationsInput | string | null
    floorNumber?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfRooms?: NullableIntFieldUpdateOperationsInput | number | null
    priceSale?: FloatFieldUpdateOperationsInput | number
    squareFootage?: NullableIntFieldUpdateOperationsInput | number | null
    location?: StringFieldUpdateOperationsInput | string
    status?: EnumUnitStatusFieldUpdateOperationsInput | $Enums.UnitStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillsCreateInput = {
    id?: string
    amount: number
    type: $Enums.PaymentType
    dueDate: Date | string
    isPaid?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    unit: UnitsCreateNestedOneWithoutBillsInput
    employee: EmployeesCreateNestedOneWithoutBillsInput
    Payments?: PaymentsCreateNestedManyWithoutBillInput
  }

  export type BillsUncheckedCreateInput = {
    id?: string
    amount: number
    type: $Enums.PaymentType
    dueDate: Date | string
    isPaid?: boolean
    unitId: string
    employeeId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Payments?: PaymentsUncheckedCreateNestedManyWithoutBillInput
  }

  export type BillsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    type?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    unit?: UnitsUpdateOneRequiredWithoutBillsNestedInput
    employee?: EmployeesUpdateOneRequiredWithoutBillsNestedInput
    Payments?: PaymentsUpdateManyWithoutBillNestedInput
  }

  export type BillsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    type?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    unitId?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Payments?: PaymentsUncheckedUpdateManyWithoutBillNestedInput
  }

  export type BillsCreateManyInput = {
    id?: string
    amount: number
    type: $Enums.PaymentType
    dueDate: Date | string
    isPaid?: boolean
    unitId: string
    employeeId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BillsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    type?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    type?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    unitId?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentsCreateInput = {
    id?: string
    amount: number
    paymentDate?: Date | string
    paymentMethod: $Enums.PaymentMethod
    status: $Enums.PaymentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    resident: ResidentsCreateNestedOneWithoutPaymentsInput
    unit?: UnitsCreateNestedOneWithoutPaymentsInput
    processedBy?: EmployeesCreateNestedOneWithoutPaymentsInput
    bill?: BillsCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentsUncheckedCreateInput = {
    id?: string
    amount: number
    paymentDate?: Date | string
    paymentMethod: $Enums.PaymentMethod
    status: $Enums.PaymentStatus
    residentId: string
    unitId?: string | null
    processedByEmployeeId?: string | null
    billId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resident?: ResidentsUpdateOneRequiredWithoutPaymentsNestedInput
    unit?: UnitsUpdateOneWithoutPaymentsNestedInput
    processedBy?: EmployeesUpdateOneWithoutPaymentsNestedInput
    bill?: BillsUpdateOneWithoutPaymentsNestedInput
  }

  export type PaymentsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    residentId?: StringFieldUpdateOperationsInput | string
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
    processedByEmployeeId?: NullableStringFieldUpdateOperationsInput | string | null
    billId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentsCreateManyInput = {
    id?: string
    amount: number
    paymentDate?: Date | string
    paymentMethod: $Enums.PaymentMethod
    status: $Enums.PaymentStatus
    residentId: string
    unitId?: string | null
    processedByEmployeeId?: string | null
    billId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    residentId?: StringFieldUpdateOperationsInput | string
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
    processedByEmployeeId?: NullableStringFieldUpdateOperationsInput | string | null
    billId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactsCreateInput = {
    id?: string
    name: string
    role: $Enums.ContactRole
    phoneNumber: string
    email?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactsUncheckedCreateInput = {
    id?: string
    name: string
    role: $Enums.ContactRole
    phoneNumber: string
    email?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumContactRoleFieldUpdateOperationsInput | $Enums.ContactRole
    phoneNumber?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumContactRoleFieldUpdateOperationsInput | $Enums.ContactRole
    phoneNumber?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactsCreateManyInput = {
    id?: string
    name: string
    role: $Enums.ContactRole
    phoneNumber: string
    email?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumContactRoleFieldUpdateOperationsInput | $Enums.ContactRole
    phoneNumber?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumContactRoleFieldUpdateOperationsInput | $Enums.ContactRole
    phoneNumber?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SecurityReportsCreateInput = {
    id?: string
    title: string
    description: string
    location: string
    incidentDate: Date | string
    status: $Enums.MaintenanceStatus
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    employee: EmployeesCreateNestedOneWithoutSecurityReportsInput
  }

  export type SecurityReportsUncheckedCreateInput = {
    id?: string
    title: string
    description: string
    location: string
    incidentDate: Date | string
    status: $Enums.MaintenanceStatus
    isPublished?: boolean
    employeeId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SecurityReportsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    incidentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumMaintenanceStatusFieldUpdateOperationsInput | $Enums.MaintenanceStatus
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeesUpdateOneRequiredWithoutSecurityReportsNestedInput
  }

  export type SecurityReportsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    incidentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumMaintenanceStatusFieldUpdateOperationsInput | $Enums.MaintenanceStatus
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    employeeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SecurityReportsCreateManyInput = {
    id?: string
    title: string
    description: string
    location: string
    incidentDate: Date | string
    status: $Enums.MaintenanceStatus
    isPublished?: boolean
    employeeId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SecurityReportsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    incidentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumMaintenanceStatusFieldUpdateOperationsInput | $Enums.MaintenanceStatus
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SecurityReportsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    incidentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumMaintenanceStatusFieldUpdateOperationsInput | $Enums.MaintenanceStatus
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    employeeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type EnumGenderNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGenderNullableFilter<$PrismaModel> | $Enums.Gender | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type ResidentsNullableScalarRelationFilter = {
    is?: ResidentsWhereInput | null
    isNot?: ResidentsWhereInput | null
  }

  export type EmployeesNullableScalarRelationFilter = {
    is?: EmployeesWhereInput | null
    isNot?: EmployeesWhereInput | null
  }

  export type ForumPostsListRelationFilter = {
    every?: ForumPostsWhereInput
    some?: ForumPostsWhereInput
    none?: ForumPostsWhereInput
  }

  export type ForumCommentsListRelationFilter = {
    every?: ForumCommentsWhereInput
    some?: ForumCommentsWhereInput
    none?: ForumCommentsWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ForumPostsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ForumCommentsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UsersCountOrderByAggregateInput = {
    id?: SortOrder
    fullName?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    username?: SortOrder
    dateOfBirth?: SortOrder
    contactNumber?: SortOrder
    primaryEmail?: SortOrder
    secondaryEmail?: SortOrder
    password?: SortOrder
    sessionToken?: SortOrder
    emailVerificationToken?: SortOrder
    passwordResetToken?: SortOrder
    role?: SortOrder
    gender?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UsersMaxOrderByAggregateInput = {
    id?: SortOrder
    fullName?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    username?: SortOrder
    dateOfBirth?: SortOrder
    contactNumber?: SortOrder
    primaryEmail?: SortOrder
    secondaryEmail?: SortOrder
    password?: SortOrder
    sessionToken?: SortOrder
    emailVerificationToken?: SortOrder
    passwordResetToken?: SortOrder
    role?: SortOrder
    gender?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UsersMinOrderByAggregateInput = {
    id?: SortOrder
    fullName?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    username?: SortOrder
    dateOfBirth?: SortOrder
    contactNumber?: SortOrder
    primaryEmail?: SortOrder
    secondaryEmail?: SortOrder
    password?: SortOrder
    sessionToken?: SortOrder
    emailVerificationToken?: SortOrder
    passwordResetToken?: SortOrder
    role?: SortOrder
    gender?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type EnumGenderNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGenderNullableWithAggregatesFilter<$PrismaModel> | $Enums.Gender | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumGenderNullableFilter<$PrismaModel>
    _max?: NestedEnumGenderNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumResidentStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ResidentStatus | EnumResidentStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.ResidentStatus[] | ListEnumResidentStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ResidentStatus[] | ListEnumResidentStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumResidentStatusNullableFilter<$PrismaModel> | $Enums.ResidentStatus | null
  }

  export type UuidNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidNullableFilter<$PrismaModel> | string | null
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type UsersScalarRelationFilter = {
    is?: UsersWhereInput
    isNot?: UsersWhereInput
  }

  export type UnitsNullableScalarRelationFilter = {
    is?: UnitsWhereInput | null
    isNot?: UnitsWhereInput | null
  }

  export type ComplaintsListRelationFilter = {
    every?: ComplaintsWhereInput
    some?: ComplaintsWhereInput
    none?: ComplaintsWhereInput
  }

  export type PaymentsListRelationFilter = {
    every?: PaymentsWhereInput
    some?: PaymentsWhereInput
    none?: PaymentsWhereInput
  }

  export type ComplaintsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ResidentsCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    emergencyContactName?: SortOrder
    emergencyContactNumber?: SortOrder
    movedInDate?: SortOrder
    movedOutDate?: SortOrder
    residentStatus?: SortOrder
    unitId?: SortOrder
    kprPaymentAmount?: SortOrder
    kprDueDate?: SortOrder
    isKprPaid?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ResidentsAvgOrderByAggregateInput = {
    kprPaymentAmount?: SortOrder
  }

  export type ResidentsMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    emergencyContactName?: SortOrder
    emergencyContactNumber?: SortOrder
    movedInDate?: SortOrder
    movedOutDate?: SortOrder
    residentStatus?: SortOrder
    unitId?: SortOrder
    kprPaymentAmount?: SortOrder
    kprDueDate?: SortOrder
    isKprPaid?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ResidentsMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    emergencyContactName?: SortOrder
    emergencyContactNumber?: SortOrder
    movedInDate?: SortOrder
    movedOutDate?: SortOrder
    residentStatus?: SortOrder
    unitId?: SortOrder
    kprPaymentAmount?: SortOrder
    kprDueDate?: SortOrder
    isKprPaid?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ResidentsSumOrderByAggregateInput = {
    kprPaymentAmount?: SortOrder
  }

  export type EnumResidentStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ResidentStatus | EnumResidentStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.ResidentStatus[] | ListEnumResidentStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ResidentStatus[] | ListEnumResidentStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumResidentStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.ResidentStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumResidentStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumResidentStatusNullableFilter<$PrismaModel>
  }

  export type UuidNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type EnumEmployeeRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.EmployeeRole | EnumEmployeeRoleFieldRefInput<$PrismaModel>
    in?: $Enums.EmployeeRole[] | ListEnumEmployeeRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.EmployeeRole[] | ListEnumEmployeeRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumEmployeeRoleFilter<$PrismaModel> | $Enums.EmployeeRole
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type AnnouncementsListRelationFilter = {
    every?: AnnouncementsWhereInput
    some?: AnnouncementsWhereInput
    none?: AnnouncementsWhereInput
  }

  export type BillsListRelationFilter = {
    every?: BillsWhereInput
    some?: BillsWhereInput
    none?: BillsWhereInput
  }

  export type SecurityReportsListRelationFilter = {
    every?: SecurityReportsWhereInput
    some?: SecurityReportsWhereInput
    none?: SecurityReportsWhereInput
  }

  export type AnnouncementsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BillsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SecurityReportsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmployeesCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    employeeNumberId?: SortOrder
    hireDate?: SortOrder
    employeePosition?: SortOrder
    workingHours?: SortOrder
    salary?: SortOrder
    bonus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmployeesAvgOrderByAggregateInput = {
    workingHours?: SortOrder
    salary?: SortOrder
    bonus?: SortOrder
  }

  export type EmployeesMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    employeeNumberId?: SortOrder
    hireDate?: SortOrder
    employeePosition?: SortOrder
    workingHours?: SortOrder
    salary?: SortOrder
    bonus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmployeesMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    employeeNumberId?: SortOrder
    hireDate?: SortOrder
    employeePosition?: SortOrder
    workingHours?: SortOrder
    salary?: SortOrder
    bonus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmployeesSumOrderByAggregateInput = {
    workingHours?: SortOrder
    salary?: SortOrder
    bonus?: SortOrder
  }

  export type EnumEmployeeRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EmployeeRole | EnumEmployeeRoleFieldRefInput<$PrismaModel>
    in?: $Enums.EmployeeRole[] | ListEnumEmployeeRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.EmployeeRole[] | ListEnumEmployeeRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumEmployeeRoleWithAggregatesFilter<$PrismaModel> | $Enums.EmployeeRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEmployeeRoleFilter<$PrismaModel>
    _max?: NestedEnumEmployeeRoleFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type EnumMaintenanceCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.MaintenanceCategory | EnumMaintenanceCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.MaintenanceCategory[] | ListEnumMaintenanceCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.MaintenanceCategory[] | ListEnumMaintenanceCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumMaintenanceCategoryFilter<$PrismaModel> | $Enums.MaintenanceCategory
  }

  export type EnumComplaintStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ComplaintStatus | EnumComplaintStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ComplaintStatus[] | ListEnumComplaintStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ComplaintStatus[] | ListEnumComplaintStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumComplaintStatusFilter<$PrismaModel> | $Enums.ComplaintStatus
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type ResidentsScalarRelationFilter = {
    is?: ResidentsWhereInput
    isNot?: ResidentsWhereInput
  }

  export type ComplaintsCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    status?: SortOrder
    images?: SortOrder
    submittedAt?: SortOrder
    resolvedAt?: SortOrder
    resolutionDetails?: SortOrder
    residentId?: SortOrder
    employeeId?: SortOrder
    unitId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ComplaintsMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    status?: SortOrder
    submittedAt?: SortOrder
    resolvedAt?: SortOrder
    resolutionDetails?: SortOrder
    residentId?: SortOrder
    employeeId?: SortOrder
    unitId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ComplaintsMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    status?: SortOrder
    submittedAt?: SortOrder
    resolvedAt?: SortOrder
    resolutionDetails?: SortOrder
    residentId?: SortOrder
    employeeId?: SortOrder
    unitId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumMaintenanceCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MaintenanceCategory | EnumMaintenanceCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.MaintenanceCategory[] | ListEnumMaintenanceCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.MaintenanceCategory[] | ListEnumMaintenanceCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumMaintenanceCategoryWithAggregatesFilter<$PrismaModel> | $Enums.MaintenanceCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMaintenanceCategoryFilter<$PrismaModel>
    _max?: NestedEnumMaintenanceCategoryFilter<$PrismaModel>
  }

  export type EnumComplaintStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ComplaintStatus | EnumComplaintStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ComplaintStatus[] | ListEnumComplaintStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ComplaintStatus[] | ListEnumComplaintStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumComplaintStatusWithAggregatesFilter<$PrismaModel> | $Enums.ComplaintStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumComplaintStatusFilter<$PrismaModel>
    _max?: NestedEnumComplaintStatusFilter<$PrismaModel>
  }

  export type EmployeesScalarRelationFilter = {
    is?: EmployeesWhereInput
    isNot?: EmployeesWhereInput
  }

  export type AnnouncementsCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    attachments?: SortOrder
    publishDate?: SortOrder
    expiryDate?: SortOrder
    employeeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AnnouncementsMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    publishDate?: SortOrder
    expiryDate?: SortOrder
    employeeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AnnouncementsMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    publishDate?: SortOrder
    expiryDate?: SortOrder
    employeeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PostTagsListRelationFilter = {
    every?: PostTagsWhereInput
    some?: PostTagsWhereInput
    none?: PostTagsWhereInput
  }

  export type PostTagsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ForumPostsCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    attachments?: SortOrder
    authorRole?: SortOrder
    userId?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ForumPostsMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    authorRole?: SortOrder
    userId?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ForumPostsMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    authorRole?: SortOrder
    userId?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PostTagsCountOrderByAggregateInput = {
    id?: SortOrder
    tagName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PostTagsMaxOrderByAggregateInput = {
    id?: SortOrder
    tagName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PostTagsMinOrderByAggregateInput = {
    id?: SortOrder
    tagName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ForumPostsScalarRelationFilter = {
    is?: ForumPostsWhereInput
    isNot?: ForumPostsWhereInput
  }

  export type ForumCommentsCountOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    userId?: SortOrder
    postId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ForumCommentsMaxOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    userId?: SortOrder
    postId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ForumCommentsMinOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    userId?: SortOrder
    postId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type EnumUnitStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.UnitStatus | EnumUnitStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UnitStatus[] | ListEnumUnitStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UnitStatus[] | ListEnumUnitStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUnitStatusFilter<$PrismaModel> | $Enums.UnitStatus
  }

  export type ResidentsListRelationFilter = {
    every?: ResidentsWhereInput
    some?: ResidentsWhereInput
    none?: ResidentsWhereInput
  }

  export type ResidentsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UnitsCountOrderByAggregateInput = {
    id?: SortOrder
    unitNumber?: SortOrder
    buildingName?: SortOrder
    floorNumber?: SortOrder
    numberOfRooms?: SortOrder
    priceSale?: SortOrder
    squareFootage?: SortOrder
    location?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UnitsAvgOrderByAggregateInput = {
    floorNumber?: SortOrder
    numberOfRooms?: SortOrder
    priceSale?: SortOrder
    squareFootage?: SortOrder
  }

  export type UnitsMaxOrderByAggregateInput = {
    id?: SortOrder
    unitNumber?: SortOrder
    buildingName?: SortOrder
    floorNumber?: SortOrder
    numberOfRooms?: SortOrder
    priceSale?: SortOrder
    squareFootage?: SortOrder
    location?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UnitsMinOrderByAggregateInput = {
    id?: SortOrder
    unitNumber?: SortOrder
    buildingName?: SortOrder
    floorNumber?: SortOrder
    numberOfRooms?: SortOrder
    priceSale?: SortOrder
    squareFootage?: SortOrder
    location?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UnitsSumOrderByAggregateInput = {
    floorNumber?: SortOrder
    numberOfRooms?: SortOrder
    priceSale?: SortOrder
    squareFootage?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumUnitStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UnitStatus | EnumUnitStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UnitStatus[] | ListEnumUnitStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UnitStatus[] | ListEnumUnitStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUnitStatusWithAggregatesFilter<$PrismaModel> | $Enums.UnitStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUnitStatusFilter<$PrismaModel>
    _max?: NestedEnumUnitStatusFilter<$PrismaModel>
  }

  export type EnumPaymentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentType | EnumPaymentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentType[] | ListEnumPaymentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentType[] | ListEnumPaymentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentTypeFilter<$PrismaModel> | $Enums.PaymentType
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type UnitsScalarRelationFilter = {
    is?: UnitsWhereInput
    isNot?: UnitsWhereInput
  }

  export type BillsCountOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    type?: SortOrder
    dueDate?: SortOrder
    isPaid?: SortOrder
    unitId?: SortOrder
    employeeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BillsAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type BillsMaxOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    type?: SortOrder
    dueDate?: SortOrder
    isPaid?: SortOrder
    unitId?: SortOrder
    employeeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BillsMinOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    type?: SortOrder
    dueDate?: SortOrder
    isPaid?: SortOrder
    unitId?: SortOrder
    employeeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BillsSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumPaymentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentType | EnumPaymentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentType[] | ListEnumPaymentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentType[] | ListEnumPaymentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentTypeWithAggregatesFilter<$PrismaModel> | $Enums.PaymentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentTypeFilter<$PrismaModel>
    _max?: NestedEnumPaymentTypeFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EnumPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod
  }

  export type EnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type BillsNullableScalarRelationFilter = {
    is?: BillsWhereInput | null
    isNot?: BillsWhereInput | null
  }

  export type PaymentsCountOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    paymentDate?: SortOrder
    paymentMethod?: SortOrder
    status?: SortOrder
    residentId?: SortOrder
    unitId?: SortOrder
    processedByEmployeeId?: SortOrder
    billId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentsAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type PaymentsMaxOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    paymentDate?: SortOrder
    paymentMethod?: SortOrder
    status?: SortOrder
    residentId?: SortOrder
    unitId?: SortOrder
    processedByEmployeeId?: SortOrder
    billId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentsMinOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    paymentDate?: SortOrder
    paymentMethod?: SortOrder
    status?: SortOrder
    residentId?: SortOrder
    unitId?: SortOrder
    processedByEmployeeId?: SortOrder
    billId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentsSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodFilter<$PrismaModel>
  }

  export type EnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type EnumContactRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.ContactRole | EnumContactRoleFieldRefInput<$PrismaModel>
    in?: $Enums.ContactRole[] | ListEnumContactRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContactRole[] | ListEnumContactRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumContactRoleFilter<$PrismaModel> | $Enums.ContactRole
  }

  export type ContactsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    role?: SortOrder
    phoneNumber?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContactsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    role?: SortOrder
    phoneNumber?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContactsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    role?: SortOrder
    phoneNumber?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumContactRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContactRole | EnumContactRoleFieldRefInput<$PrismaModel>
    in?: $Enums.ContactRole[] | ListEnumContactRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContactRole[] | ListEnumContactRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumContactRoleWithAggregatesFilter<$PrismaModel> | $Enums.ContactRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumContactRoleFilter<$PrismaModel>
    _max?: NestedEnumContactRoleFilter<$PrismaModel>
  }

  export type EnumMaintenanceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MaintenanceStatus | EnumMaintenanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MaintenanceStatus[] | ListEnumMaintenanceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MaintenanceStatus[] | ListEnumMaintenanceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMaintenanceStatusFilter<$PrismaModel> | $Enums.MaintenanceStatus
  }

  export type SecurityReportsCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    location?: SortOrder
    incidentDate?: SortOrder
    status?: SortOrder
    isPublished?: SortOrder
    employeeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SecurityReportsMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    location?: SortOrder
    incidentDate?: SortOrder
    status?: SortOrder
    isPublished?: SortOrder
    employeeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SecurityReportsMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    location?: SortOrder
    incidentDate?: SortOrder
    status?: SortOrder
    isPublished?: SortOrder
    employeeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumMaintenanceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MaintenanceStatus | EnumMaintenanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MaintenanceStatus[] | ListEnumMaintenanceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MaintenanceStatus[] | ListEnumMaintenanceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMaintenanceStatusWithAggregatesFilter<$PrismaModel> | $Enums.MaintenanceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMaintenanceStatusFilter<$PrismaModel>
    _max?: NestedEnumMaintenanceStatusFilter<$PrismaModel>
  }

  export type ResidentsCreateNestedOneWithoutUserInput = {
    create?: XOR<ResidentsCreateWithoutUserInput, ResidentsUncheckedCreateWithoutUserInput>
    connectOrCreate?: ResidentsCreateOrConnectWithoutUserInput
    connect?: ResidentsWhereUniqueInput
  }

  export type EmployeesCreateNestedOneWithoutUserInput = {
    create?: XOR<EmployeesCreateWithoutUserInput, EmployeesUncheckedCreateWithoutUserInput>
    connectOrCreate?: EmployeesCreateOrConnectWithoutUserInput
    connect?: EmployeesWhereUniqueInput
  }

  export type ForumPostsCreateNestedManyWithoutUserInput = {
    create?: XOR<ForumPostsCreateWithoutUserInput, ForumPostsUncheckedCreateWithoutUserInput> | ForumPostsCreateWithoutUserInput[] | ForumPostsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ForumPostsCreateOrConnectWithoutUserInput | ForumPostsCreateOrConnectWithoutUserInput[]
    createMany?: ForumPostsCreateManyUserInputEnvelope
    connect?: ForumPostsWhereUniqueInput | ForumPostsWhereUniqueInput[]
  }

  export type ForumCommentsCreateNestedManyWithoutUserInput = {
    create?: XOR<ForumCommentsCreateWithoutUserInput, ForumCommentsUncheckedCreateWithoutUserInput> | ForumCommentsCreateWithoutUserInput[] | ForumCommentsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ForumCommentsCreateOrConnectWithoutUserInput | ForumCommentsCreateOrConnectWithoutUserInput[]
    createMany?: ForumCommentsCreateManyUserInputEnvelope
    connect?: ForumCommentsWhereUniqueInput | ForumCommentsWhereUniqueInput[]
  }

  export type ResidentsUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<ResidentsCreateWithoutUserInput, ResidentsUncheckedCreateWithoutUserInput>
    connectOrCreate?: ResidentsCreateOrConnectWithoutUserInput
    connect?: ResidentsWhereUniqueInput
  }

  export type EmployeesUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<EmployeesCreateWithoutUserInput, EmployeesUncheckedCreateWithoutUserInput>
    connectOrCreate?: EmployeesCreateOrConnectWithoutUserInput
    connect?: EmployeesWhereUniqueInput
  }

  export type ForumPostsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ForumPostsCreateWithoutUserInput, ForumPostsUncheckedCreateWithoutUserInput> | ForumPostsCreateWithoutUserInput[] | ForumPostsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ForumPostsCreateOrConnectWithoutUserInput | ForumPostsCreateOrConnectWithoutUserInput[]
    createMany?: ForumPostsCreateManyUserInputEnvelope
    connect?: ForumPostsWhereUniqueInput | ForumPostsWhereUniqueInput[]
  }

  export type ForumCommentsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ForumCommentsCreateWithoutUserInput, ForumCommentsUncheckedCreateWithoutUserInput> | ForumCommentsCreateWithoutUserInput[] | ForumCommentsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ForumCommentsCreateOrConnectWithoutUserInput | ForumCommentsCreateOrConnectWithoutUserInput[]
    createMany?: ForumCommentsCreateManyUserInputEnvelope
    connect?: ForumCommentsWhereUniqueInput | ForumCommentsWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type NullableEnumGenderFieldUpdateOperationsInput = {
    set?: $Enums.Gender | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type ResidentsUpdateOneWithoutUserNestedInput = {
    create?: XOR<ResidentsCreateWithoutUserInput, ResidentsUncheckedCreateWithoutUserInput>
    connectOrCreate?: ResidentsCreateOrConnectWithoutUserInput
    upsert?: ResidentsUpsertWithoutUserInput
    disconnect?: ResidentsWhereInput | boolean
    delete?: ResidentsWhereInput | boolean
    connect?: ResidentsWhereUniqueInput
    update?: XOR<XOR<ResidentsUpdateToOneWithWhereWithoutUserInput, ResidentsUpdateWithoutUserInput>, ResidentsUncheckedUpdateWithoutUserInput>
  }

  export type EmployeesUpdateOneWithoutUserNestedInput = {
    create?: XOR<EmployeesCreateWithoutUserInput, EmployeesUncheckedCreateWithoutUserInput>
    connectOrCreate?: EmployeesCreateOrConnectWithoutUserInput
    upsert?: EmployeesUpsertWithoutUserInput
    disconnect?: EmployeesWhereInput | boolean
    delete?: EmployeesWhereInput | boolean
    connect?: EmployeesWhereUniqueInput
    update?: XOR<XOR<EmployeesUpdateToOneWithWhereWithoutUserInput, EmployeesUpdateWithoutUserInput>, EmployeesUncheckedUpdateWithoutUserInput>
  }

  export type ForumPostsUpdateManyWithoutUserNestedInput = {
    create?: XOR<ForumPostsCreateWithoutUserInput, ForumPostsUncheckedCreateWithoutUserInput> | ForumPostsCreateWithoutUserInput[] | ForumPostsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ForumPostsCreateOrConnectWithoutUserInput | ForumPostsCreateOrConnectWithoutUserInput[]
    upsert?: ForumPostsUpsertWithWhereUniqueWithoutUserInput | ForumPostsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ForumPostsCreateManyUserInputEnvelope
    set?: ForumPostsWhereUniqueInput | ForumPostsWhereUniqueInput[]
    disconnect?: ForumPostsWhereUniqueInput | ForumPostsWhereUniqueInput[]
    delete?: ForumPostsWhereUniqueInput | ForumPostsWhereUniqueInput[]
    connect?: ForumPostsWhereUniqueInput | ForumPostsWhereUniqueInput[]
    update?: ForumPostsUpdateWithWhereUniqueWithoutUserInput | ForumPostsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ForumPostsUpdateManyWithWhereWithoutUserInput | ForumPostsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ForumPostsScalarWhereInput | ForumPostsScalarWhereInput[]
  }

  export type ForumCommentsUpdateManyWithoutUserNestedInput = {
    create?: XOR<ForumCommentsCreateWithoutUserInput, ForumCommentsUncheckedCreateWithoutUserInput> | ForumCommentsCreateWithoutUserInput[] | ForumCommentsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ForumCommentsCreateOrConnectWithoutUserInput | ForumCommentsCreateOrConnectWithoutUserInput[]
    upsert?: ForumCommentsUpsertWithWhereUniqueWithoutUserInput | ForumCommentsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ForumCommentsCreateManyUserInputEnvelope
    set?: ForumCommentsWhereUniqueInput | ForumCommentsWhereUniqueInput[]
    disconnect?: ForumCommentsWhereUniqueInput | ForumCommentsWhereUniqueInput[]
    delete?: ForumCommentsWhereUniqueInput | ForumCommentsWhereUniqueInput[]
    connect?: ForumCommentsWhereUniqueInput | ForumCommentsWhereUniqueInput[]
    update?: ForumCommentsUpdateWithWhereUniqueWithoutUserInput | ForumCommentsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ForumCommentsUpdateManyWithWhereWithoutUserInput | ForumCommentsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ForumCommentsScalarWhereInput | ForumCommentsScalarWhereInput[]
  }

  export type ResidentsUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<ResidentsCreateWithoutUserInput, ResidentsUncheckedCreateWithoutUserInput>
    connectOrCreate?: ResidentsCreateOrConnectWithoutUserInput
    upsert?: ResidentsUpsertWithoutUserInput
    disconnect?: ResidentsWhereInput | boolean
    delete?: ResidentsWhereInput | boolean
    connect?: ResidentsWhereUniqueInput
    update?: XOR<XOR<ResidentsUpdateToOneWithWhereWithoutUserInput, ResidentsUpdateWithoutUserInput>, ResidentsUncheckedUpdateWithoutUserInput>
  }

  export type EmployeesUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<EmployeesCreateWithoutUserInput, EmployeesUncheckedCreateWithoutUserInput>
    connectOrCreate?: EmployeesCreateOrConnectWithoutUserInput
    upsert?: EmployeesUpsertWithoutUserInput
    disconnect?: EmployeesWhereInput | boolean
    delete?: EmployeesWhereInput | boolean
    connect?: EmployeesWhereUniqueInput
    update?: XOR<XOR<EmployeesUpdateToOneWithWhereWithoutUserInput, EmployeesUpdateWithoutUserInput>, EmployeesUncheckedUpdateWithoutUserInput>
  }

  export type ForumPostsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ForumPostsCreateWithoutUserInput, ForumPostsUncheckedCreateWithoutUserInput> | ForumPostsCreateWithoutUserInput[] | ForumPostsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ForumPostsCreateOrConnectWithoutUserInput | ForumPostsCreateOrConnectWithoutUserInput[]
    upsert?: ForumPostsUpsertWithWhereUniqueWithoutUserInput | ForumPostsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ForumPostsCreateManyUserInputEnvelope
    set?: ForumPostsWhereUniqueInput | ForumPostsWhereUniqueInput[]
    disconnect?: ForumPostsWhereUniqueInput | ForumPostsWhereUniqueInput[]
    delete?: ForumPostsWhereUniqueInput | ForumPostsWhereUniqueInput[]
    connect?: ForumPostsWhereUniqueInput | ForumPostsWhereUniqueInput[]
    update?: ForumPostsUpdateWithWhereUniqueWithoutUserInput | ForumPostsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ForumPostsUpdateManyWithWhereWithoutUserInput | ForumPostsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ForumPostsScalarWhereInput | ForumPostsScalarWhereInput[]
  }

  export type ForumCommentsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ForumCommentsCreateWithoutUserInput, ForumCommentsUncheckedCreateWithoutUserInput> | ForumCommentsCreateWithoutUserInput[] | ForumCommentsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ForumCommentsCreateOrConnectWithoutUserInput | ForumCommentsCreateOrConnectWithoutUserInput[]
    upsert?: ForumCommentsUpsertWithWhereUniqueWithoutUserInput | ForumCommentsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ForumCommentsCreateManyUserInputEnvelope
    set?: ForumCommentsWhereUniqueInput | ForumCommentsWhereUniqueInput[]
    disconnect?: ForumCommentsWhereUniqueInput | ForumCommentsWhereUniqueInput[]
    delete?: ForumCommentsWhereUniqueInput | ForumCommentsWhereUniqueInput[]
    connect?: ForumCommentsWhereUniqueInput | ForumCommentsWhereUniqueInput[]
    update?: ForumCommentsUpdateWithWhereUniqueWithoutUserInput | ForumCommentsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ForumCommentsUpdateManyWithWhereWithoutUserInput | ForumCommentsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ForumCommentsScalarWhereInput | ForumCommentsScalarWhereInput[]
  }

  export type UsersCreateNestedOneWithoutResidentInput = {
    create?: XOR<UsersCreateWithoutResidentInput, UsersUncheckedCreateWithoutResidentInput>
    connectOrCreate?: UsersCreateOrConnectWithoutResidentInput
    connect?: UsersWhereUniqueInput
  }

  export type UnitsCreateNestedOneWithoutResidentsInput = {
    create?: XOR<UnitsCreateWithoutResidentsInput, UnitsUncheckedCreateWithoutResidentsInput>
    connectOrCreate?: UnitsCreateOrConnectWithoutResidentsInput
    connect?: UnitsWhereUniqueInput
  }

  export type ComplaintsCreateNestedManyWithoutResidentInput = {
    create?: XOR<ComplaintsCreateWithoutResidentInput, ComplaintsUncheckedCreateWithoutResidentInput> | ComplaintsCreateWithoutResidentInput[] | ComplaintsUncheckedCreateWithoutResidentInput[]
    connectOrCreate?: ComplaintsCreateOrConnectWithoutResidentInput | ComplaintsCreateOrConnectWithoutResidentInput[]
    createMany?: ComplaintsCreateManyResidentInputEnvelope
    connect?: ComplaintsWhereUniqueInput | ComplaintsWhereUniqueInput[]
  }

  export type PaymentsCreateNestedManyWithoutResidentInput = {
    create?: XOR<PaymentsCreateWithoutResidentInput, PaymentsUncheckedCreateWithoutResidentInput> | PaymentsCreateWithoutResidentInput[] | PaymentsUncheckedCreateWithoutResidentInput[]
    connectOrCreate?: PaymentsCreateOrConnectWithoutResidentInput | PaymentsCreateOrConnectWithoutResidentInput[]
    createMany?: PaymentsCreateManyResidentInputEnvelope
    connect?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
  }

  export type ComplaintsUncheckedCreateNestedManyWithoutResidentInput = {
    create?: XOR<ComplaintsCreateWithoutResidentInput, ComplaintsUncheckedCreateWithoutResidentInput> | ComplaintsCreateWithoutResidentInput[] | ComplaintsUncheckedCreateWithoutResidentInput[]
    connectOrCreate?: ComplaintsCreateOrConnectWithoutResidentInput | ComplaintsCreateOrConnectWithoutResidentInput[]
    createMany?: ComplaintsCreateManyResidentInputEnvelope
    connect?: ComplaintsWhereUniqueInput | ComplaintsWhereUniqueInput[]
  }

  export type PaymentsUncheckedCreateNestedManyWithoutResidentInput = {
    create?: XOR<PaymentsCreateWithoutResidentInput, PaymentsUncheckedCreateWithoutResidentInput> | PaymentsCreateWithoutResidentInput[] | PaymentsUncheckedCreateWithoutResidentInput[]
    connectOrCreate?: PaymentsCreateOrConnectWithoutResidentInput | PaymentsCreateOrConnectWithoutResidentInput[]
    createMany?: PaymentsCreateManyResidentInputEnvelope
    connect?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
  }

  export type NullableEnumResidentStatusFieldUpdateOperationsInput = {
    set?: $Enums.ResidentStatus | null
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type UsersUpdateOneRequiredWithoutResidentNestedInput = {
    create?: XOR<UsersCreateWithoutResidentInput, UsersUncheckedCreateWithoutResidentInput>
    connectOrCreate?: UsersCreateOrConnectWithoutResidentInput
    upsert?: UsersUpsertWithoutResidentInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutResidentInput, UsersUpdateWithoutResidentInput>, UsersUncheckedUpdateWithoutResidentInput>
  }

  export type UnitsUpdateOneWithoutResidentsNestedInput = {
    create?: XOR<UnitsCreateWithoutResidentsInput, UnitsUncheckedCreateWithoutResidentsInput>
    connectOrCreate?: UnitsCreateOrConnectWithoutResidentsInput
    upsert?: UnitsUpsertWithoutResidentsInput
    disconnect?: UnitsWhereInput | boolean
    delete?: UnitsWhereInput | boolean
    connect?: UnitsWhereUniqueInput
    update?: XOR<XOR<UnitsUpdateToOneWithWhereWithoutResidentsInput, UnitsUpdateWithoutResidentsInput>, UnitsUncheckedUpdateWithoutResidentsInput>
  }

  export type ComplaintsUpdateManyWithoutResidentNestedInput = {
    create?: XOR<ComplaintsCreateWithoutResidentInput, ComplaintsUncheckedCreateWithoutResidentInput> | ComplaintsCreateWithoutResidentInput[] | ComplaintsUncheckedCreateWithoutResidentInput[]
    connectOrCreate?: ComplaintsCreateOrConnectWithoutResidentInput | ComplaintsCreateOrConnectWithoutResidentInput[]
    upsert?: ComplaintsUpsertWithWhereUniqueWithoutResidentInput | ComplaintsUpsertWithWhereUniqueWithoutResidentInput[]
    createMany?: ComplaintsCreateManyResidentInputEnvelope
    set?: ComplaintsWhereUniqueInput | ComplaintsWhereUniqueInput[]
    disconnect?: ComplaintsWhereUniqueInput | ComplaintsWhereUniqueInput[]
    delete?: ComplaintsWhereUniqueInput | ComplaintsWhereUniqueInput[]
    connect?: ComplaintsWhereUniqueInput | ComplaintsWhereUniqueInput[]
    update?: ComplaintsUpdateWithWhereUniqueWithoutResidentInput | ComplaintsUpdateWithWhereUniqueWithoutResidentInput[]
    updateMany?: ComplaintsUpdateManyWithWhereWithoutResidentInput | ComplaintsUpdateManyWithWhereWithoutResidentInput[]
    deleteMany?: ComplaintsScalarWhereInput | ComplaintsScalarWhereInput[]
  }

  export type PaymentsUpdateManyWithoutResidentNestedInput = {
    create?: XOR<PaymentsCreateWithoutResidentInput, PaymentsUncheckedCreateWithoutResidentInput> | PaymentsCreateWithoutResidentInput[] | PaymentsUncheckedCreateWithoutResidentInput[]
    connectOrCreate?: PaymentsCreateOrConnectWithoutResidentInput | PaymentsCreateOrConnectWithoutResidentInput[]
    upsert?: PaymentsUpsertWithWhereUniqueWithoutResidentInput | PaymentsUpsertWithWhereUniqueWithoutResidentInput[]
    createMany?: PaymentsCreateManyResidentInputEnvelope
    set?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    disconnect?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    delete?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    connect?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    update?: PaymentsUpdateWithWhereUniqueWithoutResidentInput | PaymentsUpdateWithWhereUniqueWithoutResidentInput[]
    updateMany?: PaymentsUpdateManyWithWhereWithoutResidentInput | PaymentsUpdateManyWithWhereWithoutResidentInput[]
    deleteMany?: PaymentsScalarWhereInput | PaymentsScalarWhereInput[]
  }

  export type ComplaintsUncheckedUpdateManyWithoutResidentNestedInput = {
    create?: XOR<ComplaintsCreateWithoutResidentInput, ComplaintsUncheckedCreateWithoutResidentInput> | ComplaintsCreateWithoutResidentInput[] | ComplaintsUncheckedCreateWithoutResidentInput[]
    connectOrCreate?: ComplaintsCreateOrConnectWithoutResidentInput | ComplaintsCreateOrConnectWithoutResidentInput[]
    upsert?: ComplaintsUpsertWithWhereUniqueWithoutResidentInput | ComplaintsUpsertWithWhereUniqueWithoutResidentInput[]
    createMany?: ComplaintsCreateManyResidentInputEnvelope
    set?: ComplaintsWhereUniqueInput | ComplaintsWhereUniqueInput[]
    disconnect?: ComplaintsWhereUniqueInput | ComplaintsWhereUniqueInput[]
    delete?: ComplaintsWhereUniqueInput | ComplaintsWhereUniqueInput[]
    connect?: ComplaintsWhereUniqueInput | ComplaintsWhereUniqueInput[]
    update?: ComplaintsUpdateWithWhereUniqueWithoutResidentInput | ComplaintsUpdateWithWhereUniqueWithoutResidentInput[]
    updateMany?: ComplaintsUpdateManyWithWhereWithoutResidentInput | ComplaintsUpdateManyWithWhereWithoutResidentInput[]
    deleteMany?: ComplaintsScalarWhereInput | ComplaintsScalarWhereInput[]
  }

  export type PaymentsUncheckedUpdateManyWithoutResidentNestedInput = {
    create?: XOR<PaymentsCreateWithoutResidentInput, PaymentsUncheckedCreateWithoutResidentInput> | PaymentsCreateWithoutResidentInput[] | PaymentsUncheckedCreateWithoutResidentInput[]
    connectOrCreate?: PaymentsCreateOrConnectWithoutResidentInput | PaymentsCreateOrConnectWithoutResidentInput[]
    upsert?: PaymentsUpsertWithWhereUniqueWithoutResidentInput | PaymentsUpsertWithWhereUniqueWithoutResidentInput[]
    createMany?: PaymentsCreateManyResidentInputEnvelope
    set?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    disconnect?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    delete?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    connect?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    update?: PaymentsUpdateWithWhereUniqueWithoutResidentInput | PaymentsUpdateWithWhereUniqueWithoutResidentInput[]
    updateMany?: PaymentsUpdateManyWithWhereWithoutResidentInput | PaymentsUpdateManyWithWhereWithoutResidentInput[]
    deleteMany?: PaymentsScalarWhereInput | PaymentsScalarWhereInput[]
  }

  export type UsersCreateNestedOneWithoutEmployeeInput = {
    create?: XOR<UsersCreateWithoutEmployeeInput, UsersUncheckedCreateWithoutEmployeeInput>
    connectOrCreate?: UsersCreateOrConnectWithoutEmployeeInput
    connect?: UsersWhereUniqueInput
  }

  export type AnnouncementsCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<AnnouncementsCreateWithoutEmployeeInput, AnnouncementsUncheckedCreateWithoutEmployeeInput> | AnnouncementsCreateWithoutEmployeeInput[] | AnnouncementsUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: AnnouncementsCreateOrConnectWithoutEmployeeInput | AnnouncementsCreateOrConnectWithoutEmployeeInput[]
    createMany?: AnnouncementsCreateManyEmployeeInputEnvelope
    connect?: AnnouncementsWhereUniqueInput | AnnouncementsWhereUniqueInput[]
  }

  export type ComplaintsCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<ComplaintsCreateWithoutEmployeeInput, ComplaintsUncheckedCreateWithoutEmployeeInput> | ComplaintsCreateWithoutEmployeeInput[] | ComplaintsUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: ComplaintsCreateOrConnectWithoutEmployeeInput | ComplaintsCreateOrConnectWithoutEmployeeInput[]
    createMany?: ComplaintsCreateManyEmployeeInputEnvelope
    connect?: ComplaintsWhereUniqueInput | ComplaintsWhereUniqueInput[]
  }

  export type BillsCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<BillsCreateWithoutEmployeeInput, BillsUncheckedCreateWithoutEmployeeInput> | BillsCreateWithoutEmployeeInput[] | BillsUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: BillsCreateOrConnectWithoutEmployeeInput | BillsCreateOrConnectWithoutEmployeeInput[]
    createMany?: BillsCreateManyEmployeeInputEnvelope
    connect?: BillsWhereUniqueInput | BillsWhereUniqueInput[]
  }

  export type PaymentsCreateNestedManyWithoutProcessedByInput = {
    create?: XOR<PaymentsCreateWithoutProcessedByInput, PaymentsUncheckedCreateWithoutProcessedByInput> | PaymentsCreateWithoutProcessedByInput[] | PaymentsUncheckedCreateWithoutProcessedByInput[]
    connectOrCreate?: PaymentsCreateOrConnectWithoutProcessedByInput | PaymentsCreateOrConnectWithoutProcessedByInput[]
    createMany?: PaymentsCreateManyProcessedByInputEnvelope
    connect?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
  }

  export type SecurityReportsCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<SecurityReportsCreateWithoutEmployeeInput, SecurityReportsUncheckedCreateWithoutEmployeeInput> | SecurityReportsCreateWithoutEmployeeInput[] | SecurityReportsUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: SecurityReportsCreateOrConnectWithoutEmployeeInput | SecurityReportsCreateOrConnectWithoutEmployeeInput[]
    createMany?: SecurityReportsCreateManyEmployeeInputEnvelope
    connect?: SecurityReportsWhereUniqueInput | SecurityReportsWhereUniqueInput[]
  }

  export type AnnouncementsUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<AnnouncementsCreateWithoutEmployeeInput, AnnouncementsUncheckedCreateWithoutEmployeeInput> | AnnouncementsCreateWithoutEmployeeInput[] | AnnouncementsUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: AnnouncementsCreateOrConnectWithoutEmployeeInput | AnnouncementsCreateOrConnectWithoutEmployeeInput[]
    createMany?: AnnouncementsCreateManyEmployeeInputEnvelope
    connect?: AnnouncementsWhereUniqueInput | AnnouncementsWhereUniqueInput[]
  }

  export type ComplaintsUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<ComplaintsCreateWithoutEmployeeInput, ComplaintsUncheckedCreateWithoutEmployeeInput> | ComplaintsCreateWithoutEmployeeInput[] | ComplaintsUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: ComplaintsCreateOrConnectWithoutEmployeeInput | ComplaintsCreateOrConnectWithoutEmployeeInput[]
    createMany?: ComplaintsCreateManyEmployeeInputEnvelope
    connect?: ComplaintsWhereUniqueInput | ComplaintsWhereUniqueInput[]
  }

  export type BillsUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<BillsCreateWithoutEmployeeInput, BillsUncheckedCreateWithoutEmployeeInput> | BillsCreateWithoutEmployeeInput[] | BillsUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: BillsCreateOrConnectWithoutEmployeeInput | BillsCreateOrConnectWithoutEmployeeInput[]
    createMany?: BillsCreateManyEmployeeInputEnvelope
    connect?: BillsWhereUniqueInput | BillsWhereUniqueInput[]
  }

  export type PaymentsUncheckedCreateNestedManyWithoutProcessedByInput = {
    create?: XOR<PaymentsCreateWithoutProcessedByInput, PaymentsUncheckedCreateWithoutProcessedByInput> | PaymentsCreateWithoutProcessedByInput[] | PaymentsUncheckedCreateWithoutProcessedByInput[]
    connectOrCreate?: PaymentsCreateOrConnectWithoutProcessedByInput | PaymentsCreateOrConnectWithoutProcessedByInput[]
    createMany?: PaymentsCreateManyProcessedByInputEnvelope
    connect?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
  }

  export type SecurityReportsUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<SecurityReportsCreateWithoutEmployeeInput, SecurityReportsUncheckedCreateWithoutEmployeeInput> | SecurityReportsCreateWithoutEmployeeInput[] | SecurityReportsUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: SecurityReportsCreateOrConnectWithoutEmployeeInput | SecurityReportsCreateOrConnectWithoutEmployeeInput[]
    createMany?: SecurityReportsCreateManyEmployeeInputEnvelope
    connect?: SecurityReportsWhereUniqueInput | SecurityReportsWhereUniqueInput[]
  }

  export type EnumEmployeeRoleFieldUpdateOperationsInput = {
    set?: $Enums.EmployeeRole
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UsersUpdateOneRequiredWithoutEmployeeNestedInput = {
    create?: XOR<UsersCreateWithoutEmployeeInput, UsersUncheckedCreateWithoutEmployeeInput>
    connectOrCreate?: UsersCreateOrConnectWithoutEmployeeInput
    upsert?: UsersUpsertWithoutEmployeeInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutEmployeeInput, UsersUpdateWithoutEmployeeInput>, UsersUncheckedUpdateWithoutEmployeeInput>
  }

  export type AnnouncementsUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<AnnouncementsCreateWithoutEmployeeInput, AnnouncementsUncheckedCreateWithoutEmployeeInput> | AnnouncementsCreateWithoutEmployeeInput[] | AnnouncementsUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: AnnouncementsCreateOrConnectWithoutEmployeeInput | AnnouncementsCreateOrConnectWithoutEmployeeInput[]
    upsert?: AnnouncementsUpsertWithWhereUniqueWithoutEmployeeInput | AnnouncementsUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: AnnouncementsCreateManyEmployeeInputEnvelope
    set?: AnnouncementsWhereUniqueInput | AnnouncementsWhereUniqueInput[]
    disconnect?: AnnouncementsWhereUniqueInput | AnnouncementsWhereUniqueInput[]
    delete?: AnnouncementsWhereUniqueInput | AnnouncementsWhereUniqueInput[]
    connect?: AnnouncementsWhereUniqueInput | AnnouncementsWhereUniqueInput[]
    update?: AnnouncementsUpdateWithWhereUniqueWithoutEmployeeInput | AnnouncementsUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: AnnouncementsUpdateManyWithWhereWithoutEmployeeInput | AnnouncementsUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: AnnouncementsScalarWhereInput | AnnouncementsScalarWhereInput[]
  }

  export type ComplaintsUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<ComplaintsCreateWithoutEmployeeInput, ComplaintsUncheckedCreateWithoutEmployeeInput> | ComplaintsCreateWithoutEmployeeInput[] | ComplaintsUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: ComplaintsCreateOrConnectWithoutEmployeeInput | ComplaintsCreateOrConnectWithoutEmployeeInput[]
    upsert?: ComplaintsUpsertWithWhereUniqueWithoutEmployeeInput | ComplaintsUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: ComplaintsCreateManyEmployeeInputEnvelope
    set?: ComplaintsWhereUniqueInput | ComplaintsWhereUniqueInput[]
    disconnect?: ComplaintsWhereUniqueInput | ComplaintsWhereUniqueInput[]
    delete?: ComplaintsWhereUniqueInput | ComplaintsWhereUniqueInput[]
    connect?: ComplaintsWhereUniqueInput | ComplaintsWhereUniqueInput[]
    update?: ComplaintsUpdateWithWhereUniqueWithoutEmployeeInput | ComplaintsUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: ComplaintsUpdateManyWithWhereWithoutEmployeeInput | ComplaintsUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: ComplaintsScalarWhereInput | ComplaintsScalarWhereInput[]
  }

  export type BillsUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<BillsCreateWithoutEmployeeInput, BillsUncheckedCreateWithoutEmployeeInput> | BillsCreateWithoutEmployeeInput[] | BillsUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: BillsCreateOrConnectWithoutEmployeeInput | BillsCreateOrConnectWithoutEmployeeInput[]
    upsert?: BillsUpsertWithWhereUniqueWithoutEmployeeInput | BillsUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: BillsCreateManyEmployeeInputEnvelope
    set?: BillsWhereUniqueInput | BillsWhereUniqueInput[]
    disconnect?: BillsWhereUniqueInput | BillsWhereUniqueInput[]
    delete?: BillsWhereUniqueInput | BillsWhereUniqueInput[]
    connect?: BillsWhereUniqueInput | BillsWhereUniqueInput[]
    update?: BillsUpdateWithWhereUniqueWithoutEmployeeInput | BillsUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: BillsUpdateManyWithWhereWithoutEmployeeInput | BillsUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: BillsScalarWhereInput | BillsScalarWhereInput[]
  }

  export type PaymentsUpdateManyWithoutProcessedByNestedInput = {
    create?: XOR<PaymentsCreateWithoutProcessedByInput, PaymentsUncheckedCreateWithoutProcessedByInput> | PaymentsCreateWithoutProcessedByInput[] | PaymentsUncheckedCreateWithoutProcessedByInput[]
    connectOrCreate?: PaymentsCreateOrConnectWithoutProcessedByInput | PaymentsCreateOrConnectWithoutProcessedByInput[]
    upsert?: PaymentsUpsertWithWhereUniqueWithoutProcessedByInput | PaymentsUpsertWithWhereUniqueWithoutProcessedByInput[]
    createMany?: PaymentsCreateManyProcessedByInputEnvelope
    set?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    disconnect?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    delete?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    connect?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    update?: PaymentsUpdateWithWhereUniqueWithoutProcessedByInput | PaymentsUpdateWithWhereUniqueWithoutProcessedByInput[]
    updateMany?: PaymentsUpdateManyWithWhereWithoutProcessedByInput | PaymentsUpdateManyWithWhereWithoutProcessedByInput[]
    deleteMany?: PaymentsScalarWhereInput | PaymentsScalarWhereInput[]
  }

  export type SecurityReportsUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<SecurityReportsCreateWithoutEmployeeInput, SecurityReportsUncheckedCreateWithoutEmployeeInput> | SecurityReportsCreateWithoutEmployeeInput[] | SecurityReportsUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: SecurityReportsCreateOrConnectWithoutEmployeeInput | SecurityReportsCreateOrConnectWithoutEmployeeInput[]
    upsert?: SecurityReportsUpsertWithWhereUniqueWithoutEmployeeInput | SecurityReportsUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: SecurityReportsCreateManyEmployeeInputEnvelope
    set?: SecurityReportsWhereUniqueInput | SecurityReportsWhereUniqueInput[]
    disconnect?: SecurityReportsWhereUniqueInput | SecurityReportsWhereUniqueInput[]
    delete?: SecurityReportsWhereUniqueInput | SecurityReportsWhereUniqueInput[]
    connect?: SecurityReportsWhereUniqueInput | SecurityReportsWhereUniqueInput[]
    update?: SecurityReportsUpdateWithWhereUniqueWithoutEmployeeInput | SecurityReportsUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: SecurityReportsUpdateManyWithWhereWithoutEmployeeInput | SecurityReportsUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: SecurityReportsScalarWhereInput | SecurityReportsScalarWhereInput[]
  }

  export type AnnouncementsUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<AnnouncementsCreateWithoutEmployeeInput, AnnouncementsUncheckedCreateWithoutEmployeeInput> | AnnouncementsCreateWithoutEmployeeInput[] | AnnouncementsUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: AnnouncementsCreateOrConnectWithoutEmployeeInput | AnnouncementsCreateOrConnectWithoutEmployeeInput[]
    upsert?: AnnouncementsUpsertWithWhereUniqueWithoutEmployeeInput | AnnouncementsUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: AnnouncementsCreateManyEmployeeInputEnvelope
    set?: AnnouncementsWhereUniqueInput | AnnouncementsWhereUniqueInput[]
    disconnect?: AnnouncementsWhereUniqueInput | AnnouncementsWhereUniqueInput[]
    delete?: AnnouncementsWhereUniqueInput | AnnouncementsWhereUniqueInput[]
    connect?: AnnouncementsWhereUniqueInput | AnnouncementsWhereUniqueInput[]
    update?: AnnouncementsUpdateWithWhereUniqueWithoutEmployeeInput | AnnouncementsUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: AnnouncementsUpdateManyWithWhereWithoutEmployeeInput | AnnouncementsUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: AnnouncementsScalarWhereInput | AnnouncementsScalarWhereInput[]
  }

  export type ComplaintsUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<ComplaintsCreateWithoutEmployeeInput, ComplaintsUncheckedCreateWithoutEmployeeInput> | ComplaintsCreateWithoutEmployeeInput[] | ComplaintsUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: ComplaintsCreateOrConnectWithoutEmployeeInput | ComplaintsCreateOrConnectWithoutEmployeeInput[]
    upsert?: ComplaintsUpsertWithWhereUniqueWithoutEmployeeInput | ComplaintsUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: ComplaintsCreateManyEmployeeInputEnvelope
    set?: ComplaintsWhereUniqueInput | ComplaintsWhereUniqueInput[]
    disconnect?: ComplaintsWhereUniqueInput | ComplaintsWhereUniqueInput[]
    delete?: ComplaintsWhereUniqueInput | ComplaintsWhereUniqueInput[]
    connect?: ComplaintsWhereUniqueInput | ComplaintsWhereUniqueInput[]
    update?: ComplaintsUpdateWithWhereUniqueWithoutEmployeeInput | ComplaintsUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: ComplaintsUpdateManyWithWhereWithoutEmployeeInput | ComplaintsUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: ComplaintsScalarWhereInput | ComplaintsScalarWhereInput[]
  }

  export type BillsUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<BillsCreateWithoutEmployeeInput, BillsUncheckedCreateWithoutEmployeeInput> | BillsCreateWithoutEmployeeInput[] | BillsUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: BillsCreateOrConnectWithoutEmployeeInput | BillsCreateOrConnectWithoutEmployeeInput[]
    upsert?: BillsUpsertWithWhereUniqueWithoutEmployeeInput | BillsUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: BillsCreateManyEmployeeInputEnvelope
    set?: BillsWhereUniqueInput | BillsWhereUniqueInput[]
    disconnect?: BillsWhereUniqueInput | BillsWhereUniqueInput[]
    delete?: BillsWhereUniqueInput | BillsWhereUniqueInput[]
    connect?: BillsWhereUniqueInput | BillsWhereUniqueInput[]
    update?: BillsUpdateWithWhereUniqueWithoutEmployeeInput | BillsUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: BillsUpdateManyWithWhereWithoutEmployeeInput | BillsUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: BillsScalarWhereInput | BillsScalarWhereInput[]
  }

  export type PaymentsUncheckedUpdateManyWithoutProcessedByNestedInput = {
    create?: XOR<PaymentsCreateWithoutProcessedByInput, PaymentsUncheckedCreateWithoutProcessedByInput> | PaymentsCreateWithoutProcessedByInput[] | PaymentsUncheckedCreateWithoutProcessedByInput[]
    connectOrCreate?: PaymentsCreateOrConnectWithoutProcessedByInput | PaymentsCreateOrConnectWithoutProcessedByInput[]
    upsert?: PaymentsUpsertWithWhereUniqueWithoutProcessedByInput | PaymentsUpsertWithWhereUniqueWithoutProcessedByInput[]
    createMany?: PaymentsCreateManyProcessedByInputEnvelope
    set?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    disconnect?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    delete?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    connect?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    update?: PaymentsUpdateWithWhereUniqueWithoutProcessedByInput | PaymentsUpdateWithWhereUniqueWithoutProcessedByInput[]
    updateMany?: PaymentsUpdateManyWithWhereWithoutProcessedByInput | PaymentsUpdateManyWithWhereWithoutProcessedByInput[]
    deleteMany?: PaymentsScalarWhereInput | PaymentsScalarWhereInput[]
  }

  export type SecurityReportsUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<SecurityReportsCreateWithoutEmployeeInput, SecurityReportsUncheckedCreateWithoutEmployeeInput> | SecurityReportsCreateWithoutEmployeeInput[] | SecurityReportsUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: SecurityReportsCreateOrConnectWithoutEmployeeInput | SecurityReportsCreateOrConnectWithoutEmployeeInput[]
    upsert?: SecurityReportsUpsertWithWhereUniqueWithoutEmployeeInput | SecurityReportsUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: SecurityReportsCreateManyEmployeeInputEnvelope
    set?: SecurityReportsWhereUniqueInput | SecurityReportsWhereUniqueInput[]
    disconnect?: SecurityReportsWhereUniqueInput | SecurityReportsWhereUniqueInput[]
    delete?: SecurityReportsWhereUniqueInput | SecurityReportsWhereUniqueInput[]
    connect?: SecurityReportsWhereUniqueInput | SecurityReportsWhereUniqueInput[]
    update?: SecurityReportsUpdateWithWhereUniqueWithoutEmployeeInput | SecurityReportsUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: SecurityReportsUpdateManyWithWhereWithoutEmployeeInput | SecurityReportsUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: SecurityReportsScalarWhereInput | SecurityReportsScalarWhereInput[]
  }

  export type ComplaintsCreateimagesInput = {
    set: string[]
  }

  export type ResidentsCreateNestedOneWithoutComplaintsInput = {
    create?: XOR<ResidentsCreateWithoutComplaintsInput, ResidentsUncheckedCreateWithoutComplaintsInput>
    connectOrCreate?: ResidentsCreateOrConnectWithoutComplaintsInput
    connect?: ResidentsWhereUniqueInput
  }

  export type EmployeesCreateNestedOneWithoutComplaintsInput = {
    create?: XOR<EmployeesCreateWithoutComplaintsInput, EmployeesUncheckedCreateWithoutComplaintsInput>
    connectOrCreate?: EmployeesCreateOrConnectWithoutComplaintsInput
    connect?: EmployeesWhereUniqueInput
  }

  export type UnitsCreateNestedOneWithoutComplaintsInput = {
    create?: XOR<UnitsCreateWithoutComplaintsInput, UnitsUncheckedCreateWithoutComplaintsInput>
    connectOrCreate?: UnitsCreateOrConnectWithoutComplaintsInput
    connect?: UnitsWhereUniqueInput
  }

  export type EnumMaintenanceCategoryFieldUpdateOperationsInput = {
    set?: $Enums.MaintenanceCategory
  }

  export type EnumComplaintStatusFieldUpdateOperationsInput = {
    set?: $Enums.ComplaintStatus
  }

  export type ComplaintsUpdateimagesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ResidentsUpdateOneRequiredWithoutComplaintsNestedInput = {
    create?: XOR<ResidentsCreateWithoutComplaintsInput, ResidentsUncheckedCreateWithoutComplaintsInput>
    connectOrCreate?: ResidentsCreateOrConnectWithoutComplaintsInput
    upsert?: ResidentsUpsertWithoutComplaintsInput
    connect?: ResidentsWhereUniqueInput
    update?: XOR<XOR<ResidentsUpdateToOneWithWhereWithoutComplaintsInput, ResidentsUpdateWithoutComplaintsInput>, ResidentsUncheckedUpdateWithoutComplaintsInput>
  }

  export type EmployeesUpdateOneWithoutComplaintsNestedInput = {
    create?: XOR<EmployeesCreateWithoutComplaintsInput, EmployeesUncheckedCreateWithoutComplaintsInput>
    connectOrCreate?: EmployeesCreateOrConnectWithoutComplaintsInput
    upsert?: EmployeesUpsertWithoutComplaintsInput
    disconnect?: EmployeesWhereInput | boolean
    delete?: EmployeesWhereInput | boolean
    connect?: EmployeesWhereUniqueInput
    update?: XOR<XOR<EmployeesUpdateToOneWithWhereWithoutComplaintsInput, EmployeesUpdateWithoutComplaintsInput>, EmployeesUncheckedUpdateWithoutComplaintsInput>
  }

  export type UnitsUpdateOneWithoutComplaintsNestedInput = {
    create?: XOR<UnitsCreateWithoutComplaintsInput, UnitsUncheckedCreateWithoutComplaintsInput>
    connectOrCreate?: UnitsCreateOrConnectWithoutComplaintsInput
    upsert?: UnitsUpsertWithoutComplaintsInput
    disconnect?: UnitsWhereInput | boolean
    delete?: UnitsWhereInput | boolean
    connect?: UnitsWhereUniqueInput
    update?: XOR<XOR<UnitsUpdateToOneWithWhereWithoutComplaintsInput, UnitsUpdateWithoutComplaintsInput>, UnitsUncheckedUpdateWithoutComplaintsInput>
  }

  export type AnnouncementsCreateattachmentsInput = {
    set: string[]
  }

  export type EmployeesCreateNestedOneWithoutAnnouncementsInput = {
    create?: XOR<EmployeesCreateWithoutAnnouncementsInput, EmployeesUncheckedCreateWithoutAnnouncementsInput>
    connectOrCreate?: EmployeesCreateOrConnectWithoutAnnouncementsInput
    connect?: EmployeesWhereUniqueInput
  }

  export type AnnouncementsUpdateattachmentsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EmployeesUpdateOneRequiredWithoutAnnouncementsNestedInput = {
    create?: XOR<EmployeesCreateWithoutAnnouncementsInput, EmployeesUncheckedCreateWithoutAnnouncementsInput>
    connectOrCreate?: EmployeesCreateOrConnectWithoutAnnouncementsInput
    upsert?: EmployeesUpsertWithoutAnnouncementsInput
    connect?: EmployeesWhereUniqueInput
    update?: XOR<XOR<EmployeesUpdateToOneWithWhereWithoutAnnouncementsInput, EmployeesUpdateWithoutAnnouncementsInput>, EmployeesUncheckedUpdateWithoutAnnouncementsInput>
  }

  export type ForumPostsCreateattachmentsInput = {
    set: string[]
  }

  export type UsersCreateNestedOneWithoutForumPostsInput = {
    create?: XOR<UsersCreateWithoutForumPostsInput, UsersUncheckedCreateWithoutForumPostsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutForumPostsInput
    connect?: UsersWhereUniqueInput
  }

  export type PostTagsCreateNestedManyWithoutPostsInput = {
    create?: XOR<PostTagsCreateWithoutPostsInput, PostTagsUncheckedCreateWithoutPostsInput> | PostTagsCreateWithoutPostsInput[] | PostTagsUncheckedCreateWithoutPostsInput[]
    connectOrCreate?: PostTagsCreateOrConnectWithoutPostsInput | PostTagsCreateOrConnectWithoutPostsInput[]
    connect?: PostTagsWhereUniqueInput | PostTagsWhereUniqueInput[]
  }

  export type ForumCommentsCreateNestedManyWithoutPostInput = {
    create?: XOR<ForumCommentsCreateWithoutPostInput, ForumCommentsUncheckedCreateWithoutPostInput> | ForumCommentsCreateWithoutPostInput[] | ForumCommentsUncheckedCreateWithoutPostInput[]
    connectOrCreate?: ForumCommentsCreateOrConnectWithoutPostInput | ForumCommentsCreateOrConnectWithoutPostInput[]
    createMany?: ForumCommentsCreateManyPostInputEnvelope
    connect?: ForumCommentsWhereUniqueInput | ForumCommentsWhereUniqueInput[]
  }

  export type PostTagsUncheckedCreateNestedManyWithoutPostsInput = {
    create?: XOR<PostTagsCreateWithoutPostsInput, PostTagsUncheckedCreateWithoutPostsInput> | PostTagsCreateWithoutPostsInput[] | PostTagsUncheckedCreateWithoutPostsInput[]
    connectOrCreate?: PostTagsCreateOrConnectWithoutPostsInput | PostTagsCreateOrConnectWithoutPostsInput[]
    connect?: PostTagsWhereUniqueInput | PostTagsWhereUniqueInput[]
  }

  export type ForumCommentsUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<ForumCommentsCreateWithoutPostInput, ForumCommentsUncheckedCreateWithoutPostInput> | ForumCommentsCreateWithoutPostInput[] | ForumCommentsUncheckedCreateWithoutPostInput[]
    connectOrCreate?: ForumCommentsCreateOrConnectWithoutPostInput | ForumCommentsCreateOrConnectWithoutPostInput[]
    createMany?: ForumCommentsCreateManyPostInputEnvelope
    connect?: ForumCommentsWhereUniqueInput | ForumCommentsWhereUniqueInput[]
  }

  export type ForumPostsUpdateattachmentsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UsersUpdateOneRequiredWithoutForumPostsNestedInput = {
    create?: XOR<UsersCreateWithoutForumPostsInput, UsersUncheckedCreateWithoutForumPostsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutForumPostsInput
    upsert?: UsersUpsertWithoutForumPostsInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutForumPostsInput, UsersUpdateWithoutForumPostsInput>, UsersUncheckedUpdateWithoutForumPostsInput>
  }

  export type PostTagsUpdateManyWithoutPostsNestedInput = {
    create?: XOR<PostTagsCreateWithoutPostsInput, PostTagsUncheckedCreateWithoutPostsInput> | PostTagsCreateWithoutPostsInput[] | PostTagsUncheckedCreateWithoutPostsInput[]
    connectOrCreate?: PostTagsCreateOrConnectWithoutPostsInput | PostTagsCreateOrConnectWithoutPostsInput[]
    upsert?: PostTagsUpsertWithWhereUniqueWithoutPostsInput | PostTagsUpsertWithWhereUniqueWithoutPostsInput[]
    set?: PostTagsWhereUniqueInput | PostTagsWhereUniqueInput[]
    disconnect?: PostTagsWhereUniqueInput | PostTagsWhereUniqueInput[]
    delete?: PostTagsWhereUniqueInput | PostTagsWhereUniqueInput[]
    connect?: PostTagsWhereUniqueInput | PostTagsWhereUniqueInput[]
    update?: PostTagsUpdateWithWhereUniqueWithoutPostsInput | PostTagsUpdateWithWhereUniqueWithoutPostsInput[]
    updateMany?: PostTagsUpdateManyWithWhereWithoutPostsInput | PostTagsUpdateManyWithWhereWithoutPostsInput[]
    deleteMany?: PostTagsScalarWhereInput | PostTagsScalarWhereInput[]
  }

  export type ForumCommentsUpdateManyWithoutPostNestedInput = {
    create?: XOR<ForumCommentsCreateWithoutPostInput, ForumCommentsUncheckedCreateWithoutPostInput> | ForumCommentsCreateWithoutPostInput[] | ForumCommentsUncheckedCreateWithoutPostInput[]
    connectOrCreate?: ForumCommentsCreateOrConnectWithoutPostInput | ForumCommentsCreateOrConnectWithoutPostInput[]
    upsert?: ForumCommentsUpsertWithWhereUniqueWithoutPostInput | ForumCommentsUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: ForumCommentsCreateManyPostInputEnvelope
    set?: ForumCommentsWhereUniqueInput | ForumCommentsWhereUniqueInput[]
    disconnect?: ForumCommentsWhereUniqueInput | ForumCommentsWhereUniqueInput[]
    delete?: ForumCommentsWhereUniqueInput | ForumCommentsWhereUniqueInput[]
    connect?: ForumCommentsWhereUniqueInput | ForumCommentsWhereUniqueInput[]
    update?: ForumCommentsUpdateWithWhereUniqueWithoutPostInput | ForumCommentsUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: ForumCommentsUpdateManyWithWhereWithoutPostInput | ForumCommentsUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: ForumCommentsScalarWhereInput | ForumCommentsScalarWhereInput[]
  }

  export type PostTagsUncheckedUpdateManyWithoutPostsNestedInput = {
    create?: XOR<PostTagsCreateWithoutPostsInput, PostTagsUncheckedCreateWithoutPostsInput> | PostTagsCreateWithoutPostsInput[] | PostTagsUncheckedCreateWithoutPostsInput[]
    connectOrCreate?: PostTagsCreateOrConnectWithoutPostsInput | PostTagsCreateOrConnectWithoutPostsInput[]
    upsert?: PostTagsUpsertWithWhereUniqueWithoutPostsInput | PostTagsUpsertWithWhereUniqueWithoutPostsInput[]
    set?: PostTagsWhereUniqueInput | PostTagsWhereUniqueInput[]
    disconnect?: PostTagsWhereUniqueInput | PostTagsWhereUniqueInput[]
    delete?: PostTagsWhereUniqueInput | PostTagsWhereUniqueInput[]
    connect?: PostTagsWhereUniqueInput | PostTagsWhereUniqueInput[]
    update?: PostTagsUpdateWithWhereUniqueWithoutPostsInput | PostTagsUpdateWithWhereUniqueWithoutPostsInput[]
    updateMany?: PostTagsUpdateManyWithWhereWithoutPostsInput | PostTagsUpdateManyWithWhereWithoutPostsInput[]
    deleteMany?: PostTagsScalarWhereInput | PostTagsScalarWhereInput[]
  }

  export type ForumCommentsUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<ForumCommentsCreateWithoutPostInput, ForumCommentsUncheckedCreateWithoutPostInput> | ForumCommentsCreateWithoutPostInput[] | ForumCommentsUncheckedCreateWithoutPostInput[]
    connectOrCreate?: ForumCommentsCreateOrConnectWithoutPostInput | ForumCommentsCreateOrConnectWithoutPostInput[]
    upsert?: ForumCommentsUpsertWithWhereUniqueWithoutPostInput | ForumCommentsUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: ForumCommentsCreateManyPostInputEnvelope
    set?: ForumCommentsWhereUniqueInput | ForumCommentsWhereUniqueInput[]
    disconnect?: ForumCommentsWhereUniqueInput | ForumCommentsWhereUniqueInput[]
    delete?: ForumCommentsWhereUniqueInput | ForumCommentsWhereUniqueInput[]
    connect?: ForumCommentsWhereUniqueInput | ForumCommentsWhereUniqueInput[]
    update?: ForumCommentsUpdateWithWhereUniqueWithoutPostInput | ForumCommentsUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: ForumCommentsUpdateManyWithWhereWithoutPostInput | ForumCommentsUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: ForumCommentsScalarWhereInput | ForumCommentsScalarWhereInput[]
  }

  export type ForumPostsCreateNestedManyWithoutTagsInput = {
    create?: XOR<ForumPostsCreateWithoutTagsInput, ForumPostsUncheckedCreateWithoutTagsInput> | ForumPostsCreateWithoutTagsInput[] | ForumPostsUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: ForumPostsCreateOrConnectWithoutTagsInput | ForumPostsCreateOrConnectWithoutTagsInput[]
    connect?: ForumPostsWhereUniqueInput | ForumPostsWhereUniqueInput[]
  }

  export type ForumPostsUncheckedCreateNestedManyWithoutTagsInput = {
    create?: XOR<ForumPostsCreateWithoutTagsInput, ForumPostsUncheckedCreateWithoutTagsInput> | ForumPostsCreateWithoutTagsInput[] | ForumPostsUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: ForumPostsCreateOrConnectWithoutTagsInput | ForumPostsCreateOrConnectWithoutTagsInput[]
    connect?: ForumPostsWhereUniqueInput | ForumPostsWhereUniqueInput[]
  }

  export type ForumPostsUpdateManyWithoutTagsNestedInput = {
    create?: XOR<ForumPostsCreateWithoutTagsInput, ForumPostsUncheckedCreateWithoutTagsInput> | ForumPostsCreateWithoutTagsInput[] | ForumPostsUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: ForumPostsCreateOrConnectWithoutTagsInput | ForumPostsCreateOrConnectWithoutTagsInput[]
    upsert?: ForumPostsUpsertWithWhereUniqueWithoutTagsInput | ForumPostsUpsertWithWhereUniqueWithoutTagsInput[]
    set?: ForumPostsWhereUniqueInput | ForumPostsWhereUniqueInput[]
    disconnect?: ForumPostsWhereUniqueInput | ForumPostsWhereUniqueInput[]
    delete?: ForumPostsWhereUniqueInput | ForumPostsWhereUniqueInput[]
    connect?: ForumPostsWhereUniqueInput | ForumPostsWhereUniqueInput[]
    update?: ForumPostsUpdateWithWhereUniqueWithoutTagsInput | ForumPostsUpdateWithWhereUniqueWithoutTagsInput[]
    updateMany?: ForumPostsUpdateManyWithWhereWithoutTagsInput | ForumPostsUpdateManyWithWhereWithoutTagsInput[]
    deleteMany?: ForumPostsScalarWhereInput | ForumPostsScalarWhereInput[]
  }

  export type ForumPostsUncheckedUpdateManyWithoutTagsNestedInput = {
    create?: XOR<ForumPostsCreateWithoutTagsInput, ForumPostsUncheckedCreateWithoutTagsInput> | ForumPostsCreateWithoutTagsInput[] | ForumPostsUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: ForumPostsCreateOrConnectWithoutTagsInput | ForumPostsCreateOrConnectWithoutTagsInput[]
    upsert?: ForumPostsUpsertWithWhereUniqueWithoutTagsInput | ForumPostsUpsertWithWhereUniqueWithoutTagsInput[]
    set?: ForumPostsWhereUniqueInput | ForumPostsWhereUniqueInput[]
    disconnect?: ForumPostsWhereUniqueInput | ForumPostsWhereUniqueInput[]
    delete?: ForumPostsWhereUniqueInput | ForumPostsWhereUniqueInput[]
    connect?: ForumPostsWhereUniqueInput | ForumPostsWhereUniqueInput[]
    update?: ForumPostsUpdateWithWhereUniqueWithoutTagsInput | ForumPostsUpdateWithWhereUniqueWithoutTagsInput[]
    updateMany?: ForumPostsUpdateManyWithWhereWithoutTagsInput | ForumPostsUpdateManyWithWhereWithoutTagsInput[]
    deleteMany?: ForumPostsScalarWhereInput | ForumPostsScalarWhereInput[]
  }

  export type UsersCreateNestedOneWithoutForumCommentsInput = {
    create?: XOR<UsersCreateWithoutForumCommentsInput, UsersUncheckedCreateWithoutForumCommentsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutForumCommentsInput
    connect?: UsersWhereUniqueInput
  }

  export type ForumPostsCreateNestedOneWithoutCommentsInput = {
    create?: XOR<ForumPostsCreateWithoutCommentsInput, ForumPostsUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: ForumPostsCreateOrConnectWithoutCommentsInput
    connect?: ForumPostsWhereUniqueInput
  }

  export type UsersUpdateOneRequiredWithoutForumCommentsNestedInput = {
    create?: XOR<UsersCreateWithoutForumCommentsInput, UsersUncheckedCreateWithoutForumCommentsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutForumCommentsInput
    upsert?: UsersUpsertWithoutForumCommentsInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutForumCommentsInput, UsersUpdateWithoutForumCommentsInput>, UsersUncheckedUpdateWithoutForumCommentsInput>
  }

  export type ForumPostsUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<ForumPostsCreateWithoutCommentsInput, ForumPostsUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: ForumPostsCreateOrConnectWithoutCommentsInput
    upsert?: ForumPostsUpsertWithoutCommentsInput
    connect?: ForumPostsWhereUniqueInput
    update?: XOR<XOR<ForumPostsUpdateToOneWithWhereWithoutCommentsInput, ForumPostsUpdateWithoutCommentsInput>, ForumPostsUncheckedUpdateWithoutCommentsInput>
  }

  export type ResidentsCreateNestedManyWithoutUnitInput = {
    create?: XOR<ResidentsCreateWithoutUnitInput, ResidentsUncheckedCreateWithoutUnitInput> | ResidentsCreateWithoutUnitInput[] | ResidentsUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: ResidentsCreateOrConnectWithoutUnitInput | ResidentsCreateOrConnectWithoutUnitInput[]
    createMany?: ResidentsCreateManyUnitInputEnvelope
    connect?: ResidentsWhereUniqueInput | ResidentsWhereUniqueInput[]
  }

  export type PaymentsCreateNestedManyWithoutUnitInput = {
    create?: XOR<PaymentsCreateWithoutUnitInput, PaymentsUncheckedCreateWithoutUnitInput> | PaymentsCreateWithoutUnitInput[] | PaymentsUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: PaymentsCreateOrConnectWithoutUnitInput | PaymentsCreateOrConnectWithoutUnitInput[]
    createMany?: PaymentsCreateManyUnitInputEnvelope
    connect?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
  }

  export type BillsCreateNestedManyWithoutUnitInput = {
    create?: XOR<BillsCreateWithoutUnitInput, BillsUncheckedCreateWithoutUnitInput> | BillsCreateWithoutUnitInput[] | BillsUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: BillsCreateOrConnectWithoutUnitInput | BillsCreateOrConnectWithoutUnitInput[]
    createMany?: BillsCreateManyUnitInputEnvelope
    connect?: BillsWhereUniqueInput | BillsWhereUniqueInput[]
  }

  export type ComplaintsCreateNestedManyWithoutUnitInput = {
    create?: XOR<ComplaintsCreateWithoutUnitInput, ComplaintsUncheckedCreateWithoutUnitInput> | ComplaintsCreateWithoutUnitInput[] | ComplaintsUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: ComplaintsCreateOrConnectWithoutUnitInput | ComplaintsCreateOrConnectWithoutUnitInput[]
    createMany?: ComplaintsCreateManyUnitInputEnvelope
    connect?: ComplaintsWhereUniqueInput | ComplaintsWhereUniqueInput[]
  }

  export type ResidentsUncheckedCreateNestedManyWithoutUnitInput = {
    create?: XOR<ResidentsCreateWithoutUnitInput, ResidentsUncheckedCreateWithoutUnitInput> | ResidentsCreateWithoutUnitInput[] | ResidentsUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: ResidentsCreateOrConnectWithoutUnitInput | ResidentsCreateOrConnectWithoutUnitInput[]
    createMany?: ResidentsCreateManyUnitInputEnvelope
    connect?: ResidentsWhereUniqueInput | ResidentsWhereUniqueInput[]
  }

  export type PaymentsUncheckedCreateNestedManyWithoutUnitInput = {
    create?: XOR<PaymentsCreateWithoutUnitInput, PaymentsUncheckedCreateWithoutUnitInput> | PaymentsCreateWithoutUnitInput[] | PaymentsUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: PaymentsCreateOrConnectWithoutUnitInput | PaymentsCreateOrConnectWithoutUnitInput[]
    createMany?: PaymentsCreateManyUnitInputEnvelope
    connect?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
  }

  export type BillsUncheckedCreateNestedManyWithoutUnitInput = {
    create?: XOR<BillsCreateWithoutUnitInput, BillsUncheckedCreateWithoutUnitInput> | BillsCreateWithoutUnitInput[] | BillsUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: BillsCreateOrConnectWithoutUnitInput | BillsCreateOrConnectWithoutUnitInput[]
    createMany?: BillsCreateManyUnitInputEnvelope
    connect?: BillsWhereUniqueInput | BillsWhereUniqueInput[]
  }

  export type ComplaintsUncheckedCreateNestedManyWithoutUnitInput = {
    create?: XOR<ComplaintsCreateWithoutUnitInput, ComplaintsUncheckedCreateWithoutUnitInput> | ComplaintsCreateWithoutUnitInput[] | ComplaintsUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: ComplaintsCreateOrConnectWithoutUnitInput | ComplaintsCreateOrConnectWithoutUnitInput[]
    createMany?: ComplaintsCreateManyUnitInputEnvelope
    connect?: ComplaintsWhereUniqueInput | ComplaintsWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumUnitStatusFieldUpdateOperationsInput = {
    set?: $Enums.UnitStatus
  }

  export type ResidentsUpdateManyWithoutUnitNestedInput = {
    create?: XOR<ResidentsCreateWithoutUnitInput, ResidentsUncheckedCreateWithoutUnitInput> | ResidentsCreateWithoutUnitInput[] | ResidentsUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: ResidentsCreateOrConnectWithoutUnitInput | ResidentsCreateOrConnectWithoutUnitInput[]
    upsert?: ResidentsUpsertWithWhereUniqueWithoutUnitInput | ResidentsUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: ResidentsCreateManyUnitInputEnvelope
    set?: ResidentsWhereUniqueInput | ResidentsWhereUniqueInput[]
    disconnect?: ResidentsWhereUniqueInput | ResidentsWhereUniqueInput[]
    delete?: ResidentsWhereUniqueInput | ResidentsWhereUniqueInput[]
    connect?: ResidentsWhereUniqueInput | ResidentsWhereUniqueInput[]
    update?: ResidentsUpdateWithWhereUniqueWithoutUnitInput | ResidentsUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: ResidentsUpdateManyWithWhereWithoutUnitInput | ResidentsUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: ResidentsScalarWhereInput | ResidentsScalarWhereInput[]
  }

  export type PaymentsUpdateManyWithoutUnitNestedInput = {
    create?: XOR<PaymentsCreateWithoutUnitInput, PaymentsUncheckedCreateWithoutUnitInput> | PaymentsCreateWithoutUnitInput[] | PaymentsUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: PaymentsCreateOrConnectWithoutUnitInput | PaymentsCreateOrConnectWithoutUnitInput[]
    upsert?: PaymentsUpsertWithWhereUniqueWithoutUnitInput | PaymentsUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: PaymentsCreateManyUnitInputEnvelope
    set?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    disconnect?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    delete?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    connect?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    update?: PaymentsUpdateWithWhereUniqueWithoutUnitInput | PaymentsUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: PaymentsUpdateManyWithWhereWithoutUnitInput | PaymentsUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: PaymentsScalarWhereInput | PaymentsScalarWhereInput[]
  }

  export type BillsUpdateManyWithoutUnitNestedInput = {
    create?: XOR<BillsCreateWithoutUnitInput, BillsUncheckedCreateWithoutUnitInput> | BillsCreateWithoutUnitInput[] | BillsUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: BillsCreateOrConnectWithoutUnitInput | BillsCreateOrConnectWithoutUnitInput[]
    upsert?: BillsUpsertWithWhereUniqueWithoutUnitInput | BillsUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: BillsCreateManyUnitInputEnvelope
    set?: BillsWhereUniqueInput | BillsWhereUniqueInput[]
    disconnect?: BillsWhereUniqueInput | BillsWhereUniqueInput[]
    delete?: BillsWhereUniqueInput | BillsWhereUniqueInput[]
    connect?: BillsWhereUniqueInput | BillsWhereUniqueInput[]
    update?: BillsUpdateWithWhereUniqueWithoutUnitInput | BillsUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: BillsUpdateManyWithWhereWithoutUnitInput | BillsUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: BillsScalarWhereInput | BillsScalarWhereInput[]
  }

  export type ComplaintsUpdateManyWithoutUnitNestedInput = {
    create?: XOR<ComplaintsCreateWithoutUnitInput, ComplaintsUncheckedCreateWithoutUnitInput> | ComplaintsCreateWithoutUnitInput[] | ComplaintsUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: ComplaintsCreateOrConnectWithoutUnitInput | ComplaintsCreateOrConnectWithoutUnitInput[]
    upsert?: ComplaintsUpsertWithWhereUniqueWithoutUnitInput | ComplaintsUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: ComplaintsCreateManyUnitInputEnvelope
    set?: ComplaintsWhereUniqueInput | ComplaintsWhereUniqueInput[]
    disconnect?: ComplaintsWhereUniqueInput | ComplaintsWhereUniqueInput[]
    delete?: ComplaintsWhereUniqueInput | ComplaintsWhereUniqueInput[]
    connect?: ComplaintsWhereUniqueInput | ComplaintsWhereUniqueInput[]
    update?: ComplaintsUpdateWithWhereUniqueWithoutUnitInput | ComplaintsUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: ComplaintsUpdateManyWithWhereWithoutUnitInput | ComplaintsUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: ComplaintsScalarWhereInput | ComplaintsScalarWhereInput[]
  }

  export type ResidentsUncheckedUpdateManyWithoutUnitNestedInput = {
    create?: XOR<ResidentsCreateWithoutUnitInput, ResidentsUncheckedCreateWithoutUnitInput> | ResidentsCreateWithoutUnitInput[] | ResidentsUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: ResidentsCreateOrConnectWithoutUnitInput | ResidentsCreateOrConnectWithoutUnitInput[]
    upsert?: ResidentsUpsertWithWhereUniqueWithoutUnitInput | ResidentsUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: ResidentsCreateManyUnitInputEnvelope
    set?: ResidentsWhereUniqueInput | ResidentsWhereUniqueInput[]
    disconnect?: ResidentsWhereUniqueInput | ResidentsWhereUniqueInput[]
    delete?: ResidentsWhereUniqueInput | ResidentsWhereUniqueInput[]
    connect?: ResidentsWhereUniqueInput | ResidentsWhereUniqueInput[]
    update?: ResidentsUpdateWithWhereUniqueWithoutUnitInput | ResidentsUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: ResidentsUpdateManyWithWhereWithoutUnitInput | ResidentsUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: ResidentsScalarWhereInput | ResidentsScalarWhereInput[]
  }

  export type PaymentsUncheckedUpdateManyWithoutUnitNestedInput = {
    create?: XOR<PaymentsCreateWithoutUnitInput, PaymentsUncheckedCreateWithoutUnitInput> | PaymentsCreateWithoutUnitInput[] | PaymentsUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: PaymentsCreateOrConnectWithoutUnitInput | PaymentsCreateOrConnectWithoutUnitInput[]
    upsert?: PaymentsUpsertWithWhereUniqueWithoutUnitInput | PaymentsUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: PaymentsCreateManyUnitInputEnvelope
    set?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    disconnect?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    delete?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    connect?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    update?: PaymentsUpdateWithWhereUniqueWithoutUnitInput | PaymentsUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: PaymentsUpdateManyWithWhereWithoutUnitInput | PaymentsUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: PaymentsScalarWhereInput | PaymentsScalarWhereInput[]
  }

  export type BillsUncheckedUpdateManyWithoutUnitNestedInput = {
    create?: XOR<BillsCreateWithoutUnitInput, BillsUncheckedCreateWithoutUnitInput> | BillsCreateWithoutUnitInput[] | BillsUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: BillsCreateOrConnectWithoutUnitInput | BillsCreateOrConnectWithoutUnitInput[]
    upsert?: BillsUpsertWithWhereUniqueWithoutUnitInput | BillsUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: BillsCreateManyUnitInputEnvelope
    set?: BillsWhereUniqueInput | BillsWhereUniqueInput[]
    disconnect?: BillsWhereUniqueInput | BillsWhereUniqueInput[]
    delete?: BillsWhereUniqueInput | BillsWhereUniqueInput[]
    connect?: BillsWhereUniqueInput | BillsWhereUniqueInput[]
    update?: BillsUpdateWithWhereUniqueWithoutUnitInput | BillsUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: BillsUpdateManyWithWhereWithoutUnitInput | BillsUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: BillsScalarWhereInput | BillsScalarWhereInput[]
  }

  export type ComplaintsUncheckedUpdateManyWithoutUnitNestedInput = {
    create?: XOR<ComplaintsCreateWithoutUnitInput, ComplaintsUncheckedCreateWithoutUnitInput> | ComplaintsCreateWithoutUnitInput[] | ComplaintsUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: ComplaintsCreateOrConnectWithoutUnitInput | ComplaintsCreateOrConnectWithoutUnitInput[]
    upsert?: ComplaintsUpsertWithWhereUniqueWithoutUnitInput | ComplaintsUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: ComplaintsCreateManyUnitInputEnvelope
    set?: ComplaintsWhereUniqueInput | ComplaintsWhereUniqueInput[]
    disconnect?: ComplaintsWhereUniqueInput | ComplaintsWhereUniqueInput[]
    delete?: ComplaintsWhereUniqueInput | ComplaintsWhereUniqueInput[]
    connect?: ComplaintsWhereUniqueInput | ComplaintsWhereUniqueInput[]
    update?: ComplaintsUpdateWithWhereUniqueWithoutUnitInput | ComplaintsUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: ComplaintsUpdateManyWithWhereWithoutUnitInput | ComplaintsUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: ComplaintsScalarWhereInput | ComplaintsScalarWhereInput[]
  }

  export type UnitsCreateNestedOneWithoutBillsInput = {
    create?: XOR<UnitsCreateWithoutBillsInput, UnitsUncheckedCreateWithoutBillsInput>
    connectOrCreate?: UnitsCreateOrConnectWithoutBillsInput
    connect?: UnitsWhereUniqueInput
  }

  export type EmployeesCreateNestedOneWithoutBillsInput = {
    create?: XOR<EmployeesCreateWithoutBillsInput, EmployeesUncheckedCreateWithoutBillsInput>
    connectOrCreate?: EmployeesCreateOrConnectWithoutBillsInput
    connect?: EmployeesWhereUniqueInput
  }

  export type PaymentsCreateNestedManyWithoutBillInput = {
    create?: XOR<PaymentsCreateWithoutBillInput, PaymentsUncheckedCreateWithoutBillInput> | PaymentsCreateWithoutBillInput[] | PaymentsUncheckedCreateWithoutBillInput[]
    connectOrCreate?: PaymentsCreateOrConnectWithoutBillInput | PaymentsCreateOrConnectWithoutBillInput[]
    createMany?: PaymentsCreateManyBillInputEnvelope
    connect?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
  }

  export type PaymentsUncheckedCreateNestedManyWithoutBillInput = {
    create?: XOR<PaymentsCreateWithoutBillInput, PaymentsUncheckedCreateWithoutBillInput> | PaymentsCreateWithoutBillInput[] | PaymentsUncheckedCreateWithoutBillInput[]
    connectOrCreate?: PaymentsCreateOrConnectWithoutBillInput | PaymentsCreateOrConnectWithoutBillInput[]
    createMany?: PaymentsCreateManyBillInputEnvelope
    connect?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
  }

  export type EnumPaymentTypeFieldUpdateOperationsInput = {
    set?: $Enums.PaymentType
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type UnitsUpdateOneRequiredWithoutBillsNestedInput = {
    create?: XOR<UnitsCreateWithoutBillsInput, UnitsUncheckedCreateWithoutBillsInput>
    connectOrCreate?: UnitsCreateOrConnectWithoutBillsInput
    upsert?: UnitsUpsertWithoutBillsInput
    connect?: UnitsWhereUniqueInput
    update?: XOR<XOR<UnitsUpdateToOneWithWhereWithoutBillsInput, UnitsUpdateWithoutBillsInput>, UnitsUncheckedUpdateWithoutBillsInput>
  }

  export type EmployeesUpdateOneRequiredWithoutBillsNestedInput = {
    create?: XOR<EmployeesCreateWithoutBillsInput, EmployeesUncheckedCreateWithoutBillsInput>
    connectOrCreate?: EmployeesCreateOrConnectWithoutBillsInput
    upsert?: EmployeesUpsertWithoutBillsInput
    connect?: EmployeesWhereUniqueInput
    update?: XOR<XOR<EmployeesUpdateToOneWithWhereWithoutBillsInput, EmployeesUpdateWithoutBillsInput>, EmployeesUncheckedUpdateWithoutBillsInput>
  }

  export type PaymentsUpdateManyWithoutBillNestedInput = {
    create?: XOR<PaymentsCreateWithoutBillInput, PaymentsUncheckedCreateWithoutBillInput> | PaymentsCreateWithoutBillInput[] | PaymentsUncheckedCreateWithoutBillInput[]
    connectOrCreate?: PaymentsCreateOrConnectWithoutBillInput | PaymentsCreateOrConnectWithoutBillInput[]
    upsert?: PaymentsUpsertWithWhereUniqueWithoutBillInput | PaymentsUpsertWithWhereUniqueWithoutBillInput[]
    createMany?: PaymentsCreateManyBillInputEnvelope
    set?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    disconnect?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    delete?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    connect?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    update?: PaymentsUpdateWithWhereUniqueWithoutBillInput | PaymentsUpdateWithWhereUniqueWithoutBillInput[]
    updateMany?: PaymentsUpdateManyWithWhereWithoutBillInput | PaymentsUpdateManyWithWhereWithoutBillInput[]
    deleteMany?: PaymentsScalarWhereInput | PaymentsScalarWhereInput[]
  }

  export type PaymentsUncheckedUpdateManyWithoutBillNestedInput = {
    create?: XOR<PaymentsCreateWithoutBillInput, PaymentsUncheckedCreateWithoutBillInput> | PaymentsCreateWithoutBillInput[] | PaymentsUncheckedCreateWithoutBillInput[]
    connectOrCreate?: PaymentsCreateOrConnectWithoutBillInput | PaymentsCreateOrConnectWithoutBillInput[]
    upsert?: PaymentsUpsertWithWhereUniqueWithoutBillInput | PaymentsUpsertWithWhereUniqueWithoutBillInput[]
    createMany?: PaymentsCreateManyBillInputEnvelope
    set?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    disconnect?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    delete?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    connect?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    update?: PaymentsUpdateWithWhereUniqueWithoutBillInput | PaymentsUpdateWithWhereUniqueWithoutBillInput[]
    updateMany?: PaymentsUpdateManyWithWhereWithoutBillInput | PaymentsUpdateManyWithWhereWithoutBillInput[]
    deleteMany?: PaymentsScalarWhereInput | PaymentsScalarWhereInput[]
  }

  export type ResidentsCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<ResidentsCreateWithoutPaymentsInput, ResidentsUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: ResidentsCreateOrConnectWithoutPaymentsInput
    connect?: ResidentsWhereUniqueInput
  }

  export type UnitsCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<UnitsCreateWithoutPaymentsInput, UnitsUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: UnitsCreateOrConnectWithoutPaymentsInput
    connect?: UnitsWhereUniqueInput
  }

  export type EmployeesCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<EmployeesCreateWithoutPaymentsInput, EmployeesUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: EmployeesCreateOrConnectWithoutPaymentsInput
    connect?: EmployeesWhereUniqueInput
  }

  export type BillsCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<BillsCreateWithoutPaymentsInput, BillsUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: BillsCreateOrConnectWithoutPaymentsInput
    connect?: BillsWhereUniqueInput
  }

  export type EnumPaymentMethodFieldUpdateOperationsInput = {
    set?: $Enums.PaymentMethod
  }

  export type EnumPaymentStatusFieldUpdateOperationsInput = {
    set?: $Enums.PaymentStatus
  }

  export type ResidentsUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<ResidentsCreateWithoutPaymentsInput, ResidentsUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: ResidentsCreateOrConnectWithoutPaymentsInput
    upsert?: ResidentsUpsertWithoutPaymentsInput
    connect?: ResidentsWhereUniqueInput
    update?: XOR<XOR<ResidentsUpdateToOneWithWhereWithoutPaymentsInput, ResidentsUpdateWithoutPaymentsInput>, ResidentsUncheckedUpdateWithoutPaymentsInput>
  }

  export type UnitsUpdateOneWithoutPaymentsNestedInput = {
    create?: XOR<UnitsCreateWithoutPaymentsInput, UnitsUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: UnitsCreateOrConnectWithoutPaymentsInput
    upsert?: UnitsUpsertWithoutPaymentsInput
    disconnect?: UnitsWhereInput | boolean
    delete?: UnitsWhereInput | boolean
    connect?: UnitsWhereUniqueInput
    update?: XOR<XOR<UnitsUpdateToOneWithWhereWithoutPaymentsInput, UnitsUpdateWithoutPaymentsInput>, UnitsUncheckedUpdateWithoutPaymentsInput>
  }

  export type EmployeesUpdateOneWithoutPaymentsNestedInput = {
    create?: XOR<EmployeesCreateWithoutPaymentsInput, EmployeesUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: EmployeesCreateOrConnectWithoutPaymentsInput
    upsert?: EmployeesUpsertWithoutPaymentsInput
    disconnect?: EmployeesWhereInput | boolean
    delete?: EmployeesWhereInput | boolean
    connect?: EmployeesWhereUniqueInput
    update?: XOR<XOR<EmployeesUpdateToOneWithWhereWithoutPaymentsInput, EmployeesUpdateWithoutPaymentsInput>, EmployeesUncheckedUpdateWithoutPaymentsInput>
  }

  export type BillsUpdateOneWithoutPaymentsNestedInput = {
    create?: XOR<BillsCreateWithoutPaymentsInput, BillsUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: BillsCreateOrConnectWithoutPaymentsInput
    upsert?: BillsUpsertWithoutPaymentsInput
    disconnect?: BillsWhereInput | boolean
    delete?: BillsWhereInput | boolean
    connect?: BillsWhereUniqueInput
    update?: XOR<XOR<BillsUpdateToOneWithWhereWithoutPaymentsInput, BillsUpdateWithoutPaymentsInput>, BillsUncheckedUpdateWithoutPaymentsInput>
  }

  export type EnumContactRoleFieldUpdateOperationsInput = {
    set?: $Enums.ContactRole
  }

  export type EmployeesCreateNestedOneWithoutSecurityReportsInput = {
    create?: XOR<EmployeesCreateWithoutSecurityReportsInput, EmployeesUncheckedCreateWithoutSecurityReportsInput>
    connectOrCreate?: EmployeesCreateOrConnectWithoutSecurityReportsInput
    connect?: EmployeesWhereUniqueInput
  }

  export type EnumMaintenanceStatusFieldUpdateOperationsInput = {
    set?: $Enums.MaintenanceStatus
  }

  export type EmployeesUpdateOneRequiredWithoutSecurityReportsNestedInput = {
    create?: XOR<EmployeesCreateWithoutSecurityReportsInput, EmployeesUncheckedCreateWithoutSecurityReportsInput>
    connectOrCreate?: EmployeesCreateOrConnectWithoutSecurityReportsInput
    upsert?: EmployeesUpsertWithoutSecurityReportsInput
    connect?: EmployeesWhereUniqueInput
    update?: XOR<XOR<EmployeesUpdateToOneWithWhereWithoutSecurityReportsInput, EmployeesUpdateWithoutSecurityReportsInput>, EmployeesUncheckedUpdateWithoutSecurityReportsInput>
  }

  export type NestedUuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedEnumGenderNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGenderNullableFilter<$PrismaModel> | $Enums.Gender | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedUuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedEnumGenderNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGenderNullableWithAggregatesFilter<$PrismaModel> | $Enums.Gender | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumGenderNullableFilter<$PrismaModel>
    _max?: NestedEnumGenderNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumResidentStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ResidentStatus | EnumResidentStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.ResidentStatus[] | ListEnumResidentStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ResidentStatus[] | ListEnumResidentStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumResidentStatusNullableFilter<$PrismaModel> | $Enums.ResidentStatus | null
  }

  export type NestedUuidNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidNullableFilter<$PrismaModel> | string | null
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedEnumResidentStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ResidentStatus | EnumResidentStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.ResidentStatus[] | ListEnumResidentStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ResidentStatus[] | ListEnumResidentStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumResidentStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.ResidentStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumResidentStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumResidentStatusNullableFilter<$PrismaModel>
  }

  export type NestedUuidNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedEnumEmployeeRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.EmployeeRole | EnumEmployeeRoleFieldRefInput<$PrismaModel>
    in?: $Enums.EmployeeRole[] | ListEnumEmployeeRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.EmployeeRole[] | ListEnumEmployeeRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumEmployeeRoleFilter<$PrismaModel> | $Enums.EmployeeRole
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumEmployeeRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EmployeeRole | EnumEmployeeRoleFieldRefInput<$PrismaModel>
    in?: $Enums.EmployeeRole[] | ListEnumEmployeeRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.EmployeeRole[] | ListEnumEmployeeRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumEmployeeRoleWithAggregatesFilter<$PrismaModel> | $Enums.EmployeeRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEmployeeRoleFilter<$PrismaModel>
    _max?: NestedEnumEmployeeRoleFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumMaintenanceCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.MaintenanceCategory | EnumMaintenanceCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.MaintenanceCategory[] | ListEnumMaintenanceCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.MaintenanceCategory[] | ListEnumMaintenanceCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumMaintenanceCategoryFilter<$PrismaModel> | $Enums.MaintenanceCategory
  }

  export type NestedEnumComplaintStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ComplaintStatus | EnumComplaintStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ComplaintStatus[] | ListEnumComplaintStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ComplaintStatus[] | ListEnumComplaintStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumComplaintStatusFilter<$PrismaModel> | $Enums.ComplaintStatus
  }

  export type NestedEnumMaintenanceCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MaintenanceCategory | EnumMaintenanceCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.MaintenanceCategory[] | ListEnumMaintenanceCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.MaintenanceCategory[] | ListEnumMaintenanceCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumMaintenanceCategoryWithAggregatesFilter<$PrismaModel> | $Enums.MaintenanceCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMaintenanceCategoryFilter<$PrismaModel>
    _max?: NestedEnumMaintenanceCategoryFilter<$PrismaModel>
  }

  export type NestedEnumComplaintStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ComplaintStatus | EnumComplaintStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ComplaintStatus[] | ListEnumComplaintStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ComplaintStatus[] | ListEnumComplaintStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumComplaintStatusWithAggregatesFilter<$PrismaModel> | $Enums.ComplaintStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumComplaintStatusFilter<$PrismaModel>
    _max?: NestedEnumComplaintStatusFilter<$PrismaModel>
  }

  export type NestedEnumUnitStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.UnitStatus | EnumUnitStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UnitStatus[] | ListEnumUnitStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UnitStatus[] | ListEnumUnitStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUnitStatusFilter<$PrismaModel> | $Enums.UnitStatus
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedEnumUnitStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UnitStatus | EnumUnitStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UnitStatus[] | ListEnumUnitStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UnitStatus[] | ListEnumUnitStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUnitStatusWithAggregatesFilter<$PrismaModel> | $Enums.UnitStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUnitStatusFilter<$PrismaModel>
    _max?: NestedEnumUnitStatusFilter<$PrismaModel>
  }

  export type NestedEnumPaymentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentType | EnumPaymentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentType[] | ListEnumPaymentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentType[] | ListEnumPaymentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentTypeFilter<$PrismaModel> | $Enums.PaymentType
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumPaymentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentType | EnumPaymentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentType[] | ListEnumPaymentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentType[] | ListEnumPaymentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentTypeWithAggregatesFilter<$PrismaModel> | $Enums.PaymentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentTypeFilter<$PrismaModel>
    _max?: NestedEnumPaymentTypeFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod
  }

  export type NestedEnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodFilter<$PrismaModel>
  }

  export type NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type NestedEnumContactRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.ContactRole | EnumContactRoleFieldRefInput<$PrismaModel>
    in?: $Enums.ContactRole[] | ListEnumContactRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContactRole[] | ListEnumContactRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumContactRoleFilter<$PrismaModel> | $Enums.ContactRole
  }

  export type NestedEnumContactRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContactRole | EnumContactRoleFieldRefInput<$PrismaModel>
    in?: $Enums.ContactRole[] | ListEnumContactRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContactRole[] | ListEnumContactRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumContactRoleWithAggregatesFilter<$PrismaModel> | $Enums.ContactRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumContactRoleFilter<$PrismaModel>
    _max?: NestedEnumContactRoleFilter<$PrismaModel>
  }

  export type NestedEnumMaintenanceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MaintenanceStatus | EnumMaintenanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MaintenanceStatus[] | ListEnumMaintenanceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MaintenanceStatus[] | ListEnumMaintenanceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMaintenanceStatusFilter<$PrismaModel> | $Enums.MaintenanceStatus
  }

  export type NestedEnumMaintenanceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MaintenanceStatus | EnumMaintenanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MaintenanceStatus[] | ListEnumMaintenanceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MaintenanceStatus[] | ListEnumMaintenanceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMaintenanceStatusWithAggregatesFilter<$PrismaModel> | $Enums.MaintenanceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMaintenanceStatusFilter<$PrismaModel>
    _max?: NestedEnumMaintenanceStatusFilter<$PrismaModel>
  }

  export type ResidentsCreateWithoutUserInput = {
    id?: string
    emergencyContactName?: string | null
    emergencyContactNumber?: string | null
    movedInDate: Date | string
    movedOutDate?: Date | string | null
    residentStatus?: $Enums.ResidentStatus | null
    kprPaymentAmount?: number | null
    kprDueDate?: Date | string | null
    isKprPaid?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    unit?: UnitsCreateNestedOneWithoutResidentsInput
    Complaints?: ComplaintsCreateNestedManyWithoutResidentInput
    Payments?: PaymentsCreateNestedManyWithoutResidentInput
  }

  export type ResidentsUncheckedCreateWithoutUserInput = {
    id?: string
    emergencyContactName?: string | null
    emergencyContactNumber?: string | null
    movedInDate: Date | string
    movedOutDate?: Date | string | null
    residentStatus?: $Enums.ResidentStatus | null
    unitId?: string | null
    kprPaymentAmount?: number | null
    kprDueDate?: Date | string | null
    isKprPaid?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Complaints?: ComplaintsUncheckedCreateNestedManyWithoutResidentInput
    Payments?: PaymentsUncheckedCreateNestedManyWithoutResidentInput
  }

  export type ResidentsCreateOrConnectWithoutUserInput = {
    where: ResidentsWhereUniqueInput
    create: XOR<ResidentsCreateWithoutUserInput, ResidentsUncheckedCreateWithoutUserInput>
  }

  export type EmployeesCreateWithoutUserInput = {
    id?: string
    employeeNumberId: string
    hireDate: Date | string
    employeePosition?: $Enums.EmployeeRole
    workingHours: number
    salary: number
    bonus?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Announcements?: AnnouncementsCreateNestedManyWithoutEmployeeInput
    Complaints?: ComplaintsCreateNestedManyWithoutEmployeeInput
    Bills?: BillsCreateNestedManyWithoutEmployeeInput
    Payments?: PaymentsCreateNestedManyWithoutProcessedByInput
    SecurityReports?: SecurityReportsCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeesUncheckedCreateWithoutUserInput = {
    id?: string
    employeeNumberId: string
    hireDate: Date | string
    employeePosition?: $Enums.EmployeeRole
    workingHours: number
    salary: number
    bonus?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Announcements?: AnnouncementsUncheckedCreateNestedManyWithoutEmployeeInput
    Complaints?: ComplaintsUncheckedCreateNestedManyWithoutEmployeeInput
    Bills?: BillsUncheckedCreateNestedManyWithoutEmployeeInput
    Payments?: PaymentsUncheckedCreateNestedManyWithoutProcessedByInput
    SecurityReports?: SecurityReportsUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeesCreateOrConnectWithoutUserInput = {
    where: EmployeesWhereUniqueInput
    create: XOR<EmployeesCreateWithoutUserInput, EmployeesUncheckedCreateWithoutUserInput>
  }

  export type ForumPostsCreateWithoutUserInput = {
    id?: string
    title: string
    content: string
    attachments?: ForumPostsCreateattachmentsInput | string[]
    authorRole: $Enums.UserRole
    publishedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    tags?: PostTagsCreateNestedManyWithoutPostsInput
    comments?: ForumCommentsCreateNestedManyWithoutPostInput
  }

  export type ForumPostsUncheckedCreateWithoutUserInput = {
    id?: string
    title: string
    content: string
    attachments?: ForumPostsCreateattachmentsInput | string[]
    authorRole: $Enums.UserRole
    publishedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    tags?: PostTagsUncheckedCreateNestedManyWithoutPostsInput
    comments?: ForumCommentsUncheckedCreateNestedManyWithoutPostInput
  }

  export type ForumPostsCreateOrConnectWithoutUserInput = {
    where: ForumPostsWhereUniqueInput
    create: XOR<ForumPostsCreateWithoutUserInput, ForumPostsUncheckedCreateWithoutUserInput>
  }

  export type ForumPostsCreateManyUserInputEnvelope = {
    data: ForumPostsCreateManyUserInput | ForumPostsCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ForumCommentsCreateWithoutUserInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    post: ForumPostsCreateNestedOneWithoutCommentsInput
  }

  export type ForumCommentsUncheckedCreateWithoutUserInput = {
    id?: string
    content: string
    postId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ForumCommentsCreateOrConnectWithoutUserInput = {
    where: ForumCommentsWhereUniqueInput
    create: XOR<ForumCommentsCreateWithoutUserInput, ForumCommentsUncheckedCreateWithoutUserInput>
  }

  export type ForumCommentsCreateManyUserInputEnvelope = {
    data: ForumCommentsCreateManyUserInput | ForumCommentsCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ResidentsUpsertWithoutUserInput = {
    update: XOR<ResidentsUpdateWithoutUserInput, ResidentsUncheckedUpdateWithoutUserInput>
    create: XOR<ResidentsCreateWithoutUserInput, ResidentsUncheckedCreateWithoutUserInput>
    where?: ResidentsWhereInput
  }

  export type ResidentsUpdateToOneWithWhereWithoutUserInput = {
    where?: ResidentsWhereInput
    data: XOR<ResidentsUpdateWithoutUserInput, ResidentsUncheckedUpdateWithoutUserInput>
  }

  export type ResidentsUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    movedInDate?: DateTimeFieldUpdateOperationsInput | Date | string
    movedOutDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    residentStatus?: NullableEnumResidentStatusFieldUpdateOperationsInput | $Enums.ResidentStatus | null
    kprPaymentAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    kprDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isKprPaid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    unit?: UnitsUpdateOneWithoutResidentsNestedInput
    Complaints?: ComplaintsUpdateManyWithoutResidentNestedInput
    Payments?: PaymentsUpdateManyWithoutResidentNestedInput
  }

  export type ResidentsUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    movedInDate?: DateTimeFieldUpdateOperationsInput | Date | string
    movedOutDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    residentStatus?: NullableEnumResidentStatusFieldUpdateOperationsInput | $Enums.ResidentStatus | null
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
    kprPaymentAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    kprDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isKprPaid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Complaints?: ComplaintsUncheckedUpdateManyWithoutResidentNestedInput
    Payments?: PaymentsUncheckedUpdateManyWithoutResidentNestedInput
  }

  export type EmployeesUpsertWithoutUserInput = {
    update: XOR<EmployeesUpdateWithoutUserInput, EmployeesUncheckedUpdateWithoutUserInput>
    create: XOR<EmployeesCreateWithoutUserInput, EmployeesUncheckedCreateWithoutUserInput>
    where?: EmployeesWhereInput
  }

  export type EmployeesUpdateToOneWithWhereWithoutUserInput = {
    where?: EmployeesWhereInput
    data: XOR<EmployeesUpdateWithoutUserInput, EmployeesUncheckedUpdateWithoutUserInput>
  }

  export type EmployeesUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeNumberId?: StringFieldUpdateOperationsInput | string
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    employeePosition?: EnumEmployeeRoleFieldUpdateOperationsInput | $Enums.EmployeeRole
    workingHours?: IntFieldUpdateOperationsInput | number
    salary?: FloatFieldUpdateOperationsInput | number
    bonus?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Announcements?: AnnouncementsUpdateManyWithoutEmployeeNestedInput
    Complaints?: ComplaintsUpdateManyWithoutEmployeeNestedInput
    Bills?: BillsUpdateManyWithoutEmployeeNestedInput
    Payments?: PaymentsUpdateManyWithoutProcessedByNestedInput
    SecurityReports?: SecurityReportsUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeesUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeNumberId?: StringFieldUpdateOperationsInput | string
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    employeePosition?: EnumEmployeeRoleFieldUpdateOperationsInput | $Enums.EmployeeRole
    workingHours?: IntFieldUpdateOperationsInput | number
    salary?: FloatFieldUpdateOperationsInput | number
    bonus?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Announcements?: AnnouncementsUncheckedUpdateManyWithoutEmployeeNestedInput
    Complaints?: ComplaintsUncheckedUpdateManyWithoutEmployeeNestedInput
    Bills?: BillsUncheckedUpdateManyWithoutEmployeeNestedInput
    Payments?: PaymentsUncheckedUpdateManyWithoutProcessedByNestedInput
    SecurityReports?: SecurityReportsUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type ForumPostsUpsertWithWhereUniqueWithoutUserInput = {
    where: ForumPostsWhereUniqueInput
    update: XOR<ForumPostsUpdateWithoutUserInput, ForumPostsUncheckedUpdateWithoutUserInput>
    create: XOR<ForumPostsCreateWithoutUserInput, ForumPostsUncheckedCreateWithoutUserInput>
  }

  export type ForumPostsUpdateWithWhereUniqueWithoutUserInput = {
    where: ForumPostsWhereUniqueInput
    data: XOR<ForumPostsUpdateWithoutUserInput, ForumPostsUncheckedUpdateWithoutUserInput>
  }

  export type ForumPostsUpdateManyWithWhereWithoutUserInput = {
    where: ForumPostsScalarWhereInput
    data: XOR<ForumPostsUpdateManyMutationInput, ForumPostsUncheckedUpdateManyWithoutUserInput>
  }

  export type ForumPostsScalarWhereInput = {
    AND?: ForumPostsScalarWhereInput | ForumPostsScalarWhereInput[]
    OR?: ForumPostsScalarWhereInput[]
    NOT?: ForumPostsScalarWhereInput | ForumPostsScalarWhereInput[]
    id?: UuidFilter<"ForumPosts"> | string
    title?: StringFilter<"ForumPosts"> | string
    content?: StringFilter<"ForumPosts"> | string
    attachments?: StringNullableListFilter<"ForumPosts">
    authorRole?: EnumUserRoleFilter<"ForumPosts"> | $Enums.UserRole
    userId?: UuidFilter<"ForumPosts"> | string
    publishedAt?: DateTimeFilter<"ForumPosts"> | Date | string
    createdAt?: DateTimeFilter<"ForumPosts"> | Date | string
    updatedAt?: DateTimeFilter<"ForumPosts"> | Date | string
  }

  export type ForumCommentsUpsertWithWhereUniqueWithoutUserInput = {
    where: ForumCommentsWhereUniqueInput
    update: XOR<ForumCommentsUpdateWithoutUserInput, ForumCommentsUncheckedUpdateWithoutUserInput>
    create: XOR<ForumCommentsCreateWithoutUserInput, ForumCommentsUncheckedCreateWithoutUserInput>
  }

  export type ForumCommentsUpdateWithWhereUniqueWithoutUserInput = {
    where: ForumCommentsWhereUniqueInput
    data: XOR<ForumCommentsUpdateWithoutUserInput, ForumCommentsUncheckedUpdateWithoutUserInput>
  }

  export type ForumCommentsUpdateManyWithWhereWithoutUserInput = {
    where: ForumCommentsScalarWhereInput
    data: XOR<ForumCommentsUpdateManyMutationInput, ForumCommentsUncheckedUpdateManyWithoutUserInput>
  }

  export type ForumCommentsScalarWhereInput = {
    AND?: ForumCommentsScalarWhereInput | ForumCommentsScalarWhereInput[]
    OR?: ForumCommentsScalarWhereInput[]
    NOT?: ForumCommentsScalarWhereInput | ForumCommentsScalarWhereInput[]
    id?: UuidFilter<"ForumComments"> | string
    content?: StringFilter<"ForumComments"> | string
    userId?: UuidFilter<"ForumComments"> | string
    postId?: UuidFilter<"ForumComments"> | string
    createdAt?: DateTimeFilter<"ForumComments"> | Date | string
    updatedAt?: DateTimeFilter<"ForumComments"> | Date | string
  }

  export type UsersCreateWithoutResidentInput = {
    id?: string
    fullName: string
    firstName: string
    lastName: string
    username: string
    dateOfBirth?: Date | string | null
    contactNumber?: string | null
    primaryEmail: string
    secondaryEmail?: string | null
    password: string
    sessionToken?: string | null
    emailVerificationToken?: string | null
    passwordResetToken?: string | null
    role: $Enums.UserRole
    gender?: $Enums.Gender | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Employee?: EmployeesCreateNestedOneWithoutUserInput
    ForumPosts?: ForumPostsCreateNestedManyWithoutUserInput
    ForumComments?: ForumCommentsCreateNestedManyWithoutUserInput
  }

  export type UsersUncheckedCreateWithoutResidentInput = {
    id?: string
    fullName: string
    firstName: string
    lastName: string
    username: string
    dateOfBirth?: Date | string | null
    contactNumber?: string | null
    primaryEmail: string
    secondaryEmail?: string | null
    password: string
    sessionToken?: string | null
    emailVerificationToken?: string | null
    passwordResetToken?: string | null
    role: $Enums.UserRole
    gender?: $Enums.Gender | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Employee?: EmployeesUncheckedCreateNestedOneWithoutUserInput
    ForumPosts?: ForumPostsUncheckedCreateNestedManyWithoutUserInput
    ForumComments?: ForumCommentsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UsersCreateOrConnectWithoutResidentInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutResidentInput, UsersUncheckedCreateWithoutResidentInput>
  }

  export type UnitsCreateWithoutResidentsInput = {
    id?: string
    unitNumber: string
    buildingName?: string | null
    floorNumber?: number | null
    numberOfRooms?: number | null
    priceSale: number
    squareFootage?: number | null
    location: string
    status: $Enums.UnitStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    Payments?: PaymentsCreateNestedManyWithoutUnitInput
    Bills?: BillsCreateNestedManyWithoutUnitInput
    Complaints?: ComplaintsCreateNestedManyWithoutUnitInput
  }

  export type UnitsUncheckedCreateWithoutResidentsInput = {
    id?: string
    unitNumber: string
    buildingName?: string | null
    floorNumber?: number | null
    numberOfRooms?: number | null
    priceSale: number
    squareFootage?: number | null
    location: string
    status: $Enums.UnitStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    Payments?: PaymentsUncheckedCreateNestedManyWithoutUnitInput
    Bills?: BillsUncheckedCreateNestedManyWithoutUnitInput
    Complaints?: ComplaintsUncheckedCreateNestedManyWithoutUnitInput
  }

  export type UnitsCreateOrConnectWithoutResidentsInput = {
    where: UnitsWhereUniqueInput
    create: XOR<UnitsCreateWithoutResidentsInput, UnitsUncheckedCreateWithoutResidentsInput>
  }

  export type ComplaintsCreateWithoutResidentInput = {
    id?: string
    title: string
    description: string
    category: $Enums.MaintenanceCategory
    status?: $Enums.ComplaintStatus
    images?: ComplaintsCreateimagesInput | string[]
    submittedAt?: Date | string
    resolvedAt?: Date | string | null
    resolutionDetails?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employee?: EmployeesCreateNestedOneWithoutComplaintsInput
    unit?: UnitsCreateNestedOneWithoutComplaintsInput
  }

  export type ComplaintsUncheckedCreateWithoutResidentInput = {
    id?: string
    title: string
    description: string
    category: $Enums.MaintenanceCategory
    status?: $Enums.ComplaintStatus
    images?: ComplaintsCreateimagesInput | string[]
    submittedAt?: Date | string
    resolvedAt?: Date | string | null
    resolutionDetails?: string | null
    employeeId?: string | null
    unitId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ComplaintsCreateOrConnectWithoutResidentInput = {
    where: ComplaintsWhereUniqueInput
    create: XOR<ComplaintsCreateWithoutResidentInput, ComplaintsUncheckedCreateWithoutResidentInput>
  }

  export type ComplaintsCreateManyResidentInputEnvelope = {
    data: ComplaintsCreateManyResidentInput | ComplaintsCreateManyResidentInput[]
    skipDuplicates?: boolean
  }

  export type PaymentsCreateWithoutResidentInput = {
    id?: string
    amount: number
    paymentDate?: Date | string
    paymentMethod: $Enums.PaymentMethod
    status: $Enums.PaymentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    unit?: UnitsCreateNestedOneWithoutPaymentsInput
    processedBy?: EmployeesCreateNestedOneWithoutPaymentsInput
    bill?: BillsCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentsUncheckedCreateWithoutResidentInput = {
    id?: string
    amount: number
    paymentDate?: Date | string
    paymentMethod: $Enums.PaymentMethod
    status: $Enums.PaymentStatus
    unitId?: string | null
    processedByEmployeeId?: string | null
    billId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentsCreateOrConnectWithoutResidentInput = {
    where: PaymentsWhereUniqueInput
    create: XOR<PaymentsCreateWithoutResidentInput, PaymentsUncheckedCreateWithoutResidentInput>
  }

  export type PaymentsCreateManyResidentInputEnvelope = {
    data: PaymentsCreateManyResidentInput | PaymentsCreateManyResidentInput[]
    skipDuplicates?: boolean
  }

  export type UsersUpsertWithoutResidentInput = {
    update: XOR<UsersUpdateWithoutResidentInput, UsersUncheckedUpdateWithoutResidentInput>
    create: XOR<UsersCreateWithoutResidentInput, UsersUncheckedCreateWithoutResidentInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutResidentInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutResidentInput, UsersUncheckedUpdateWithoutResidentInput>
  }

  export type UsersUpdateWithoutResidentInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    primaryEmail?: StringFieldUpdateOperationsInput | string
    secondaryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    sessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Employee?: EmployeesUpdateOneWithoutUserNestedInput
    ForumPosts?: ForumPostsUpdateManyWithoutUserNestedInput
    ForumComments?: ForumCommentsUpdateManyWithoutUserNestedInput
  }

  export type UsersUncheckedUpdateWithoutResidentInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    primaryEmail?: StringFieldUpdateOperationsInput | string
    secondaryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    sessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Employee?: EmployeesUncheckedUpdateOneWithoutUserNestedInput
    ForumPosts?: ForumPostsUncheckedUpdateManyWithoutUserNestedInput
    ForumComments?: ForumCommentsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UnitsUpsertWithoutResidentsInput = {
    update: XOR<UnitsUpdateWithoutResidentsInput, UnitsUncheckedUpdateWithoutResidentsInput>
    create: XOR<UnitsCreateWithoutResidentsInput, UnitsUncheckedCreateWithoutResidentsInput>
    where?: UnitsWhereInput
  }

  export type UnitsUpdateToOneWithWhereWithoutResidentsInput = {
    where?: UnitsWhereInput
    data: XOR<UnitsUpdateWithoutResidentsInput, UnitsUncheckedUpdateWithoutResidentsInput>
  }

  export type UnitsUpdateWithoutResidentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    unitNumber?: StringFieldUpdateOperationsInput | string
    buildingName?: NullableStringFieldUpdateOperationsInput | string | null
    floorNumber?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfRooms?: NullableIntFieldUpdateOperationsInput | number | null
    priceSale?: FloatFieldUpdateOperationsInput | number
    squareFootage?: NullableIntFieldUpdateOperationsInput | number | null
    location?: StringFieldUpdateOperationsInput | string
    status?: EnumUnitStatusFieldUpdateOperationsInput | $Enums.UnitStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Payments?: PaymentsUpdateManyWithoutUnitNestedInput
    Bills?: BillsUpdateManyWithoutUnitNestedInput
    Complaints?: ComplaintsUpdateManyWithoutUnitNestedInput
  }

  export type UnitsUncheckedUpdateWithoutResidentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    unitNumber?: StringFieldUpdateOperationsInput | string
    buildingName?: NullableStringFieldUpdateOperationsInput | string | null
    floorNumber?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfRooms?: NullableIntFieldUpdateOperationsInput | number | null
    priceSale?: FloatFieldUpdateOperationsInput | number
    squareFootage?: NullableIntFieldUpdateOperationsInput | number | null
    location?: StringFieldUpdateOperationsInput | string
    status?: EnumUnitStatusFieldUpdateOperationsInput | $Enums.UnitStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Payments?: PaymentsUncheckedUpdateManyWithoutUnitNestedInput
    Bills?: BillsUncheckedUpdateManyWithoutUnitNestedInput
    Complaints?: ComplaintsUncheckedUpdateManyWithoutUnitNestedInput
  }

  export type ComplaintsUpsertWithWhereUniqueWithoutResidentInput = {
    where: ComplaintsWhereUniqueInput
    update: XOR<ComplaintsUpdateWithoutResidentInput, ComplaintsUncheckedUpdateWithoutResidentInput>
    create: XOR<ComplaintsCreateWithoutResidentInput, ComplaintsUncheckedCreateWithoutResidentInput>
  }

  export type ComplaintsUpdateWithWhereUniqueWithoutResidentInput = {
    where: ComplaintsWhereUniqueInput
    data: XOR<ComplaintsUpdateWithoutResidentInput, ComplaintsUncheckedUpdateWithoutResidentInput>
  }

  export type ComplaintsUpdateManyWithWhereWithoutResidentInput = {
    where: ComplaintsScalarWhereInput
    data: XOR<ComplaintsUpdateManyMutationInput, ComplaintsUncheckedUpdateManyWithoutResidentInput>
  }

  export type ComplaintsScalarWhereInput = {
    AND?: ComplaintsScalarWhereInput | ComplaintsScalarWhereInput[]
    OR?: ComplaintsScalarWhereInput[]
    NOT?: ComplaintsScalarWhereInput | ComplaintsScalarWhereInput[]
    id?: UuidFilter<"Complaints"> | string
    title?: StringFilter<"Complaints"> | string
    description?: StringFilter<"Complaints"> | string
    category?: EnumMaintenanceCategoryFilter<"Complaints"> | $Enums.MaintenanceCategory
    status?: EnumComplaintStatusFilter<"Complaints"> | $Enums.ComplaintStatus
    images?: StringNullableListFilter<"Complaints">
    submittedAt?: DateTimeFilter<"Complaints"> | Date | string
    resolvedAt?: DateTimeNullableFilter<"Complaints"> | Date | string | null
    resolutionDetails?: StringNullableFilter<"Complaints"> | string | null
    residentId?: UuidFilter<"Complaints"> | string
    employeeId?: UuidNullableFilter<"Complaints"> | string | null
    unitId?: UuidNullableFilter<"Complaints"> | string | null
    createdAt?: DateTimeFilter<"Complaints"> | Date | string
    updatedAt?: DateTimeFilter<"Complaints"> | Date | string
  }

  export type PaymentsUpsertWithWhereUniqueWithoutResidentInput = {
    where: PaymentsWhereUniqueInput
    update: XOR<PaymentsUpdateWithoutResidentInput, PaymentsUncheckedUpdateWithoutResidentInput>
    create: XOR<PaymentsCreateWithoutResidentInput, PaymentsUncheckedCreateWithoutResidentInput>
  }

  export type PaymentsUpdateWithWhereUniqueWithoutResidentInput = {
    where: PaymentsWhereUniqueInput
    data: XOR<PaymentsUpdateWithoutResidentInput, PaymentsUncheckedUpdateWithoutResidentInput>
  }

  export type PaymentsUpdateManyWithWhereWithoutResidentInput = {
    where: PaymentsScalarWhereInput
    data: XOR<PaymentsUpdateManyMutationInput, PaymentsUncheckedUpdateManyWithoutResidentInput>
  }

  export type PaymentsScalarWhereInput = {
    AND?: PaymentsScalarWhereInput | PaymentsScalarWhereInput[]
    OR?: PaymentsScalarWhereInput[]
    NOT?: PaymentsScalarWhereInput | PaymentsScalarWhereInput[]
    id?: UuidFilter<"Payments"> | string
    amount?: FloatFilter<"Payments"> | number
    paymentDate?: DateTimeFilter<"Payments"> | Date | string
    paymentMethod?: EnumPaymentMethodFilter<"Payments"> | $Enums.PaymentMethod
    status?: EnumPaymentStatusFilter<"Payments"> | $Enums.PaymentStatus
    residentId?: UuidFilter<"Payments"> | string
    unitId?: UuidNullableFilter<"Payments"> | string | null
    processedByEmployeeId?: UuidNullableFilter<"Payments"> | string | null
    billId?: UuidNullableFilter<"Payments"> | string | null
    createdAt?: DateTimeFilter<"Payments"> | Date | string
    updatedAt?: DateTimeFilter<"Payments"> | Date | string
  }

  export type UsersCreateWithoutEmployeeInput = {
    id?: string
    fullName: string
    firstName: string
    lastName: string
    username: string
    dateOfBirth?: Date | string | null
    contactNumber?: string | null
    primaryEmail: string
    secondaryEmail?: string | null
    password: string
    sessionToken?: string | null
    emailVerificationToken?: string | null
    passwordResetToken?: string | null
    role: $Enums.UserRole
    gender?: $Enums.Gender | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Resident?: ResidentsCreateNestedOneWithoutUserInput
    ForumPosts?: ForumPostsCreateNestedManyWithoutUserInput
    ForumComments?: ForumCommentsCreateNestedManyWithoutUserInput
  }

  export type UsersUncheckedCreateWithoutEmployeeInput = {
    id?: string
    fullName: string
    firstName: string
    lastName: string
    username: string
    dateOfBirth?: Date | string | null
    contactNumber?: string | null
    primaryEmail: string
    secondaryEmail?: string | null
    password: string
    sessionToken?: string | null
    emailVerificationToken?: string | null
    passwordResetToken?: string | null
    role: $Enums.UserRole
    gender?: $Enums.Gender | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Resident?: ResidentsUncheckedCreateNestedOneWithoutUserInput
    ForumPosts?: ForumPostsUncheckedCreateNestedManyWithoutUserInput
    ForumComments?: ForumCommentsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UsersCreateOrConnectWithoutEmployeeInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutEmployeeInput, UsersUncheckedCreateWithoutEmployeeInput>
  }

  export type AnnouncementsCreateWithoutEmployeeInput = {
    id?: string
    title: string
    content: string
    attachments?: AnnouncementsCreateattachmentsInput | string[]
    publishDate?: Date | string
    expiryDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AnnouncementsUncheckedCreateWithoutEmployeeInput = {
    id?: string
    title: string
    content: string
    attachments?: AnnouncementsCreateattachmentsInput | string[]
    publishDate?: Date | string
    expiryDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AnnouncementsCreateOrConnectWithoutEmployeeInput = {
    where: AnnouncementsWhereUniqueInput
    create: XOR<AnnouncementsCreateWithoutEmployeeInput, AnnouncementsUncheckedCreateWithoutEmployeeInput>
  }

  export type AnnouncementsCreateManyEmployeeInputEnvelope = {
    data: AnnouncementsCreateManyEmployeeInput | AnnouncementsCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type ComplaintsCreateWithoutEmployeeInput = {
    id?: string
    title: string
    description: string
    category: $Enums.MaintenanceCategory
    status?: $Enums.ComplaintStatus
    images?: ComplaintsCreateimagesInput | string[]
    submittedAt?: Date | string
    resolvedAt?: Date | string | null
    resolutionDetails?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    resident: ResidentsCreateNestedOneWithoutComplaintsInput
    unit?: UnitsCreateNestedOneWithoutComplaintsInput
  }

  export type ComplaintsUncheckedCreateWithoutEmployeeInput = {
    id?: string
    title: string
    description: string
    category: $Enums.MaintenanceCategory
    status?: $Enums.ComplaintStatus
    images?: ComplaintsCreateimagesInput | string[]
    submittedAt?: Date | string
    resolvedAt?: Date | string | null
    resolutionDetails?: string | null
    residentId: string
    unitId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ComplaintsCreateOrConnectWithoutEmployeeInput = {
    where: ComplaintsWhereUniqueInput
    create: XOR<ComplaintsCreateWithoutEmployeeInput, ComplaintsUncheckedCreateWithoutEmployeeInput>
  }

  export type ComplaintsCreateManyEmployeeInputEnvelope = {
    data: ComplaintsCreateManyEmployeeInput | ComplaintsCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type BillsCreateWithoutEmployeeInput = {
    id?: string
    amount: number
    type: $Enums.PaymentType
    dueDate: Date | string
    isPaid?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    unit: UnitsCreateNestedOneWithoutBillsInput
    Payments?: PaymentsCreateNestedManyWithoutBillInput
  }

  export type BillsUncheckedCreateWithoutEmployeeInput = {
    id?: string
    amount: number
    type: $Enums.PaymentType
    dueDate: Date | string
    isPaid?: boolean
    unitId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Payments?: PaymentsUncheckedCreateNestedManyWithoutBillInput
  }

  export type BillsCreateOrConnectWithoutEmployeeInput = {
    where: BillsWhereUniqueInput
    create: XOR<BillsCreateWithoutEmployeeInput, BillsUncheckedCreateWithoutEmployeeInput>
  }

  export type BillsCreateManyEmployeeInputEnvelope = {
    data: BillsCreateManyEmployeeInput | BillsCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type PaymentsCreateWithoutProcessedByInput = {
    id?: string
    amount: number
    paymentDate?: Date | string
    paymentMethod: $Enums.PaymentMethod
    status: $Enums.PaymentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    resident: ResidentsCreateNestedOneWithoutPaymentsInput
    unit?: UnitsCreateNestedOneWithoutPaymentsInput
    bill?: BillsCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentsUncheckedCreateWithoutProcessedByInput = {
    id?: string
    amount: number
    paymentDate?: Date | string
    paymentMethod: $Enums.PaymentMethod
    status: $Enums.PaymentStatus
    residentId: string
    unitId?: string | null
    billId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentsCreateOrConnectWithoutProcessedByInput = {
    where: PaymentsWhereUniqueInput
    create: XOR<PaymentsCreateWithoutProcessedByInput, PaymentsUncheckedCreateWithoutProcessedByInput>
  }

  export type PaymentsCreateManyProcessedByInputEnvelope = {
    data: PaymentsCreateManyProcessedByInput | PaymentsCreateManyProcessedByInput[]
    skipDuplicates?: boolean
  }

  export type SecurityReportsCreateWithoutEmployeeInput = {
    id?: string
    title: string
    description: string
    location: string
    incidentDate: Date | string
    status: $Enums.MaintenanceStatus
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SecurityReportsUncheckedCreateWithoutEmployeeInput = {
    id?: string
    title: string
    description: string
    location: string
    incidentDate: Date | string
    status: $Enums.MaintenanceStatus
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SecurityReportsCreateOrConnectWithoutEmployeeInput = {
    where: SecurityReportsWhereUniqueInput
    create: XOR<SecurityReportsCreateWithoutEmployeeInput, SecurityReportsUncheckedCreateWithoutEmployeeInput>
  }

  export type SecurityReportsCreateManyEmployeeInputEnvelope = {
    data: SecurityReportsCreateManyEmployeeInput | SecurityReportsCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type UsersUpsertWithoutEmployeeInput = {
    update: XOR<UsersUpdateWithoutEmployeeInput, UsersUncheckedUpdateWithoutEmployeeInput>
    create: XOR<UsersCreateWithoutEmployeeInput, UsersUncheckedCreateWithoutEmployeeInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutEmployeeInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutEmployeeInput, UsersUncheckedUpdateWithoutEmployeeInput>
  }

  export type UsersUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    primaryEmail?: StringFieldUpdateOperationsInput | string
    secondaryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    sessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Resident?: ResidentsUpdateOneWithoutUserNestedInput
    ForumPosts?: ForumPostsUpdateManyWithoutUserNestedInput
    ForumComments?: ForumCommentsUpdateManyWithoutUserNestedInput
  }

  export type UsersUncheckedUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    primaryEmail?: StringFieldUpdateOperationsInput | string
    secondaryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    sessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Resident?: ResidentsUncheckedUpdateOneWithoutUserNestedInput
    ForumPosts?: ForumPostsUncheckedUpdateManyWithoutUserNestedInput
    ForumComments?: ForumCommentsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AnnouncementsUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: AnnouncementsWhereUniqueInput
    update: XOR<AnnouncementsUpdateWithoutEmployeeInput, AnnouncementsUncheckedUpdateWithoutEmployeeInput>
    create: XOR<AnnouncementsCreateWithoutEmployeeInput, AnnouncementsUncheckedCreateWithoutEmployeeInput>
  }

  export type AnnouncementsUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: AnnouncementsWhereUniqueInput
    data: XOR<AnnouncementsUpdateWithoutEmployeeInput, AnnouncementsUncheckedUpdateWithoutEmployeeInput>
  }

  export type AnnouncementsUpdateManyWithWhereWithoutEmployeeInput = {
    where: AnnouncementsScalarWhereInput
    data: XOR<AnnouncementsUpdateManyMutationInput, AnnouncementsUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type AnnouncementsScalarWhereInput = {
    AND?: AnnouncementsScalarWhereInput | AnnouncementsScalarWhereInput[]
    OR?: AnnouncementsScalarWhereInput[]
    NOT?: AnnouncementsScalarWhereInput | AnnouncementsScalarWhereInput[]
    id?: UuidFilter<"Announcements"> | string
    title?: StringFilter<"Announcements"> | string
    content?: StringFilter<"Announcements"> | string
    attachments?: StringNullableListFilter<"Announcements">
    publishDate?: DateTimeFilter<"Announcements"> | Date | string
    expiryDate?: DateTimeNullableFilter<"Announcements"> | Date | string | null
    employeeId?: UuidFilter<"Announcements"> | string
    createdAt?: DateTimeFilter<"Announcements"> | Date | string
    updatedAt?: DateTimeFilter<"Announcements"> | Date | string
  }

  export type ComplaintsUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: ComplaintsWhereUniqueInput
    update: XOR<ComplaintsUpdateWithoutEmployeeInput, ComplaintsUncheckedUpdateWithoutEmployeeInput>
    create: XOR<ComplaintsCreateWithoutEmployeeInput, ComplaintsUncheckedCreateWithoutEmployeeInput>
  }

  export type ComplaintsUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: ComplaintsWhereUniqueInput
    data: XOR<ComplaintsUpdateWithoutEmployeeInput, ComplaintsUncheckedUpdateWithoutEmployeeInput>
  }

  export type ComplaintsUpdateManyWithWhereWithoutEmployeeInput = {
    where: ComplaintsScalarWhereInput
    data: XOR<ComplaintsUpdateManyMutationInput, ComplaintsUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type BillsUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: BillsWhereUniqueInput
    update: XOR<BillsUpdateWithoutEmployeeInput, BillsUncheckedUpdateWithoutEmployeeInput>
    create: XOR<BillsCreateWithoutEmployeeInput, BillsUncheckedCreateWithoutEmployeeInput>
  }

  export type BillsUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: BillsWhereUniqueInput
    data: XOR<BillsUpdateWithoutEmployeeInput, BillsUncheckedUpdateWithoutEmployeeInput>
  }

  export type BillsUpdateManyWithWhereWithoutEmployeeInput = {
    where: BillsScalarWhereInput
    data: XOR<BillsUpdateManyMutationInput, BillsUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type BillsScalarWhereInput = {
    AND?: BillsScalarWhereInput | BillsScalarWhereInput[]
    OR?: BillsScalarWhereInput[]
    NOT?: BillsScalarWhereInput | BillsScalarWhereInput[]
    id?: UuidFilter<"Bills"> | string
    amount?: FloatFilter<"Bills"> | number
    type?: EnumPaymentTypeFilter<"Bills"> | $Enums.PaymentType
    dueDate?: DateTimeFilter<"Bills"> | Date | string
    isPaid?: BoolFilter<"Bills"> | boolean
    unitId?: UuidFilter<"Bills"> | string
    employeeId?: UuidFilter<"Bills"> | string
    createdAt?: DateTimeFilter<"Bills"> | Date | string
    updatedAt?: DateTimeFilter<"Bills"> | Date | string
  }

  export type PaymentsUpsertWithWhereUniqueWithoutProcessedByInput = {
    where: PaymentsWhereUniqueInput
    update: XOR<PaymentsUpdateWithoutProcessedByInput, PaymentsUncheckedUpdateWithoutProcessedByInput>
    create: XOR<PaymentsCreateWithoutProcessedByInput, PaymentsUncheckedCreateWithoutProcessedByInput>
  }

  export type PaymentsUpdateWithWhereUniqueWithoutProcessedByInput = {
    where: PaymentsWhereUniqueInput
    data: XOR<PaymentsUpdateWithoutProcessedByInput, PaymentsUncheckedUpdateWithoutProcessedByInput>
  }

  export type PaymentsUpdateManyWithWhereWithoutProcessedByInput = {
    where: PaymentsScalarWhereInput
    data: XOR<PaymentsUpdateManyMutationInput, PaymentsUncheckedUpdateManyWithoutProcessedByInput>
  }

  export type SecurityReportsUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: SecurityReportsWhereUniqueInput
    update: XOR<SecurityReportsUpdateWithoutEmployeeInput, SecurityReportsUncheckedUpdateWithoutEmployeeInput>
    create: XOR<SecurityReportsCreateWithoutEmployeeInput, SecurityReportsUncheckedCreateWithoutEmployeeInput>
  }

  export type SecurityReportsUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: SecurityReportsWhereUniqueInput
    data: XOR<SecurityReportsUpdateWithoutEmployeeInput, SecurityReportsUncheckedUpdateWithoutEmployeeInput>
  }

  export type SecurityReportsUpdateManyWithWhereWithoutEmployeeInput = {
    where: SecurityReportsScalarWhereInput
    data: XOR<SecurityReportsUpdateManyMutationInput, SecurityReportsUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type SecurityReportsScalarWhereInput = {
    AND?: SecurityReportsScalarWhereInput | SecurityReportsScalarWhereInput[]
    OR?: SecurityReportsScalarWhereInput[]
    NOT?: SecurityReportsScalarWhereInput | SecurityReportsScalarWhereInput[]
    id?: UuidFilter<"SecurityReports"> | string
    title?: StringFilter<"SecurityReports"> | string
    description?: StringFilter<"SecurityReports"> | string
    location?: StringFilter<"SecurityReports"> | string
    incidentDate?: DateTimeFilter<"SecurityReports"> | Date | string
    status?: EnumMaintenanceStatusFilter<"SecurityReports"> | $Enums.MaintenanceStatus
    isPublished?: BoolFilter<"SecurityReports"> | boolean
    employeeId?: UuidFilter<"SecurityReports"> | string
    createdAt?: DateTimeFilter<"SecurityReports"> | Date | string
    updatedAt?: DateTimeFilter<"SecurityReports"> | Date | string
  }

  export type ResidentsCreateWithoutComplaintsInput = {
    id?: string
    emergencyContactName?: string | null
    emergencyContactNumber?: string | null
    movedInDate: Date | string
    movedOutDate?: Date | string | null
    residentStatus?: $Enums.ResidentStatus | null
    kprPaymentAmount?: number | null
    kprDueDate?: Date | string | null
    isKprPaid?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UsersCreateNestedOneWithoutResidentInput
    unit?: UnitsCreateNestedOneWithoutResidentsInput
    Payments?: PaymentsCreateNestedManyWithoutResidentInput
  }

  export type ResidentsUncheckedCreateWithoutComplaintsInput = {
    id?: string
    userId: string
    emergencyContactName?: string | null
    emergencyContactNumber?: string | null
    movedInDate: Date | string
    movedOutDate?: Date | string | null
    residentStatus?: $Enums.ResidentStatus | null
    unitId?: string | null
    kprPaymentAmount?: number | null
    kprDueDate?: Date | string | null
    isKprPaid?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Payments?: PaymentsUncheckedCreateNestedManyWithoutResidentInput
  }

  export type ResidentsCreateOrConnectWithoutComplaintsInput = {
    where: ResidentsWhereUniqueInput
    create: XOR<ResidentsCreateWithoutComplaintsInput, ResidentsUncheckedCreateWithoutComplaintsInput>
  }

  export type EmployeesCreateWithoutComplaintsInput = {
    id?: string
    employeeNumberId: string
    hireDate: Date | string
    employeePosition?: $Enums.EmployeeRole
    workingHours: number
    salary: number
    bonus?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UsersCreateNestedOneWithoutEmployeeInput
    Announcements?: AnnouncementsCreateNestedManyWithoutEmployeeInput
    Bills?: BillsCreateNestedManyWithoutEmployeeInput
    Payments?: PaymentsCreateNestedManyWithoutProcessedByInput
    SecurityReports?: SecurityReportsCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeesUncheckedCreateWithoutComplaintsInput = {
    id?: string
    userId: string
    employeeNumberId: string
    hireDate: Date | string
    employeePosition?: $Enums.EmployeeRole
    workingHours: number
    salary: number
    bonus?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Announcements?: AnnouncementsUncheckedCreateNestedManyWithoutEmployeeInput
    Bills?: BillsUncheckedCreateNestedManyWithoutEmployeeInput
    Payments?: PaymentsUncheckedCreateNestedManyWithoutProcessedByInput
    SecurityReports?: SecurityReportsUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeesCreateOrConnectWithoutComplaintsInput = {
    where: EmployeesWhereUniqueInput
    create: XOR<EmployeesCreateWithoutComplaintsInput, EmployeesUncheckedCreateWithoutComplaintsInput>
  }

  export type UnitsCreateWithoutComplaintsInput = {
    id?: string
    unitNumber: string
    buildingName?: string | null
    floorNumber?: number | null
    numberOfRooms?: number | null
    priceSale: number
    squareFootage?: number | null
    location: string
    status: $Enums.UnitStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    Residents?: ResidentsCreateNestedManyWithoutUnitInput
    Payments?: PaymentsCreateNestedManyWithoutUnitInput
    Bills?: BillsCreateNestedManyWithoutUnitInput
  }

  export type UnitsUncheckedCreateWithoutComplaintsInput = {
    id?: string
    unitNumber: string
    buildingName?: string | null
    floorNumber?: number | null
    numberOfRooms?: number | null
    priceSale: number
    squareFootage?: number | null
    location: string
    status: $Enums.UnitStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    Residents?: ResidentsUncheckedCreateNestedManyWithoutUnitInput
    Payments?: PaymentsUncheckedCreateNestedManyWithoutUnitInput
    Bills?: BillsUncheckedCreateNestedManyWithoutUnitInput
  }

  export type UnitsCreateOrConnectWithoutComplaintsInput = {
    where: UnitsWhereUniqueInput
    create: XOR<UnitsCreateWithoutComplaintsInput, UnitsUncheckedCreateWithoutComplaintsInput>
  }

  export type ResidentsUpsertWithoutComplaintsInput = {
    update: XOR<ResidentsUpdateWithoutComplaintsInput, ResidentsUncheckedUpdateWithoutComplaintsInput>
    create: XOR<ResidentsCreateWithoutComplaintsInput, ResidentsUncheckedCreateWithoutComplaintsInput>
    where?: ResidentsWhereInput
  }

  export type ResidentsUpdateToOneWithWhereWithoutComplaintsInput = {
    where?: ResidentsWhereInput
    data: XOR<ResidentsUpdateWithoutComplaintsInput, ResidentsUncheckedUpdateWithoutComplaintsInput>
  }

  export type ResidentsUpdateWithoutComplaintsInput = {
    id?: StringFieldUpdateOperationsInput | string
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    movedInDate?: DateTimeFieldUpdateOperationsInput | Date | string
    movedOutDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    residentStatus?: NullableEnumResidentStatusFieldUpdateOperationsInput | $Enums.ResidentStatus | null
    kprPaymentAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    kprDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isKprPaid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UsersUpdateOneRequiredWithoutResidentNestedInput
    unit?: UnitsUpdateOneWithoutResidentsNestedInput
    Payments?: PaymentsUpdateManyWithoutResidentNestedInput
  }

  export type ResidentsUncheckedUpdateWithoutComplaintsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    movedInDate?: DateTimeFieldUpdateOperationsInput | Date | string
    movedOutDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    residentStatus?: NullableEnumResidentStatusFieldUpdateOperationsInput | $Enums.ResidentStatus | null
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
    kprPaymentAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    kprDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isKprPaid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Payments?: PaymentsUncheckedUpdateManyWithoutResidentNestedInput
  }

  export type EmployeesUpsertWithoutComplaintsInput = {
    update: XOR<EmployeesUpdateWithoutComplaintsInput, EmployeesUncheckedUpdateWithoutComplaintsInput>
    create: XOR<EmployeesCreateWithoutComplaintsInput, EmployeesUncheckedCreateWithoutComplaintsInput>
    where?: EmployeesWhereInput
  }

  export type EmployeesUpdateToOneWithWhereWithoutComplaintsInput = {
    where?: EmployeesWhereInput
    data: XOR<EmployeesUpdateWithoutComplaintsInput, EmployeesUncheckedUpdateWithoutComplaintsInput>
  }

  export type EmployeesUpdateWithoutComplaintsInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeNumberId?: StringFieldUpdateOperationsInput | string
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    employeePosition?: EnumEmployeeRoleFieldUpdateOperationsInput | $Enums.EmployeeRole
    workingHours?: IntFieldUpdateOperationsInput | number
    salary?: FloatFieldUpdateOperationsInput | number
    bonus?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UsersUpdateOneRequiredWithoutEmployeeNestedInput
    Announcements?: AnnouncementsUpdateManyWithoutEmployeeNestedInput
    Bills?: BillsUpdateManyWithoutEmployeeNestedInput
    Payments?: PaymentsUpdateManyWithoutProcessedByNestedInput
    SecurityReports?: SecurityReportsUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeesUncheckedUpdateWithoutComplaintsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    employeeNumberId?: StringFieldUpdateOperationsInput | string
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    employeePosition?: EnumEmployeeRoleFieldUpdateOperationsInput | $Enums.EmployeeRole
    workingHours?: IntFieldUpdateOperationsInput | number
    salary?: FloatFieldUpdateOperationsInput | number
    bonus?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Announcements?: AnnouncementsUncheckedUpdateManyWithoutEmployeeNestedInput
    Bills?: BillsUncheckedUpdateManyWithoutEmployeeNestedInput
    Payments?: PaymentsUncheckedUpdateManyWithoutProcessedByNestedInput
    SecurityReports?: SecurityReportsUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type UnitsUpsertWithoutComplaintsInput = {
    update: XOR<UnitsUpdateWithoutComplaintsInput, UnitsUncheckedUpdateWithoutComplaintsInput>
    create: XOR<UnitsCreateWithoutComplaintsInput, UnitsUncheckedCreateWithoutComplaintsInput>
    where?: UnitsWhereInput
  }

  export type UnitsUpdateToOneWithWhereWithoutComplaintsInput = {
    where?: UnitsWhereInput
    data: XOR<UnitsUpdateWithoutComplaintsInput, UnitsUncheckedUpdateWithoutComplaintsInput>
  }

  export type UnitsUpdateWithoutComplaintsInput = {
    id?: StringFieldUpdateOperationsInput | string
    unitNumber?: StringFieldUpdateOperationsInput | string
    buildingName?: NullableStringFieldUpdateOperationsInput | string | null
    floorNumber?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfRooms?: NullableIntFieldUpdateOperationsInput | number | null
    priceSale?: FloatFieldUpdateOperationsInput | number
    squareFootage?: NullableIntFieldUpdateOperationsInput | number | null
    location?: StringFieldUpdateOperationsInput | string
    status?: EnumUnitStatusFieldUpdateOperationsInput | $Enums.UnitStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Residents?: ResidentsUpdateManyWithoutUnitNestedInput
    Payments?: PaymentsUpdateManyWithoutUnitNestedInput
    Bills?: BillsUpdateManyWithoutUnitNestedInput
  }

  export type UnitsUncheckedUpdateWithoutComplaintsInput = {
    id?: StringFieldUpdateOperationsInput | string
    unitNumber?: StringFieldUpdateOperationsInput | string
    buildingName?: NullableStringFieldUpdateOperationsInput | string | null
    floorNumber?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfRooms?: NullableIntFieldUpdateOperationsInput | number | null
    priceSale?: FloatFieldUpdateOperationsInput | number
    squareFootage?: NullableIntFieldUpdateOperationsInput | number | null
    location?: StringFieldUpdateOperationsInput | string
    status?: EnumUnitStatusFieldUpdateOperationsInput | $Enums.UnitStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Residents?: ResidentsUncheckedUpdateManyWithoutUnitNestedInput
    Payments?: PaymentsUncheckedUpdateManyWithoutUnitNestedInput
    Bills?: BillsUncheckedUpdateManyWithoutUnitNestedInput
  }

  export type EmployeesCreateWithoutAnnouncementsInput = {
    id?: string
    employeeNumberId: string
    hireDate: Date | string
    employeePosition?: $Enums.EmployeeRole
    workingHours: number
    salary: number
    bonus?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UsersCreateNestedOneWithoutEmployeeInput
    Complaints?: ComplaintsCreateNestedManyWithoutEmployeeInput
    Bills?: BillsCreateNestedManyWithoutEmployeeInput
    Payments?: PaymentsCreateNestedManyWithoutProcessedByInput
    SecurityReports?: SecurityReportsCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeesUncheckedCreateWithoutAnnouncementsInput = {
    id?: string
    userId: string
    employeeNumberId: string
    hireDate: Date | string
    employeePosition?: $Enums.EmployeeRole
    workingHours: number
    salary: number
    bonus?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Complaints?: ComplaintsUncheckedCreateNestedManyWithoutEmployeeInput
    Bills?: BillsUncheckedCreateNestedManyWithoutEmployeeInput
    Payments?: PaymentsUncheckedCreateNestedManyWithoutProcessedByInput
    SecurityReports?: SecurityReportsUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeesCreateOrConnectWithoutAnnouncementsInput = {
    where: EmployeesWhereUniqueInput
    create: XOR<EmployeesCreateWithoutAnnouncementsInput, EmployeesUncheckedCreateWithoutAnnouncementsInput>
  }

  export type EmployeesUpsertWithoutAnnouncementsInput = {
    update: XOR<EmployeesUpdateWithoutAnnouncementsInput, EmployeesUncheckedUpdateWithoutAnnouncementsInput>
    create: XOR<EmployeesCreateWithoutAnnouncementsInput, EmployeesUncheckedCreateWithoutAnnouncementsInput>
    where?: EmployeesWhereInput
  }

  export type EmployeesUpdateToOneWithWhereWithoutAnnouncementsInput = {
    where?: EmployeesWhereInput
    data: XOR<EmployeesUpdateWithoutAnnouncementsInput, EmployeesUncheckedUpdateWithoutAnnouncementsInput>
  }

  export type EmployeesUpdateWithoutAnnouncementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeNumberId?: StringFieldUpdateOperationsInput | string
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    employeePosition?: EnumEmployeeRoleFieldUpdateOperationsInput | $Enums.EmployeeRole
    workingHours?: IntFieldUpdateOperationsInput | number
    salary?: FloatFieldUpdateOperationsInput | number
    bonus?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UsersUpdateOneRequiredWithoutEmployeeNestedInput
    Complaints?: ComplaintsUpdateManyWithoutEmployeeNestedInput
    Bills?: BillsUpdateManyWithoutEmployeeNestedInput
    Payments?: PaymentsUpdateManyWithoutProcessedByNestedInput
    SecurityReports?: SecurityReportsUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeesUncheckedUpdateWithoutAnnouncementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    employeeNumberId?: StringFieldUpdateOperationsInput | string
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    employeePosition?: EnumEmployeeRoleFieldUpdateOperationsInput | $Enums.EmployeeRole
    workingHours?: IntFieldUpdateOperationsInput | number
    salary?: FloatFieldUpdateOperationsInput | number
    bonus?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Complaints?: ComplaintsUncheckedUpdateManyWithoutEmployeeNestedInput
    Bills?: BillsUncheckedUpdateManyWithoutEmployeeNestedInput
    Payments?: PaymentsUncheckedUpdateManyWithoutProcessedByNestedInput
    SecurityReports?: SecurityReportsUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type UsersCreateWithoutForumPostsInput = {
    id?: string
    fullName: string
    firstName: string
    lastName: string
    username: string
    dateOfBirth?: Date | string | null
    contactNumber?: string | null
    primaryEmail: string
    secondaryEmail?: string | null
    password: string
    sessionToken?: string | null
    emailVerificationToken?: string | null
    passwordResetToken?: string | null
    role: $Enums.UserRole
    gender?: $Enums.Gender | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Resident?: ResidentsCreateNestedOneWithoutUserInput
    Employee?: EmployeesCreateNestedOneWithoutUserInput
    ForumComments?: ForumCommentsCreateNestedManyWithoutUserInput
  }

  export type UsersUncheckedCreateWithoutForumPostsInput = {
    id?: string
    fullName: string
    firstName: string
    lastName: string
    username: string
    dateOfBirth?: Date | string | null
    contactNumber?: string | null
    primaryEmail: string
    secondaryEmail?: string | null
    password: string
    sessionToken?: string | null
    emailVerificationToken?: string | null
    passwordResetToken?: string | null
    role: $Enums.UserRole
    gender?: $Enums.Gender | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Resident?: ResidentsUncheckedCreateNestedOneWithoutUserInput
    Employee?: EmployeesUncheckedCreateNestedOneWithoutUserInput
    ForumComments?: ForumCommentsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UsersCreateOrConnectWithoutForumPostsInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutForumPostsInput, UsersUncheckedCreateWithoutForumPostsInput>
  }

  export type PostTagsCreateWithoutPostsInput = {
    id?: string
    tagName: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PostTagsUncheckedCreateWithoutPostsInput = {
    id?: string
    tagName: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PostTagsCreateOrConnectWithoutPostsInput = {
    where: PostTagsWhereUniqueInput
    create: XOR<PostTagsCreateWithoutPostsInput, PostTagsUncheckedCreateWithoutPostsInput>
  }

  export type ForumCommentsCreateWithoutPostInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UsersCreateNestedOneWithoutForumCommentsInput
  }

  export type ForumCommentsUncheckedCreateWithoutPostInput = {
    id?: string
    content: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ForumCommentsCreateOrConnectWithoutPostInput = {
    where: ForumCommentsWhereUniqueInput
    create: XOR<ForumCommentsCreateWithoutPostInput, ForumCommentsUncheckedCreateWithoutPostInput>
  }

  export type ForumCommentsCreateManyPostInputEnvelope = {
    data: ForumCommentsCreateManyPostInput | ForumCommentsCreateManyPostInput[]
    skipDuplicates?: boolean
  }

  export type UsersUpsertWithoutForumPostsInput = {
    update: XOR<UsersUpdateWithoutForumPostsInput, UsersUncheckedUpdateWithoutForumPostsInput>
    create: XOR<UsersCreateWithoutForumPostsInput, UsersUncheckedCreateWithoutForumPostsInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutForumPostsInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutForumPostsInput, UsersUncheckedUpdateWithoutForumPostsInput>
  }

  export type UsersUpdateWithoutForumPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    primaryEmail?: StringFieldUpdateOperationsInput | string
    secondaryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    sessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Resident?: ResidentsUpdateOneWithoutUserNestedInput
    Employee?: EmployeesUpdateOneWithoutUserNestedInput
    ForumComments?: ForumCommentsUpdateManyWithoutUserNestedInput
  }

  export type UsersUncheckedUpdateWithoutForumPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    primaryEmail?: StringFieldUpdateOperationsInput | string
    secondaryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    sessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Resident?: ResidentsUncheckedUpdateOneWithoutUserNestedInput
    Employee?: EmployeesUncheckedUpdateOneWithoutUserNestedInput
    ForumComments?: ForumCommentsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PostTagsUpsertWithWhereUniqueWithoutPostsInput = {
    where: PostTagsWhereUniqueInput
    update: XOR<PostTagsUpdateWithoutPostsInput, PostTagsUncheckedUpdateWithoutPostsInput>
    create: XOR<PostTagsCreateWithoutPostsInput, PostTagsUncheckedCreateWithoutPostsInput>
  }

  export type PostTagsUpdateWithWhereUniqueWithoutPostsInput = {
    where: PostTagsWhereUniqueInput
    data: XOR<PostTagsUpdateWithoutPostsInput, PostTagsUncheckedUpdateWithoutPostsInput>
  }

  export type PostTagsUpdateManyWithWhereWithoutPostsInput = {
    where: PostTagsScalarWhereInput
    data: XOR<PostTagsUpdateManyMutationInput, PostTagsUncheckedUpdateManyWithoutPostsInput>
  }

  export type PostTagsScalarWhereInput = {
    AND?: PostTagsScalarWhereInput | PostTagsScalarWhereInput[]
    OR?: PostTagsScalarWhereInput[]
    NOT?: PostTagsScalarWhereInput | PostTagsScalarWhereInput[]
    id?: UuidFilter<"PostTags"> | string
    tagName?: StringFilter<"PostTags"> | string
    createdAt?: DateTimeFilter<"PostTags"> | Date | string
    updatedAt?: DateTimeFilter<"PostTags"> | Date | string
  }

  export type ForumCommentsUpsertWithWhereUniqueWithoutPostInput = {
    where: ForumCommentsWhereUniqueInput
    update: XOR<ForumCommentsUpdateWithoutPostInput, ForumCommentsUncheckedUpdateWithoutPostInput>
    create: XOR<ForumCommentsCreateWithoutPostInput, ForumCommentsUncheckedCreateWithoutPostInput>
  }

  export type ForumCommentsUpdateWithWhereUniqueWithoutPostInput = {
    where: ForumCommentsWhereUniqueInput
    data: XOR<ForumCommentsUpdateWithoutPostInput, ForumCommentsUncheckedUpdateWithoutPostInput>
  }

  export type ForumCommentsUpdateManyWithWhereWithoutPostInput = {
    where: ForumCommentsScalarWhereInput
    data: XOR<ForumCommentsUpdateManyMutationInput, ForumCommentsUncheckedUpdateManyWithoutPostInput>
  }

  export type ForumPostsCreateWithoutTagsInput = {
    id?: string
    title: string
    content: string
    attachments?: ForumPostsCreateattachmentsInput | string[]
    authorRole: $Enums.UserRole
    publishedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UsersCreateNestedOneWithoutForumPostsInput
    comments?: ForumCommentsCreateNestedManyWithoutPostInput
  }

  export type ForumPostsUncheckedCreateWithoutTagsInput = {
    id?: string
    title: string
    content: string
    attachments?: ForumPostsCreateattachmentsInput | string[]
    authorRole: $Enums.UserRole
    userId: string
    publishedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: ForumCommentsUncheckedCreateNestedManyWithoutPostInput
  }

  export type ForumPostsCreateOrConnectWithoutTagsInput = {
    where: ForumPostsWhereUniqueInput
    create: XOR<ForumPostsCreateWithoutTagsInput, ForumPostsUncheckedCreateWithoutTagsInput>
  }

  export type ForumPostsUpsertWithWhereUniqueWithoutTagsInput = {
    where: ForumPostsWhereUniqueInput
    update: XOR<ForumPostsUpdateWithoutTagsInput, ForumPostsUncheckedUpdateWithoutTagsInput>
    create: XOR<ForumPostsCreateWithoutTagsInput, ForumPostsUncheckedCreateWithoutTagsInput>
  }

  export type ForumPostsUpdateWithWhereUniqueWithoutTagsInput = {
    where: ForumPostsWhereUniqueInput
    data: XOR<ForumPostsUpdateWithoutTagsInput, ForumPostsUncheckedUpdateWithoutTagsInput>
  }

  export type ForumPostsUpdateManyWithWhereWithoutTagsInput = {
    where: ForumPostsScalarWhereInput
    data: XOR<ForumPostsUpdateManyMutationInput, ForumPostsUncheckedUpdateManyWithoutTagsInput>
  }

  export type UsersCreateWithoutForumCommentsInput = {
    id?: string
    fullName: string
    firstName: string
    lastName: string
    username: string
    dateOfBirth?: Date | string | null
    contactNumber?: string | null
    primaryEmail: string
    secondaryEmail?: string | null
    password: string
    sessionToken?: string | null
    emailVerificationToken?: string | null
    passwordResetToken?: string | null
    role: $Enums.UserRole
    gender?: $Enums.Gender | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Resident?: ResidentsCreateNestedOneWithoutUserInput
    Employee?: EmployeesCreateNestedOneWithoutUserInput
    ForumPosts?: ForumPostsCreateNestedManyWithoutUserInput
  }

  export type UsersUncheckedCreateWithoutForumCommentsInput = {
    id?: string
    fullName: string
    firstName: string
    lastName: string
    username: string
    dateOfBirth?: Date | string | null
    contactNumber?: string | null
    primaryEmail: string
    secondaryEmail?: string | null
    password: string
    sessionToken?: string | null
    emailVerificationToken?: string | null
    passwordResetToken?: string | null
    role: $Enums.UserRole
    gender?: $Enums.Gender | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Resident?: ResidentsUncheckedCreateNestedOneWithoutUserInput
    Employee?: EmployeesUncheckedCreateNestedOneWithoutUserInput
    ForumPosts?: ForumPostsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UsersCreateOrConnectWithoutForumCommentsInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutForumCommentsInput, UsersUncheckedCreateWithoutForumCommentsInput>
  }

  export type ForumPostsCreateWithoutCommentsInput = {
    id?: string
    title: string
    content: string
    attachments?: ForumPostsCreateattachmentsInput | string[]
    authorRole: $Enums.UserRole
    publishedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UsersCreateNestedOneWithoutForumPostsInput
    tags?: PostTagsCreateNestedManyWithoutPostsInput
  }

  export type ForumPostsUncheckedCreateWithoutCommentsInput = {
    id?: string
    title: string
    content: string
    attachments?: ForumPostsCreateattachmentsInput | string[]
    authorRole: $Enums.UserRole
    userId: string
    publishedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    tags?: PostTagsUncheckedCreateNestedManyWithoutPostsInput
  }

  export type ForumPostsCreateOrConnectWithoutCommentsInput = {
    where: ForumPostsWhereUniqueInput
    create: XOR<ForumPostsCreateWithoutCommentsInput, ForumPostsUncheckedCreateWithoutCommentsInput>
  }

  export type UsersUpsertWithoutForumCommentsInput = {
    update: XOR<UsersUpdateWithoutForumCommentsInput, UsersUncheckedUpdateWithoutForumCommentsInput>
    create: XOR<UsersCreateWithoutForumCommentsInput, UsersUncheckedCreateWithoutForumCommentsInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutForumCommentsInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutForumCommentsInput, UsersUncheckedUpdateWithoutForumCommentsInput>
  }

  export type UsersUpdateWithoutForumCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    primaryEmail?: StringFieldUpdateOperationsInput | string
    secondaryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    sessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Resident?: ResidentsUpdateOneWithoutUserNestedInput
    Employee?: EmployeesUpdateOneWithoutUserNestedInput
    ForumPosts?: ForumPostsUpdateManyWithoutUserNestedInput
  }

  export type UsersUncheckedUpdateWithoutForumCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    primaryEmail?: StringFieldUpdateOperationsInput | string
    secondaryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    sessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Resident?: ResidentsUncheckedUpdateOneWithoutUserNestedInput
    Employee?: EmployeesUncheckedUpdateOneWithoutUserNestedInput
    ForumPosts?: ForumPostsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ForumPostsUpsertWithoutCommentsInput = {
    update: XOR<ForumPostsUpdateWithoutCommentsInput, ForumPostsUncheckedUpdateWithoutCommentsInput>
    create: XOR<ForumPostsCreateWithoutCommentsInput, ForumPostsUncheckedCreateWithoutCommentsInput>
    where?: ForumPostsWhereInput
  }

  export type ForumPostsUpdateToOneWithWhereWithoutCommentsInput = {
    where?: ForumPostsWhereInput
    data: XOR<ForumPostsUpdateWithoutCommentsInput, ForumPostsUncheckedUpdateWithoutCommentsInput>
  }

  export type ForumPostsUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    attachments?: ForumPostsUpdateattachmentsInput | string[]
    authorRole?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UsersUpdateOneRequiredWithoutForumPostsNestedInput
    tags?: PostTagsUpdateManyWithoutPostsNestedInput
  }

  export type ForumPostsUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    attachments?: ForumPostsUpdateattachmentsInput | string[]
    authorRole?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    userId?: StringFieldUpdateOperationsInput | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tags?: PostTagsUncheckedUpdateManyWithoutPostsNestedInput
  }

  export type ResidentsCreateWithoutUnitInput = {
    id?: string
    emergencyContactName?: string | null
    emergencyContactNumber?: string | null
    movedInDate: Date | string
    movedOutDate?: Date | string | null
    residentStatus?: $Enums.ResidentStatus | null
    kprPaymentAmount?: number | null
    kprDueDate?: Date | string | null
    isKprPaid?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UsersCreateNestedOneWithoutResidentInput
    Complaints?: ComplaintsCreateNestedManyWithoutResidentInput
    Payments?: PaymentsCreateNestedManyWithoutResidentInput
  }

  export type ResidentsUncheckedCreateWithoutUnitInput = {
    id?: string
    userId: string
    emergencyContactName?: string | null
    emergencyContactNumber?: string | null
    movedInDate: Date | string
    movedOutDate?: Date | string | null
    residentStatus?: $Enums.ResidentStatus | null
    kprPaymentAmount?: number | null
    kprDueDate?: Date | string | null
    isKprPaid?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Complaints?: ComplaintsUncheckedCreateNestedManyWithoutResidentInput
    Payments?: PaymentsUncheckedCreateNestedManyWithoutResidentInput
  }

  export type ResidentsCreateOrConnectWithoutUnitInput = {
    where: ResidentsWhereUniqueInput
    create: XOR<ResidentsCreateWithoutUnitInput, ResidentsUncheckedCreateWithoutUnitInput>
  }

  export type ResidentsCreateManyUnitInputEnvelope = {
    data: ResidentsCreateManyUnitInput | ResidentsCreateManyUnitInput[]
    skipDuplicates?: boolean
  }

  export type PaymentsCreateWithoutUnitInput = {
    id?: string
    amount: number
    paymentDate?: Date | string
    paymentMethod: $Enums.PaymentMethod
    status: $Enums.PaymentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    resident: ResidentsCreateNestedOneWithoutPaymentsInput
    processedBy?: EmployeesCreateNestedOneWithoutPaymentsInput
    bill?: BillsCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentsUncheckedCreateWithoutUnitInput = {
    id?: string
    amount: number
    paymentDate?: Date | string
    paymentMethod: $Enums.PaymentMethod
    status: $Enums.PaymentStatus
    residentId: string
    processedByEmployeeId?: string | null
    billId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentsCreateOrConnectWithoutUnitInput = {
    where: PaymentsWhereUniqueInput
    create: XOR<PaymentsCreateWithoutUnitInput, PaymentsUncheckedCreateWithoutUnitInput>
  }

  export type PaymentsCreateManyUnitInputEnvelope = {
    data: PaymentsCreateManyUnitInput | PaymentsCreateManyUnitInput[]
    skipDuplicates?: boolean
  }

  export type BillsCreateWithoutUnitInput = {
    id?: string
    amount: number
    type: $Enums.PaymentType
    dueDate: Date | string
    isPaid?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    employee: EmployeesCreateNestedOneWithoutBillsInput
    Payments?: PaymentsCreateNestedManyWithoutBillInput
  }

  export type BillsUncheckedCreateWithoutUnitInput = {
    id?: string
    amount: number
    type: $Enums.PaymentType
    dueDate: Date | string
    isPaid?: boolean
    employeeId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Payments?: PaymentsUncheckedCreateNestedManyWithoutBillInput
  }

  export type BillsCreateOrConnectWithoutUnitInput = {
    where: BillsWhereUniqueInput
    create: XOR<BillsCreateWithoutUnitInput, BillsUncheckedCreateWithoutUnitInput>
  }

  export type BillsCreateManyUnitInputEnvelope = {
    data: BillsCreateManyUnitInput | BillsCreateManyUnitInput[]
    skipDuplicates?: boolean
  }

  export type ComplaintsCreateWithoutUnitInput = {
    id?: string
    title: string
    description: string
    category: $Enums.MaintenanceCategory
    status?: $Enums.ComplaintStatus
    images?: ComplaintsCreateimagesInput | string[]
    submittedAt?: Date | string
    resolvedAt?: Date | string | null
    resolutionDetails?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    resident: ResidentsCreateNestedOneWithoutComplaintsInput
    employee?: EmployeesCreateNestedOneWithoutComplaintsInput
  }

  export type ComplaintsUncheckedCreateWithoutUnitInput = {
    id?: string
    title: string
    description: string
    category: $Enums.MaintenanceCategory
    status?: $Enums.ComplaintStatus
    images?: ComplaintsCreateimagesInput | string[]
    submittedAt?: Date | string
    resolvedAt?: Date | string | null
    resolutionDetails?: string | null
    residentId: string
    employeeId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ComplaintsCreateOrConnectWithoutUnitInput = {
    where: ComplaintsWhereUniqueInput
    create: XOR<ComplaintsCreateWithoutUnitInput, ComplaintsUncheckedCreateWithoutUnitInput>
  }

  export type ComplaintsCreateManyUnitInputEnvelope = {
    data: ComplaintsCreateManyUnitInput | ComplaintsCreateManyUnitInput[]
    skipDuplicates?: boolean
  }

  export type ResidentsUpsertWithWhereUniqueWithoutUnitInput = {
    where: ResidentsWhereUniqueInput
    update: XOR<ResidentsUpdateWithoutUnitInput, ResidentsUncheckedUpdateWithoutUnitInput>
    create: XOR<ResidentsCreateWithoutUnitInput, ResidentsUncheckedCreateWithoutUnitInput>
  }

  export type ResidentsUpdateWithWhereUniqueWithoutUnitInput = {
    where: ResidentsWhereUniqueInput
    data: XOR<ResidentsUpdateWithoutUnitInput, ResidentsUncheckedUpdateWithoutUnitInput>
  }

  export type ResidentsUpdateManyWithWhereWithoutUnitInput = {
    where: ResidentsScalarWhereInput
    data: XOR<ResidentsUpdateManyMutationInput, ResidentsUncheckedUpdateManyWithoutUnitInput>
  }

  export type ResidentsScalarWhereInput = {
    AND?: ResidentsScalarWhereInput | ResidentsScalarWhereInput[]
    OR?: ResidentsScalarWhereInput[]
    NOT?: ResidentsScalarWhereInput | ResidentsScalarWhereInput[]
    id?: UuidFilter<"Residents"> | string
    userId?: UuidFilter<"Residents"> | string
    emergencyContactName?: StringNullableFilter<"Residents"> | string | null
    emergencyContactNumber?: StringNullableFilter<"Residents"> | string | null
    movedInDate?: DateTimeFilter<"Residents"> | Date | string
    movedOutDate?: DateTimeNullableFilter<"Residents"> | Date | string | null
    residentStatus?: EnumResidentStatusNullableFilter<"Residents"> | $Enums.ResidentStatus | null
    unitId?: UuidNullableFilter<"Residents"> | string | null
    kprPaymentAmount?: FloatNullableFilter<"Residents"> | number | null
    kprDueDate?: DateTimeNullableFilter<"Residents"> | Date | string | null
    isKprPaid?: BoolNullableFilter<"Residents"> | boolean | null
    createdAt?: DateTimeFilter<"Residents"> | Date | string
    updatedAt?: DateTimeFilter<"Residents"> | Date | string
  }

  export type PaymentsUpsertWithWhereUniqueWithoutUnitInput = {
    where: PaymentsWhereUniqueInput
    update: XOR<PaymentsUpdateWithoutUnitInput, PaymentsUncheckedUpdateWithoutUnitInput>
    create: XOR<PaymentsCreateWithoutUnitInput, PaymentsUncheckedCreateWithoutUnitInput>
  }

  export type PaymentsUpdateWithWhereUniqueWithoutUnitInput = {
    where: PaymentsWhereUniqueInput
    data: XOR<PaymentsUpdateWithoutUnitInput, PaymentsUncheckedUpdateWithoutUnitInput>
  }

  export type PaymentsUpdateManyWithWhereWithoutUnitInput = {
    where: PaymentsScalarWhereInput
    data: XOR<PaymentsUpdateManyMutationInput, PaymentsUncheckedUpdateManyWithoutUnitInput>
  }

  export type BillsUpsertWithWhereUniqueWithoutUnitInput = {
    where: BillsWhereUniqueInput
    update: XOR<BillsUpdateWithoutUnitInput, BillsUncheckedUpdateWithoutUnitInput>
    create: XOR<BillsCreateWithoutUnitInput, BillsUncheckedCreateWithoutUnitInput>
  }

  export type BillsUpdateWithWhereUniqueWithoutUnitInput = {
    where: BillsWhereUniqueInput
    data: XOR<BillsUpdateWithoutUnitInput, BillsUncheckedUpdateWithoutUnitInput>
  }

  export type BillsUpdateManyWithWhereWithoutUnitInput = {
    where: BillsScalarWhereInput
    data: XOR<BillsUpdateManyMutationInput, BillsUncheckedUpdateManyWithoutUnitInput>
  }

  export type ComplaintsUpsertWithWhereUniqueWithoutUnitInput = {
    where: ComplaintsWhereUniqueInput
    update: XOR<ComplaintsUpdateWithoutUnitInput, ComplaintsUncheckedUpdateWithoutUnitInput>
    create: XOR<ComplaintsCreateWithoutUnitInput, ComplaintsUncheckedCreateWithoutUnitInput>
  }

  export type ComplaintsUpdateWithWhereUniqueWithoutUnitInput = {
    where: ComplaintsWhereUniqueInput
    data: XOR<ComplaintsUpdateWithoutUnitInput, ComplaintsUncheckedUpdateWithoutUnitInput>
  }

  export type ComplaintsUpdateManyWithWhereWithoutUnitInput = {
    where: ComplaintsScalarWhereInput
    data: XOR<ComplaintsUpdateManyMutationInput, ComplaintsUncheckedUpdateManyWithoutUnitInput>
  }

  export type UnitsCreateWithoutBillsInput = {
    id?: string
    unitNumber: string
    buildingName?: string | null
    floorNumber?: number | null
    numberOfRooms?: number | null
    priceSale: number
    squareFootage?: number | null
    location: string
    status: $Enums.UnitStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    Residents?: ResidentsCreateNestedManyWithoutUnitInput
    Payments?: PaymentsCreateNestedManyWithoutUnitInput
    Complaints?: ComplaintsCreateNestedManyWithoutUnitInput
  }

  export type UnitsUncheckedCreateWithoutBillsInput = {
    id?: string
    unitNumber: string
    buildingName?: string | null
    floorNumber?: number | null
    numberOfRooms?: number | null
    priceSale: number
    squareFootage?: number | null
    location: string
    status: $Enums.UnitStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    Residents?: ResidentsUncheckedCreateNestedManyWithoutUnitInput
    Payments?: PaymentsUncheckedCreateNestedManyWithoutUnitInput
    Complaints?: ComplaintsUncheckedCreateNestedManyWithoutUnitInput
  }

  export type UnitsCreateOrConnectWithoutBillsInput = {
    where: UnitsWhereUniqueInput
    create: XOR<UnitsCreateWithoutBillsInput, UnitsUncheckedCreateWithoutBillsInput>
  }

  export type EmployeesCreateWithoutBillsInput = {
    id?: string
    employeeNumberId: string
    hireDate: Date | string
    employeePosition?: $Enums.EmployeeRole
    workingHours: number
    salary: number
    bonus?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UsersCreateNestedOneWithoutEmployeeInput
    Announcements?: AnnouncementsCreateNestedManyWithoutEmployeeInput
    Complaints?: ComplaintsCreateNestedManyWithoutEmployeeInput
    Payments?: PaymentsCreateNestedManyWithoutProcessedByInput
    SecurityReports?: SecurityReportsCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeesUncheckedCreateWithoutBillsInput = {
    id?: string
    userId: string
    employeeNumberId: string
    hireDate: Date | string
    employeePosition?: $Enums.EmployeeRole
    workingHours: number
    salary: number
    bonus?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Announcements?: AnnouncementsUncheckedCreateNestedManyWithoutEmployeeInput
    Complaints?: ComplaintsUncheckedCreateNestedManyWithoutEmployeeInput
    Payments?: PaymentsUncheckedCreateNestedManyWithoutProcessedByInput
    SecurityReports?: SecurityReportsUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeesCreateOrConnectWithoutBillsInput = {
    where: EmployeesWhereUniqueInput
    create: XOR<EmployeesCreateWithoutBillsInput, EmployeesUncheckedCreateWithoutBillsInput>
  }

  export type PaymentsCreateWithoutBillInput = {
    id?: string
    amount: number
    paymentDate?: Date | string
    paymentMethod: $Enums.PaymentMethod
    status: $Enums.PaymentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    resident: ResidentsCreateNestedOneWithoutPaymentsInput
    unit?: UnitsCreateNestedOneWithoutPaymentsInput
    processedBy?: EmployeesCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentsUncheckedCreateWithoutBillInput = {
    id?: string
    amount: number
    paymentDate?: Date | string
    paymentMethod: $Enums.PaymentMethod
    status: $Enums.PaymentStatus
    residentId: string
    unitId?: string | null
    processedByEmployeeId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentsCreateOrConnectWithoutBillInput = {
    where: PaymentsWhereUniqueInput
    create: XOR<PaymentsCreateWithoutBillInput, PaymentsUncheckedCreateWithoutBillInput>
  }

  export type PaymentsCreateManyBillInputEnvelope = {
    data: PaymentsCreateManyBillInput | PaymentsCreateManyBillInput[]
    skipDuplicates?: boolean
  }

  export type UnitsUpsertWithoutBillsInput = {
    update: XOR<UnitsUpdateWithoutBillsInput, UnitsUncheckedUpdateWithoutBillsInput>
    create: XOR<UnitsCreateWithoutBillsInput, UnitsUncheckedCreateWithoutBillsInput>
    where?: UnitsWhereInput
  }

  export type UnitsUpdateToOneWithWhereWithoutBillsInput = {
    where?: UnitsWhereInput
    data: XOR<UnitsUpdateWithoutBillsInput, UnitsUncheckedUpdateWithoutBillsInput>
  }

  export type UnitsUpdateWithoutBillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    unitNumber?: StringFieldUpdateOperationsInput | string
    buildingName?: NullableStringFieldUpdateOperationsInput | string | null
    floorNumber?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfRooms?: NullableIntFieldUpdateOperationsInput | number | null
    priceSale?: FloatFieldUpdateOperationsInput | number
    squareFootage?: NullableIntFieldUpdateOperationsInput | number | null
    location?: StringFieldUpdateOperationsInput | string
    status?: EnumUnitStatusFieldUpdateOperationsInput | $Enums.UnitStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Residents?: ResidentsUpdateManyWithoutUnitNestedInput
    Payments?: PaymentsUpdateManyWithoutUnitNestedInput
    Complaints?: ComplaintsUpdateManyWithoutUnitNestedInput
  }

  export type UnitsUncheckedUpdateWithoutBillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    unitNumber?: StringFieldUpdateOperationsInput | string
    buildingName?: NullableStringFieldUpdateOperationsInput | string | null
    floorNumber?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfRooms?: NullableIntFieldUpdateOperationsInput | number | null
    priceSale?: FloatFieldUpdateOperationsInput | number
    squareFootage?: NullableIntFieldUpdateOperationsInput | number | null
    location?: StringFieldUpdateOperationsInput | string
    status?: EnumUnitStatusFieldUpdateOperationsInput | $Enums.UnitStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Residents?: ResidentsUncheckedUpdateManyWithoutUnitNestedInput
    Payments?: PaymentsUncheckedUpdateManyWithoutUnitNestedInput
    Complaints?: ComplaintsUncheckedUpdateManyWithoutUnitNestedInput
  }

  export type EmployeesUpsertWithoutBillsInput = {
    update: XOR<EmployeesUpdateWithoutBillsInput, EmployeesUncheckedUpdateWithoutBillsInput>
    create: XOR<EmployeesCreateWithoutBillsInput, EmployeesUncheckedCreateWithoutBillsInput>
    where?: EmployeesWhereInput
  }

  export type EmployeesUpdateToOneWithWhereWithoutBillsInput = {
    where?: EmployeesWhereInput
    data: XOR<EmployeesUpdateWithoutBillsInput, EmployeesUncheckedUpdateWithoutBillsInput>
  }

  export type EmployeesUpdateWithoutBillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeNumberId?: StringFieldUpdateOperationsInput | string
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    employeePosition?: EnumEmployeeRoleFieldUpdateOperationsInput | $Enums.EmployeeRole
    workingHours?: IntFieldUpdateOperationsInput | number
    salary?: FloatFieldUpdateOperationsInput | number
    bonus?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UsersUpdateOneRequiredWithoutEmployeeNestedInput
    Announcements?: AnnouncementsUpdateManyWithoutEmployeeNestedInput
    Complaints?: ComplaintsUpdateManyWithoutEmployeeNestedInput
    Payments?: PaymentsUpdateManyWithoutProcessedByNestedInput
    SecurityReports?: SecurityReportsUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeesUncheckedUpdateWithoutBillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    employeeNumberId?: StringFieldUpdateOperationsInput | string
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    employeePosition?: EnumEmployeeRoleFieldUpdateOperationsInput | $Enums.EmployeeRole
    workingHours?: IntFieldUpdateOperationsInput | number
    salary?: FloatFieldUpdateOperationsInput | number
    bonus?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Announcements?: AnnouncementsUncheckedUpdateManyWithoutEmployeeNestedInput
    Complaints?: ComplaintsUncheckedUpdateManyWithoutEmployeeNestedInput
    Payments?: PaymentsUncheckedUpdateManyWithoutProcessedByNestedInput
    SecurityReports?: SecurityReportsUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type PaymentsUpsertWithWhereUniqueWithoutBillInput = {
    where: PaymentsWhereUniqueInput
    update: XOR<PaymentsUpdateWithoutBillInput, PaymentsUncheckedUpdateWithoutBillInput>
    create: XOR<PaymentsCreateWithoutBillInput, PaymentsUncheckedCreateWithoutBillInput>
  }

  export type PaymentsUpdateWithWhereUniqueWithoutBillInput = {
    where: PaymentsWhereUniqueInput
    data: XOR<PaymentsUpdateWithoutBillInput, PaymentsUncheckedUpdateWithoutBillInput>
  }

  export type PaymentsUpdateManyWithWhereWithoutBillInput = {
    where: PaymentsScalarWhereInput
    data: XOR<PaymentsUpdateManyMutationInput, PaymentsUncheckedUpdateManyWithoutBillInput>
  }

  export type ResidentsCreateWithoutPaymentsInput = {
    id?: string
    emergencyContactName?: string | null
    emergencyContactNumber?: string | null
    movedInDate: Date | string
    movedOutDate?: Date | string | null
    residentStatus?: $Enums.ResidentStatus | null
    kprPaymentAmount?: number | null
    kprDueDate?: Date | string | null
    isKprPaid?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UsersCreateNestedOneWithoutResidentInput
    unit?: UnitsCreateNestedOneWithoutResidentsInput
    Complaints?: ComplaintsCreateNestedManyWithoutResidentInput
  }

  export type ResidentsUncheckedCreateWithoutPaymentsInput = {
    id?: string
    userId: string
    emergencyContactName?: string | null
    emergencyContactNumber?: string | null
    movedInDate: Date | string
    movedOutDate?: Date | string | null
    residentStatus?: $Enums.ResidentStatus | null
    unitId?: string | null
    kprPaymentAmount?: number | null
    kprDueDate?: Date | string | null
    isKprPaid?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Complaints?: ComplaintsUncheckedCreateNestedManyWithoutResidentInput
  }

  export type ResidentsCreateOrConnectWithoutPaymentsInput = {
    where: ResidentsWhereUniqueInput
    create: XOR<ResidentsCreateWithoutPaymentsInput, ResidentsUncheckedCreateWithoutPaymentsInput>
  }

  export type UnitsCreateWithoutPaymentsInput = {
    id?: string
    unitNumber: string
    buildingName?: string | null
    floorNumber?: number | null
    numberOfRooms?: number | null
    priceSale: number
    squareFootage?: number | null
    location: string
    status: $Enums.UnitStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    Residents?: ResidentsCreateNestedManyWithoutUnitInput
    Bills?: BillsCreateNestedManyWithoutUnitInput
    Complaints?: ComplaintsCreateNestedManyWithoutUnitInput
  }

  export type UnitsUncheckedCreateWithoutPaymentsInput = {
    id?: string
    unitNumber: string
    buildingName?: string | null
    floorNumber?: number | null
    numberOfRooms?: number | null
    priceSale: number
    squareFootage?: number | null
    location: string
    status: $Enums.UnitStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    Residents?: ResidentsUncheckedCreateNestedManyWithoutUnitInput
    Bills?: BillsUncheckedCreateNestedManyWithoutUnitInput
    Complaints?: ComplaintsUncheckedCreateNestedManyWithoutUnitInput
  }

  export type UnitsCreateOrConnectWithoutPaymentsInput = {
    where: UnitsWhereUniqueInput
    create: XOR<UnitsCreateWithoutPaymentsInput, UnitsUncheckedCreateWithoutPaymentsInput>
  }

  export type EmployeesCreateWithoutPaymentsInput = {
    id?: string
    employeeNumberId: string
    hireDate: Date | string
    employeePosition?: $Enums.EmployeeRole
    workingHours: number
    salary: number
    bonus?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UsersCreateNestedOneWithoutEmployeeInput
    Announcements?: AnnouncementsCreateNestedManyWithoutEmployeeInput
    Complaints?: ComplaintsCreateNestedManyWithoutEmployeeInput
    Bills?: BillsCreateNestedManyWithoutEmployeeInput
    SecurityReports?: SecurityReportsCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeesUncheckedCreateWithoutPaymentsInput = {
    id?: string
    userId: string
    employeeNumberId: string
    hireDate: Date | string
    employeePosition?: $Enums.EmployeeRole
    workingHours: number
    salary: number
    bonus?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Announcements?: AnnouncementsUncheckedCreateNestedManyWithoutEmployeeInput
    Complaints?: ComplaintsUncheckedCreateNestedManyWithoutEmployeeInput
    Bills?: BillsUncheckedCreateNestedManyWithoutEmployeeInput
    SecurityReports?: SecurityReportsUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeesCreateOrConnectWithoutPaymentsInput = {
    where: EmployeesWhereUniqueInput
    create: XOR<EmployeesCreateWithoutPaymentsInput, EmployeesUncheckedCreateWithoutPaymentsInput>
  }

  export type BillsCreateWithoutPaymentsInput = {
    id?: string
    amount: number
    type: $Enums.PaymentType
    dueDate: Date | string
    isPaid?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    unit: UnitsCreateNestedOneWithoutBillsInput
    employee: EmployeesCreateNestedOneWithoutBillsInput
  }

  export type BillsUncheckedCreateWithoutPaymentsInput = {
    id?: string
    amount: number
    type: $Enums.PaymentType
    dueDate: Date | string
    isPaid?: boolean
    unitId: string
    employeeId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BillsCreateOrConnectWithoutPaymentsInput = {
    where: BillsWhereUniqueInput
    create: XOR<BillsCreateWithoutPaymentsInput, BillsUncheckedCreateWithoutPaymentsInput>
  }

  export type ResidentsUpsertWithoutPaymentsInput = {
    update: XOR<ResidentsUpdateWithoutPaymentsInput, ResidentsUncheckedUpdateWithoutPaymentsInput>
    create: XOR<ResidentsCreateWithoutPaymentsInput, ResidentsUncheckedCreateWithoutPaymentsInput>
    where?: ResidentsWhereInput
  }

  export type ResidentsUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: ResidentsWhereInput
    data: XOR<ResidentsUpdateWithoutPaymentsInput, ResidentsUncheckedUpdateWithoutPaymentsInput>
  }

  export type ResidentsUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    movedInDate?: DateTimeFieldUpdateOperationsInput | Date | string
    movedOutDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    residentStatus?: NullableEnumResidentStatusFieldUpdateOperationsInput | $Enums.ResidentStatus | null
    kprPaymentAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    kprDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isKprPaid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UsersUpdateOneRequiredWithoutResidentNestedInput
    unit?: UnitsUpdateOneWithoutResidentsNestedInput
    Complaints?: ComplaintsUpdateManyWithoutResidentNestedInput
  }

  export type ResidentsUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    movedInDate?: DateTimeFieldUpdateOperationsInput | Date | string
    movedOutDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    residentStatus?: NullableEnumResidentStatusFieldUpdateOperationsInput | $Enums.ResidentStatus | null
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
    kprPaymentAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    kprDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isKprPaid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Complaints?: ComplaintsUncheckedUpdateManyWithoutResidentNestedInput
  }

  export type UnitsUpsertWithoutPaymentsInput = {
    update: XOR<UnitsUpdateWithoutPaymentsInput, UnitsUncheckedUpdateWithoutPaymentsInput>
    create: XOR<UnitsCreateWithoutPaymentsInput, UnitsUncheckedCreateWithoutPaymentsInput>
    where?: UnitsWhereInput
  }

  export type UnitsUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: UnitsWhereInput
    data: XOR<UnitsUpdateWithoutPaymentsInput, UnitsUncheckedUpdateWithoutPaymentsInput>
  }

  export type UnitsUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    unitNumber?: StringFieldUpdateOperationsInput | string
    buildingName?: NullableStringFieldUpdateOperationsInput | string | null
    floorNumber?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfRooms?: NullableIntFieldUpdateOperationsInput | number | null
    priceSale?: FloatFieldUpdateOperationsInput | number
    squareFootage?: NullableIntFieldUpdateOperationsInput | number | null
    location?: StringFieldUpdateOperationsInput | string
    status?: EnumUnitStatusFieldUpdateOperationsInput | $Enums.UnitStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Residents?: ResidentsUpdateManyWithoutUnitNestedInput
    Bills?: BillsUpdateManyWithoutUnitNestedInput
    Complaints?: ComplaintsUpdateManyWithoutUnitNestedInput
  }

  export type UnitsUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    unitNumber?: StringFieldUpdateOperationsInput | string
    buildingName?: NullableStringFieldUpdateOperationsInput | string | null
    floorNumber?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfRooms?: NullableIntFieldUpdateOperationsInput | number | null
    priceSale?: FloatFieldUpdateOperationsInput | number
    squareFootage?: NullableIntFieldUpdateOperationsInput | number | null
    location?: StringFieldUpdateOperationsInput | string
    status?: EnumUnitStatusFieldUpdateOperationsInput | $Enums.UnitStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Residents?: ResidentsUncheckedUpdateManyWithoutUnitNestedInput
    Bills?: BillsUncheckedUpdateManyWithoutUnitNestedInput
    Complaints?: ComplaintsUncheckedUpdateManyWithoutUnitNestedInput
  }

  export type EmployeesUpsertWithoutPaymentsInput = {
    update: XOR<EmployeesUpdateWithoutPaymentsInput, EmployeesUncheckedUpdateWithoutPaymentsInput>
    create: XOR<EmployeesCreateWithoutPaymentsInput, EmployeesUncheckedCreateWithoutPaymentsInput>
    where?: EmployeesWhereInput
  }

  export type EmployeesUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: EmployeesWhereInput
    data: XOR<EmployeesUpdateWithoutPaymentsInput, EmployeesUncheckedUpdateWithoutPaymentsInput>
  }

  export type EmployeesUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeNumberId?: StringFieldUpdateOperationsInput | string
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    employeePosition?: EnumEmployeeRoleFieldUpdateOperationsInput | $Enums.EmployeeRole
    workingHours?: IntFieldUpdateOperationsInput | number
    salary?: FloatFieldUpdateOperationsInput | number
    bonus?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UsersUpdateOneRequiredWithoutEmployeeNestedInput
    Announcements?: AnnouncementsUpdateManyWithoutEmployeeNestedInput
    Complaints?: ComplaintsUpdateManyWithoutEmployeeNestedInput
    Bills?: BillsUpdateManyWithoutEmployeeNestedInput
    SecurityReports?: SecurityReportsUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeesUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    employeeNumberId?: StringFieldUpdateOperationsInput | string
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    employeePosition?: EnumEmployeeRoleFieldUpdateOperationsInput | $Enums.EmployeeRole
    workingHours?: IntFieldUpdateOperationsInput | number
    salary?: FloatFieldUpdateOperationsInput | number
    bonus?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Announcements?: AnnouncementsUncheckedUpdateManyWithoutEmployeeNestedInput
    Complaints?: ComplaintsUncheckedUpdateManyWithoutEmployeeNestedInput
    Bills?: BillsUncheckedUpdateManyWithoutEmployeeNestedInput
    SecurityReports?: SecurityReportsUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type BillsUpsertWithoutPaymentsInput = {
    update: XOR<BillsUpdateWithoutPaymentsInput, BillsUncheckedUpdateWithoutPaymentsInput>
    create: XOR<BillsCreateWithoutPaymentsInput, BillsUncheckedCreateWithoutPaymentsInput>
    where?: BillsWhereInput
  }

  export type BillsUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: BillsWhereInput
    data: XOR<BillsUpdateWithoutPaymentsInput, BillsUncheckedUpdateWithoutPaymentsInput>
  }

  export type BillsUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    type?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    unit?: UnitsUpdateOneRequiredWithoutBillsNestedInput
    employee?: EmployeesUpdateOneRequiredWithoutBillsNestedInput
  }

  export type BillsUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    type?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    unitId?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeesCreateWithoutSecurityReportsInput = {
    id?: string
    employeeNumberId: string
    hireDate: Date | string
    employeePosition?: $Enums.EmployeeRole
    workingHours: number
    salary: number
    bonus?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UsersCreateNestedOneWithoutEmployeeInput
    Announcements?: AnnouncementsCreateNestedManyWithoutEmployeeInput
    Complaints?: ComplaintsCreateNestedManyWithoutEmployeeInput
    Bills?: BillsCreateNestedManyWithoutEmployeeInput
    Payments?: PaymentsCreateNestedManyWithoutProcessedByInput
  }

  export type EmployeesUncheckedCreateWithoutSecurityReportsInput = {
    id?: string
    userId: string
    employeeNumberId: string
    hireDate: Date | string
    employeePosition?: $Enums.EmployeeRole
    workingHours: number
    salary: number
    bonus?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Announcements?: AnnouncementsUncheckedCreateNestedManyWithoutEmployeeInput
    Complaints?: ComplaintsUncheckedCreateNestedManyWithoutEmployeeInput
    Bills?: BillsUncheckedCreateNestedManyWithoutEmployeeInput
    Payments?: PaymentsUncheckedCreateNestedManyWithoutProcessedByInput
  }

  export type EmployeesCreateOrConnectWithoutSecurityReportsInput = {
    where: EmployeesWhereUniqueInput
    create: XOR<EmployeesCreateWithoutSecurityReportsInput, EmployeesUncheckedCreateWithoutSecurityReportsInput>
  }

  export type EmployeesUpsertWithoutSecurityReportsInput = {
    update: XOR<EmployeesUpdateWithoutSecurityReportsInput, EmployeesUncheckedUpdateWithoutSecurityReportsInput>
    create: XOR<EmployeesCreateWithoutSecurityReportsInput, EmployeesUncheckedCreateWithoutSecurityReportsInput>
    where?: EmployeesWhereInput
  }

  export type EmployeesUpdateToOneWithWhereWithoutSecurityReportsInput = {
    where?: EmployeesWhereInput
    data: XOR<EmployeesUpdateWithoutSecurityReportsInput, EmployeesUncheckedUpdateWithoutSecurityReportsInput>
  }

  export type EmployeesUpdateWithoutSecurityReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeNumberId?: StringFieldUpdateOperationsInput | string
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    employeePosition?: EnumEmployeeRoleFieldUpdateOperationsInput | $Enums.EmployeeRole
    workingHours?: IntFieldUpdateOperationsInput | number
    salary?: FloatFieldUpdateOperationsInput | number
    bonus?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UsersUpdateOneRequiredWithoutEmployeeNestedInput
    Announcements?: AnnouncementsUpdateManyWithoutEmployeeNestedInput
    Complaints?: ComplaintsUpdateManyWithoutEmployeeNestedInput
    Bills?: BillsUpdateManyWithoutEmployeeNestedInput
    Payments?: PaymentsUpdateManyWithoutProcessedByNestedInput
  }

  export type EmployeesUncheckedUpdateWithoutSecurityReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    employeeNumberId?: StringFieldUpdateOperationsInput | string
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    employeePosition?: EnumEmployeeRoleFieldUpdateOperationsInput | $Enums.EmployeeRole
    workingHours?: IntFieldUpdateOperationsInput | number
    salary?: FloatFieldUpdateOperationsInput | number
    bonus?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Announcements?: AnnouncementsUncheckedUpdateManyWithoutEmployeeNestedInput
    Complaints?: ComplaintsUncheckedUpdateManyWithoutEmployeeNestedInput
    Bills?: BillsUncheckedUpdateManyWithoutEmployeeNestedInput
    Payments?: PaymentsUncheckedUpdateManyWithoutProcessedByNestedInput
  }

  export type ForumPostsCreateManyUserInput = {
    id?: string
    title: string
    content: string
    attachments?: ForumPostsCreateattachmentsInput | string[]
    authorRole: $Enums.UserRole
    publishedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ForumCommentsCreateManyUserInput = {
    id?: string
    content: string
    postId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ForumPostsUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    attachments?: ForumPostsUpdateattachmentsInput | string[]
    authorRole?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tags?: PostTagsUpdateManyWithoutPostsNestedInput
    comments?: ForumCommentsUpdateManyWithoutPostNestedInput
  }

  export type ForumPostsUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    attachments?: ForumPostsUpdateattachmentsInput | string[]
    authorRole?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tags?: PostTagsUncheckedUpdateManyWithoutPostsNestedInput
    comments?: ForumCommentsUncheckedUpdateManyWithoutPostNestedInput
  }

  export type ForumPostsUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    attachments?: ForumPostsUpdateattachmentsInput | string[]
    authorRole?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ForumCommentsUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: ForumPostsUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type ForumCommentsUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ForumCommentsUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplaintsCreateManyResidentInput = {
    id?: string
    title: string
    description: string
    category: $Enums.MaintenanceCategory
    status?: $Enums.ComplaintStatus
    images?: ComplaintsCreateimagesInput | string[]
    submittedAt?: Date | string
    resolvedAt?: Date | string | null
    resolutionDetails?: string | null
    employeeId?: string | null
    unitId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentsCreateManyResidentInput = {
    id?: string
    amount: number
    paymentDate?: Date | string
    paymentMethod: $Enums.PaymentMethod
    status: $Enums.PaymentStatus
    unitId?: string | null
    processedByEmployeeId?: string | null
    billId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ComplaintsUpdateWithoutResidentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumMaintenanceCategoryFieldUpdateOperationsInput | $Enums.MaintenanceCategory
    status?: EnumComplaintStatusFieldUpdateOperationsInput | $Enums.ComplaintStatus
    images?: ComplaintsUpdateimagesInput | string[]
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolutionDetails?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeesUpdateOneWithoutComplaintsNestedInput
    unit?: UnitsUpdateOneWithoutComplaintsNestedInput
  }

  export type ComplaintsUncheckedUpdateWithoutResidentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumMaintenanceCategoryFieldUpdateOperationsInput | $Enums.MaintenanceCategory
    status?: EnumComplaintStatusFieldUpdateOperationsInput | $Enums.ComplaintStatus
    images?: ComplaintsUpdateimagesInput | string[]
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolutionDetails?: NullableStringFieldUpdateOperationsInput | string | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplaintsUncheckedUpdateManyWithoutResidentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumMaintenanceCategoryFieldUpdateOperationsInput | $Enums.MaintenanceCategory
    status?: EnumComplaintStatusFieldUpdateOperationsInput | $Enums.ComplaintStatus
    images?: ComplaintsUpdateimagesInput | string[]
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolutionDetails?: NullableStringFieldUpdateOperationsInput | string | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentsUpdateWithoutResidentInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    unit?: UnitsUpdateOneWithoutPaymentsNestedInput
    processedBy?: EmployeesUpdateOneWithoutPaymentsNestedInput
    bill?: BillsUpdateOneWithoutPaymentsNestedInput
  }

  export type PaymentsUncheckedUpdateWithoutResidentInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
    processedByEmployeeId?: NullableStringFieldUpdateOperationsInput | string | null
    billId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentsUncheckedUpdateManyWithoutResidentInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
    processedByEmployeeId?: NullableStringFieldUpdateOperationsInput | string | null
    billId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnnouncementsCreateManyEmployeeInput = {
    id?: string
    title: string
    content: string
    attachments?: AnnouncementsCreateattachmentsInput | string[]
    publishDate?: Date | string
    expiryDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ComplaintsCreateManyEmployeeInput = {
    id?: string
    title: string
    description: string
    category: $Enums.MaintenanceCategory
    status?: $Enums.ComplaintStatus
    images?: ComplaintsCreateimagesInput | string[]
    submittedAt?: Date | string
    resolvedAt?: Date | string | null
    resolutionDetails?: string | null
    residentId: string
    unitId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BillsCreateManyEmployeeInput = {
    id?: string
    amount: number
    type: $Enums.PaymentType
    dueDate: Date | string
    isPaid?: boolean
    unitId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentsCreateManyProcessedByInput = {
    id?: string
    amount: number
    paymentDate?: Date | string
    paymentMethod: $Enums.PaymentMethod
    status: $Enums.PaymentStatus
    residentId: string
    unitId?: string | null
    billId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SecurityReportsCreateManyEmployeeInput = {
    id?: string
    title: string
    description: string
    location: string
    incidentDate: Date | string
    status: $Enums.MaintenanceStatus
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AnnouncementsUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    attachments?: AnnouncementsUpdateattachmentsInput | string[]
    publishDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnnouncementsUncheckedUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    attachments?: AnnouncementsUpdateattachmentsInput | string[]
    publishDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnnouncementsUncheckedUpdateManyWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    attachments?: AnnouncementsUpdateattachmentsInput | string[]
    publishDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplaintsUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumMaintenanceCategoryFieldUpdateOperationsInput | $Enums.MaintenanceCategory
    status?: EnumComplaintStatusFieldUpdateOperationsInput | $Enums.ComplaintStatus
    images?: ComplaintsUpdateimagesInput | string[]
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolutionDetails?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resident?: ResidentsUpdateOneRequiredWithoutComplaintsNestedInput
    unit?: UnitsUpdateOneWithoutComplaintsNestedInput
  }

  export type ComplaintsUncheckedUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumMaintenanceCategoryFieldUpdateOperationsInput | $Enums.MaintenanceCategory
    status?: EnumComplaintStatusFieldUpdateOperationsInput | $Enums.ComplaintStatus
    images?: ComplaintsUpdateimagesInput | string[]
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolutionDetails?: NullableStringFieldUpdateOperationsInput | string | null
    residentId?: StringFieldUpdateOperationsInput | string
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplaintsUncheckedUpdateManyWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumMaintenanceCategoryFieldUpdateOperationsInput | $Enums.MaintenanceCategory
    status?: EnumComplaintStatusFieldUpdateOperationsInput | $Enums.ComplaintStatus
    images?: ComplaintsUpdateimagesInput | string[]
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolutionDetails?: NullableStringFieldUpdateOperationsInput | string | null
    residentId?: StringFieldUpdateOperationsInput | string
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillsUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    type?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    unit?: UnitsUpdateOneRequiredWithoutBillsNestedInput
    Payments?: PaymentsUpdateManyWithoutBillNestedInput
  }

  export type BillsUncheckedUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    type?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    unitId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Payments?: PaymentsUncheckedUpdateManyWithoutBillNestedInput
  }

  export type BillsUncheckedUpdateManyWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    type?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    unitId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentsUpdateWithoutProcessedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resident?: ResidentsUpdateOneRequiredWithoutPaymentsNestedInput
    unit?: UnitsUpdateOneWithoutPaymentsNestedInput
    bill?: BillsUpdateOneWithoutPaymentsNestedInput
  }

  export type PaymentsUncheckedUpdateWithoutProcessedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    residentId?: StringFieldUpdateOperationsInput | string
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
    billId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentsUncheckedUpdateManyWithoutProcessedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    residentId?: StringFieldUpdateOperationsInput | string
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
    billId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SecurityReportsUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    incidentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumMaintenanceStatusFieldUpdateOperationsInput | $Enums.MaintenanceStatus
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SecurityReportsUncheckedUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    incidentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumMaintenanceStatusFieldUpdateOperationsInput | $Enums.MaintenanceStatus
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SecurityReportsUncheckedUpdateManyWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    incidentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumMaintenanceStatusFieldUpdateOperationsInput | $Enums.MaintenanceStatus
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ForumCommentsCreateManyPostInput = {
    id?: string
    content: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PostTagsUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tagName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostTagsUncheckedUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tagName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostTagsUncheckedUpdateManyWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tagName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ForumCommentsUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UsersUpdateOneRequiredWithoutForumCommentsNestedInput
  }

  export type ForumCommentsUncheckedUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ForumCommentsUncheckedUpdateManyWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ForumPostsUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    attachments?: ForumPostsUpdateattachmentsInput | string[]
    authorRole?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UsersUpdateOneRequiredWithoutForumPostsNestedInput
    comments?: ForumCommentsUpdateManyWithoutPostNestedInput
  }

  export type ForumPostsUncheckedUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    attachments?: ForumPostsUpdateattachmentsInput | string[]
    authorRole?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    userId?: StringFieldUpdateOperationsInput | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: ForumCommentsUncheckedUpdateManyWithoutPostNestedInput
  }

  export type ForumPostsUncheckedUpdateManyWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    attachments?: ForumPostsUpdateattachmentsInput | string[]
    authorRole?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    userId?: StringFieldUpdateOperationsInput | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResidentsCreateManyUnitInput = {
    id?: string
    userId: string
    emergencyContactName?: string | null
    emergencyContactNumber?: string | null
    movedInDate: Date | string
    movedOutDate?: Date | string | null
    residentStatus?: $Enums.ResidentStatus | null
    kprPaymentAmount?: number | null
    kprDueDate?: Date | string | null
    isKprPaid?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentsCreateManyUnitInput = {
    id?: string
    amount: number
    paymentDate?: Date | string
    paymentMethod: $Enums.PaymentMethod
    status: $Enums.PaymentStatus
    residentId: string
    processedByEmployeeId?: string | null
    billId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BillsCreateManyUnitInput = {
    id?: string
    amount: number
    type: $Enums.PaymentType
    dueDate: Date | string
    isPaid?: boolean
    employeeId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ComplaintsCreateManyUnitInput = {
    id?: string
    title: string
    description: string
    category: $Enums.MaintenanceCategory
    status?: $Enums.ComplaintStatus
    images?: ComplaintsCreateimagesInput | string[]
    submittedAt?: Date | string
    resolvedAt?: Date | string | null
    resolutionDetails?: string | null
    residentId: string
    employeeId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResidentsUpdateWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    movedInDate?: DateTimeFieldUpdateOperationsInput | Date | string
    movedOutDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    residentStatus?: NullableEnumResidentStatusFieldUpdateOperationsInput | $Enums.ResidentStatus | null
    kprPaymentAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    kprDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isKprPaid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UsersUpdateOneRequiredWithoutResidentNestedInput
    Complaints?: ComplaintsUpdateManyWithoutResidentNestedInput
    Payments?: PaymentsUpdateManyWithoutResidentNestedInput
  }

  export type ResidentsUncheckedUpdateWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    movedInDate?: DateTimeFieldUpdateOperationsInput | Date | string
    movedOutDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    residentStatus?: NullableEnumResidentStatusFieldUpdateOperationsInput | $Enums.ResidentStatus | null
    kprPaymentAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    kprDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isKprPaid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Complaints?: ComplaintsUncheckedUpdateManyWithoutResidentNestedInput
    Payments?: PaymentsUncheckedUpdateManyWithoutResidentNestedInput
  }

  export type ResidentsUncheckedUpdateManyWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    movedInDate?: DateTimeFieldUpdateOperationsInput | Date | string
    movedOutDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    residentStatus?: NullableEnumResidentStatusFieldUpdateOperationsInput | $Enums.ResidentStatus | null
    kprPaymentAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    kprDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isKprPaid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentsUpdateWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resident?: ResidentsUpdateOneRequiredWithoutPaymentsNestedInput
    processedBy?: EmployeesUpdateOneWithoutPaymentsNestedInput
    bill?: BillsUpdateOneWithoutPaymentsNestedInput
  }

  export type PaymentsUncheckedUpdateWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    residentId?: StringFieldUpdateOperationsInput | string
    processedByEmployeeId?: NullableStringFieldUpdateOperationsInput | string | null
    billId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentsUncheckedUpdateManyWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    residentId?: StringFieldUpdateOperationsInput | string
    processedByEmployeeId?: NullableStringFieldUpdateOperationsInput | string | null
    billId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillsUpdateWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    type?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeesUpdateOneRequiredWithoutBillsNestedInput
    Payments?: PaymentsUpdateManyWithoutBillNestedInput
  }

  export type BillsUncheckedUpdateWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    type?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    employeeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Payments?: PaymentsUncheckedUpdateManyWithoutBillNestedInput
  }

  export type BillsUncheckedUpdateManyWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    type?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    employeeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplaintsUpdateWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumMaintenanceCategoryFieldUpdateOperationsInput | $Enums.MaintenanceCategory
    status?: EnumComplaintStatusFieldUpdateOperationsInput | $Enums.ComplaintStatus
    images?: ComplaintsUpdateimagesInput | string[]
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolutionDetails?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resident?: ResidentsUpdateOneRequiredWithoutComplaintsNestedInput
    employee?: EmployeesUpdateOneWithoutComplaintsNestedInput
  }

  export type ComplaintsUncheckedUpdateWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumMaintenanceCategoryFieldUpdateOperationsInput | $Enums.MaintenanceCategory
    status?: EnumComplaintStatusFieldUpdateOperationsInput | $Enums.ComplaintStatus
    images?: ComplaintsUpdateimagesInput | string[]
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolutionDetails?: NullableStringFieldUpdateOperationsInput | string | null
    residentId?: StringFieldUpdateOperationsInput | string
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplaintsUncheckedUpdateManyWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumMaintenanceCategoryFieldUpdateOperationsInput | $Enums.MaintenanceCategory
    status?: EnumComplaintStatusFieldUpdateOperationsInput | $Enums.ComplaintStatus
    images?: ComplaintsUpdateimagesInput | string[]
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolutionDetails?: NullableStringFieldUpdateOperationsInput | string | null
    residentId?: StringFieldUpdateOperationsInput | string
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentsCreateManyBillInput = {
    id?: string
    amount: number
    paymentDate?: Date | string
    paymentMethod: $Enums.PaymentMethod
    status: $Enums.PaymentStatus
    residentId: string
    unitId?: string | null
    processedByEmployeeId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentsUpdateWithoutBillInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resident?: ResidentsUpdateOneRequiredWithoutPaymentsNestedInput
    unit?: UnitsUpdateOneWithoutPaymentsNestedInput
    processedBy?: EmployeesUpdateOneWithoutPaymentsNestedInput
  }

  export type PaymentsUncheckedUpdateWithoutBillInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    residentId?: StringFieldUpdateOperationsInput | string
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
    processedByEmployeeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentsUncheckedUpdateManyWithoutBillInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    residentId?: StringFieldUpdateOperationsInput | string
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
    processedByEmployeeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}